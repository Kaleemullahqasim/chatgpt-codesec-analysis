problem§compiled§cppcheck§flawfinder§gcc
1§True§collected_code/problem-1-0.c:12:24: error: Cannot determine that 'cost[0][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n     tc[0][0] = cost[0][0];\n                       ^\ncollected_code/problem-1-0.c:16:40: error: Cannot determine that 'cost[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        tc[i][0] = tc[i-1][0] + cost[i][0];\n                                       ^\ncollected_code/problem-1-0.c:20:40: error: Cannot determine that 'cost[0][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        tc[0][j] = tc[0][j-1] + cost[0][j];\n                                       ^\ncollected_code/problem-1-0.c:27:49: error: Cannot determine that 'cost[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                           tc[i][j-1]) + cost[i][j];\n                                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-1-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 47 in approximately 0.01 seconds (7765 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 28.5714 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
2§True§"collected_code/problem-2-0.c:8:22: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list1[i] == list2[j]) {\n                     ^\ncollected_code/problem-2-0.c:8:34: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list1[i] == list2[j]) {\n                                 ^\ncollected_code/problem-2-0.c:9:36: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                printf(""%d "", list1[i]);\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-2-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3756 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
3§True§"collected_code/problem-3-0.c:37:21: error: Cannot determine that 'start' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &start, &end);\n                    ^\ncollected_code/problem-3-0.c:37:29: error: Cannot determine that 'end' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &start, &end);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-3-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.39 seconds (105 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 185.185 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
4§True§"collected_code/problem-4-0.c:5:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-4-0.c:6:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-4-0.c:15:24: error: Cannot determine that 'arr[left]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] > arr[largest])\n                       ^\ncollected_code/problem-4-0.c:15:36: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] > arr[largest])\n                                   ^\ncollected_code/problem-4-0.c:18:25: error: Cannot determine that 'arr[right]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] > arr[largest])\n                        ^\ncollected_code/problem-4-0.c:18:38: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] > arr[largest])\n                                     ^\ncollected_code/problem-4-0.c:38:26: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr[0]);\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-4-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 52 in approximately 0.01 seconds (9089 lines/second)\nPhysical Source Lines of Code (SLOC) = 40\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  25 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
5§True§"collected_code/problem-5-0.c:9:30: error: Array 'A[2147483648]' accessed at index -1, which is out of bounds. [negativeIndex]\n        A[i] = A[i-2] * 4 - A[i-4];\n                             ^\ncollected_code/problem-5-0.c:8:18: note: Assignment 'i=3', assigned value is 3\n    for (int i = 3; i <= n; i++) {\n                 ^\ncollected_code/problem-5-0.c:9:30: note: Negative array index\n        A[i] = A[i-2] * 4 - A[i-4];\n                             ^\ncollected_code/problem-5-0.c:17:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-5-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.64 seconds (29 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-5-0.c: In function 'countWays':\ncollected_code/problem-5-0.c:9:30: warning: stack-based buffer under-read [CWE-127] [-Wanalyzer-out-of-bounds]\n    9 |         A[i] = A[i-2] * 4 - A[i-4];\n      |                             ~^~~~~\n  'countWays': events 1-3\n    |\n    |    8 |     for (int i = 3; i <= n; i++) {\n    |      |                     ~~^~~~\n    |      |                       |\n    |      |                       (1) following 'true' branch (when 'i <= n')...\n    |    9 |         A[i] = A[i-2] * 4 - A[i-4];\n    |      |                  ~~~        ~~~~~~\n    |      |                   |          |\n    |      |                   |          (3) out-of-bounds read from byte -4 till byte -1 but region starts at byte 0\n    |      |                   (2) ...to here\n    |\ncollected_code/problem-5-0.c:9:30: warning: use of uninitialized value '*A[<unknown>]' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n    9 |         A[i] = A[i-2] * 4 - A[i-4];\n      |                             ~^~~~~\n  'countWays': events 1-4\n    |\n    |    4 |     int A[n+1];\n    |      |         ^\n    |      |         |\n    |      |         (1) region created on stack here\n    |......\n    |    8 |     for (int i = 3; i <= n; i++) {\n    |      |                     ~~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i <= n')...\n    |    9 |         A[i] = A[i-2] * 4 - A[i-4];\n    |      |                  ~~~        ~~~~~~\n    |      |                   |          |\n    |      |                   |          (4) use of uninitialized value '*A[<unknown>]' here\n    |      |                   (3) ...to here\n    |\ncollected_code/problem-5-0.c:9:30: warning: stack-based buffer under-read [CWE-127] [-Wanalyzer-out-of-bounds]\n    9 |         A[i] = A[i-2] * 4 - A[i-4];\n      |                             ~^~~~~\n  'main': events 1-2\n    |\n    |   14 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   18 |     printf(""Number of ways to fill the board: %d"", countWays(n));\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'countWays' from 'main'\n    |\n    +--> 'countWays': events 3-6\n           |\n           |    3 | int countWays(int n) {\n           |      |     ^~~~~~~~~\n           |      |     |\n           |      |     (3) entry to 'countWays'\n           |......\n           |    8 |     for (int i = 3; i <= n; i++) {\n           |      |                     ~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i <= n')...\n           |    9 |         A[i] = A[i-2] * 4 - A[i-4];\n           |      |                  ~~~        ~~~~~~\n           |      |                   |          |\n           |      |                   |          (6) out-of-bounds read from byte -4 till byte -1 but region starts at byte 0\n           |      |                   (5) ...to here\n           |\ncollected_code/problem-5-0.c:9:30: warning: use of uninitialized value '*A[<unknown>]' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n    9 |         A[i] = A[i-2] * 4 - A[i-4];\n      |                             ~^~~~~\n  'main': events 1-2\n    |\n    |   14 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   18 |     printf(""Number of ways to fill the board: %d"", countWays(n));\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'countWays' from 'main'\n    |\n    +--> 'countWays': events 3-7\n           |\n           |    3 | int countWays(int n) {\n           |      |     ^~~~~~~~~\n           |      |     |\n           |      |     (3) entry to 'countWays'\n           |    4 |     int A[n+1];\n           |      |         ~\n           |      |         |\n           |      |         (4) region created on stack here\n           |......\n           |    8 |     for (int i = 3; i <= n; i++) {\n           |      |                     ~~~~~~\n           |      |                       |\n           |      |                       (5) following 'true' branch (when 'i <= n')...\n           |    9 |         A[i] = A[i-2] * 4 - A[i-4];\n           |      |                  ~~~        ~~~~~~\n           |      |                   |          |\n           |      |                   |          (7) use of uninitialized value '*A[<unknown>]' here\n           |      |                   (6) ...to here\n           |\n"
6§True§"collected_code/problem-6-0.c:11:21: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                    ^\ncollected_code/problem-6-0.c:11:28: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-6-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.45 seconds (43 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
7§True§collected_code/problem-7-0.c:15:28: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (regexec(&regex, str, 1, matches, 0) == 0) {\n                           ^\ncollected_code/problem-7-0.c:16:29: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n        for (int i = matches[0].rm_so; i <= matches[0].rm_eo; i++) {\n                            ^\ncollected_code/problem-7-0.c:20:23: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n        str += matches[0].rm_eo;\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-7-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (3600 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
8§True§collected_code/problem-8-0.c:5:23: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        list[i] = list[i] * list[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-8-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.53 seconds (36 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
9§True§collected_code/problem-9-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\ncollected_code/problem-9-0.c:7:12: error: Cannot determine that 'concat[0]' is initialized [premium-bughuntingUninit]\n    strcpy(concat, str);\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-9-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-9-0.c:7:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-9-0.c:8:  [4] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused).\ncollected_code/problem-9-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 39 in approximately 0.02 seconds (1807 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   4 [1+]   3 [2+]   2 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 129.032 [1+] 96.7742 [2+] 64.5161 [3+] 64.5161 [4+] 64.5161 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-9-0.c: In function 'findMinRotations':\ncollected_code/problem-9-0.c:6:27: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n    6 |     char* concat = (char*)malloc(sizeof(char) * (len * 2 + 1));\n      |                           ^~~~~~\ncollected_code/problem-9-0.c:3:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    2 | #include <string.h>\n  +++ |+#include <stdlib.h>\n    3 | \ncollected_code/problem-9-0.c:6:27: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n    6 |     char* concat = (char*)malloc(sizeof(char) * (len * 2 + 1));\n      |                           ^~~~~~\ncollected_code/problem-9-0.c:6:27: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-9-0.c:29:5: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   29 |     free(concat);\n      |     ^~~~\ncollected_code/problem-9-0.c:29:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-9-0.c:29:5: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-9-0.c:29:5: note: include '<stdlib.h>' or provide a declaration of 'free'\n
10§True§collected_code/problem-10-0.c:8:30: error: Cannot determine that 'dataset[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        smallest[i] = dataset[i];\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-10-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.02 seconds (2505 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 68.9655 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
11§True§"collected_code/problem-11-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\ncollected_code/problem-11-0.c:48:17: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str);\n                ^\ncollected_code/problem-11-0.c:50:19: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf("" %c"", &c);\n                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-11-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-11-0.c:48:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-11-0.c:43:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-11-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 58 in approximately 0.01 seconds (5656 lines/second)\nPhysical Source Lines of Code (SLOC) = 38\nHits@level = [0]   4 [1]   1 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   7 [1+]   3 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 184.211 [1+] 78.9474 [2+] 52.6316 [3+] 26.3158 [4+] 26.3158 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
12§True§"collected_code/problem-12-0.c:10:35: error: Cannot determine that 'matrix[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            rowSum[i] += matrix[i][j];\n                                  ^\ncollected_code/problem-12-0.c:37:18: error: Cannot determine that 'rows' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &rows);\n                 ^\ncollected_code/problem-12-0.c:40:18: error: Cannot determine that 'columns' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &columns);\n                 ^\ncollected_code/problem-12-0.c:52:36: error: Cannot determine that 'matrix[i][j]' is initialized [premium-bughuntingUninit]\n            printf(""%d "", matrix[i][j]);\n                                   ^\ncollected_code/problem-12-0.c:62:36: error: Cannot determine that 'matrix[i][j]' is initialized [premium-bughuntingUninit]\n            printf(""%d "", matrix[i][j]);\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-12-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 67 in approximately 0.01 seconds (6079 lines/second)\nPhysical Source Lines of Code (SLOC) = 53\nHits@level = [0]  12 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]  12 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 226.415 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
13§True§"collected_code/problem-13-0.c:11:39: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        char *currentWord = dictionary[i];\n                                      ^\ncollected_code/problem-13-0.c:15:24: error: Cannot determine that 'currentWord' is initialized [premium-bughuntingUninit]\n            if (strcmp(currentWord, dictionary[j]) == 0) {\n                       ^\ncollected_code/problem-13-0.c:15:47: error: Cannot determine that 'dictionary[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strcmp(currentWord, dictionary[j]) == 0) {\n                                              ^\ncollected_code/problem-13-0.c:31:37: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf("" %s"", dictionary[i]);\n                                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-13-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 52 in approximately 0.02 seconds (2627 lines/second)\nPhysical Source Lines of Code (SLOC) = 41\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 73.1707 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
14§True§"collected_code/problem-14-0.c:12:18: error: Cannot determine that 'base' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &base);\n                 ^\ncollected_code/problem-14-0.c:15:18: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &height);\n                 ^\ncollected_code/problem-14-0.c:18:18: error: Cannot determine that 'depth' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &depth);\n                 ^\ncollected_code/problem-14-0.c:20:25: error: Cannot determine that 'base' is initialized [premium-bughuntingUninit]\n    volume = findVolume(base, height, depth);\n                        ^\ncollected_code/problem-14-0.c:20:31: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    volume = findVolume(base, height, depth);\n                              ^\ncollected_code/problem-14-0.c:20:39: error: Cannot determine that 'depth' is initialized [premium-bughuntingUninit]\n    volume = findVolume(base, height, depth);\n                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-14-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.38 seconds (61 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 411.765 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
15§True§"collected_code/problem-15-0.c:5:20: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; str[i] != '\0'; i++) {\n                   ^\ncollected_code/problem-15-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] >= 'a' && str[i] <= 'z') {\n               ^\ncollected_code/problem-15-0.c:9:29: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%c"", str[i]);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-15-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.10 seconds (174 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
16§True§"collected_code/problem-16-0.c:5:33: error: Cannot determine that 'input_string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; input_string[i] != '\0'; i++) {\n                                ^\ncollected_code/problem-16-0.c:6:25: error: Cannot determine that 'input_string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (input_string[i] >= 'a' && input_string[i] <= 'z') {\n                        ^\ncollected_code/problem-16-0.c:15:46: error: Cannot determine that 'input_string[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                    printf(""%c"", input_string[j]);\n                                             ^\ncollected_code/problem-16-0.c:24:38: error: Cannot determine that 'input_string[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%c"", input_string[j]);\n                                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-16-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (4945 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
17§True§"collected_code/problem-17-0.c:11:18: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &side);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-17-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2783 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
18§True§"collected_code/problem-18-0.c:5:25: error: Cannot determine that 'str1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str1[i] != '\0'; i++) {\n                        ^\ncollected_code/problem-18-0.c:7:29: error: Cannot determine that 'str2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        for (int j = 0; str2[j] != '\0'; j++) {\n                            ^\ncollected_code/problem-18-0.c:8:21: error: Cannot determine that 'str1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (str1[i] == str2[j]) {\n                    ^\ncollected_code/problem-18-0.c:8:32: error: Cannot determine that 'str2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (str1[i] == str2[j]) {\n                               ^\ncollected_code/problem-18-0.c:14:33: error: Cannot determine that 'str1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str1[count++] = str1[i];\n                                ^\ncollected_code/problem-18-0.c:23:17: error: Cannot determine that 'str1[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str1);\n                ^\ncollected_code/problem-18-0.c:25:17: error: Cannot determine that 'str2[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str2);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-18-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-18-0.c:23:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-18-0.c:25:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-18-0.c:21:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 30 in approximately 0.01 seconds (5061 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   6 [1+]   3 [2+]   3 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+] 111.111 [2+] 111.111 [3+] 74.0741 [4+] 74.0741 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
19§True§collected_code/problem-19-0.c:6:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr[i] == arr[j]) {\n                  ^\ncollected_code/problem-19-0.c:6:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr[i] == arr[j]) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-19-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.14 seconds (171 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
20§True§"collected_code/problem-20-0.c:26:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-20-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.40 seconds (75 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 160 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
21§True§"collected_code/problem-21-0.c:13:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-21-0.c:16:18: error: Cannot determine that 'm' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &m);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-21-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.53 seconds (37 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
22§True§collected_code/problem-22-0.c:7:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                   ^\ncollected_code/problem-22-0.c:7:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                             ^\ncollected_code/problem-22-0.c:8:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                return arr[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-22-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.30 seconds (82 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
23§True§collected_code/problem-23-0.c:7:37: error: Cannot determine that 'colCount[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        for (int j = 0; j < colCount[i]; j++) {\n                                    ^\ncollected_code/problem-23-0.c:8:27: error: Cannot determine that 'list[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += list[i][j];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-23-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (5570 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
24§True§"collected_code/problem-24-0.c:24:18: error: Cannot determine that 'binary' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &binary);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-24-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.38 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
25§True§collected_code/problem-25-0.c:13:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                   ^\ncollected_code/problem-25-0.c:13:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                             ^\ncollected_code/problem-25-0.c:19:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            product *= arr[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-25-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (5608 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
26§True§Checking collected_code/problem-26-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-26-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.40 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  80 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
27§True§collected_code/problem-27-0.c:9:12: error: Cannot determine that '*j' is initialized [premium-bughuntingUninit]\n    while (*j != '\0') {\n           ^\ncollected_code/problem-27-0.c:22:26: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        removeDigits(list[i]);\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-27-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.37 seconds (97 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 34.4828 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-27-0.c: In function 'removeDigits':\ncollected_code/problem-27-0.c:11:16: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   11 |             *i = *j;\n      |             ~~~^~~~\n  'main': events 1-2\n    |\n    |   26 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   30 |     removeDigitsFromList(list, size);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeDigitsFromList' from 'main'\n    |\n    +--> 'removeDigitsFromList': events 3-6\n           |\n           |   20 | void removeDigitsFromList(char **list, int size) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeDigitsFromList'\n           |   21 |     for (int i = 0; i < size; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < size')...\n           |   22 |         removeDigits(list[i]);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~\n           |      |         |                |\n           |      |         |                (5) ...to here\n           |      |         (6) calling 'removeDigits' from 'removeDigitsFromList'\n           |\n           +--> 'removeDigits': events 7-12\n                  |\n                  |    5 | void removeDigits(char *str) {\n                  |      |      ^~~~~~~~~~~~\n                  |      |      |\n                  |      |      (7) entry to 'removeDigits'\n                  |......\n                  |    9 |     while (*j != '\0') {\n                  |      |            ~~~~~~~~~~\n                  |      |               |\n                  |      |               (8) following 'true' branch...\n                  |   10 |         if (!isdigit(*j)) {\n                  |      |            ~         ~~\n                  |      |            |         |\n                  |      |            |         (9) ...to here\n                  |      |            (10) following 'true' branch...\n                  |   11 |             *i = *j;\n                  |      |             ~~~~~~~\n                  |      |                | |\n                  |      |                | (11) ...to here\n                  |      |                (12) write to string literal here\n                  |\ncollected_code/problem-27-0.c:11:16: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   11 |             *i = *j;\n      |             ~~~^~~~\n  'main': events 1-2\n    |\n    |   26 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   30 |     removeDigitsFromList(list, size);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeDigitsFromList' from 'main'\n    |\n    +--> 'removeDigitsFromList': events 3-6\n           |\n           |   20 | void removeDigitsFromList(char **list, int size) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeDigitsFromList'\n           |   21 |     for (int i = 0; i < size; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < size')...\n           |   22 |         removeDigits(list[i]);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~\n           |      |         |                |\n           |      |         |                (5) ...to here\n           |      |         (6) calling 'removeDigits' from 'removeDigitsFromList'\n           |\n           +--> 'removeDigits': events 7-16\n                  |\n                  |    5 | void removeDigits(char *str) {\n                  |      |      ^~~~~~~~~~~~\n                  |      |      |\n                  |      |      (7) entry to 'removeDigits'\n                  |......\n                  |    9 |     while (*j != '\0') {\n                  |      |            ~~~~~~~~~~\n                  |      |               |\n                  |      |               (8) following 'true' branch...\n                  |      |               (12) following 'true' branch...\n                  |   10 |         if (!isdigit(*j)) {\n                  |      |            ~         ~~\n                  |      |            |         |\n                  |      |            |         (9) ...to here\n                  |      |            |         (13) ...to here\n                  |      |            (10) following 'true' branch...\n                  |      |            (14) following 'true' branch...\n                  |   11 |             *i = *j;\n                  |      |             ~~~~~~~\n                  |      |                | |\n                  |      |                | (11) ...to here\n                  |      |                | (15) ...to here\n                  |      |                (16) write to string literal here\n                  |\ncollected_code/problem-27-0.c:11:16: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   11 |             *i = *j;\n      |             ~~~^~~~\n  'main': events 1-2\n    |\n    |   26 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   30 |     removeDigitsFromList(list, size);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeDigitsFromList' from 'main'\n    |\n    +--> 'removeDigitsFromList': events 3-6\n           |\n           |   20 | void removeDigitsFromList(char **list, int size) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeDigitsFromList'\n           |   21 |     for (int i = 0; i < size; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < size')...\n           |   22 |         removeDigits(list[i]);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~\n           |      |         |                |\n           |      |         |                (5) ...to here\n           |      |         (6) calling 'removeDigits' from 'removeDigitsFromList'\n           |\n           +--> 'removeDigits': events 7-20\n                  |\n                  |    5 | void removeDigits(char *str) {\n                  |      |      ^~~~~~~~~~~~\n                  |      |      |\n                  |      |      (7) entry to 'removeDigits'\n                  |......\n                  |    9 |     while (*j != '\0') {\n                  |      |            ~~~~~~~~~~\n                  |      |               |\n                  |      |               (8) following 'true' branch...\n                  |      |               (12) following 'true' branch...\n                  |      |               (16) following 'true' branch...\n                  |   10 |         if (!isdigit(*j)) {\n                  |      |            ~         ~~\n                  |      |            |         |\n                  |      |            |         (9) ...to here\n                  |      |            |         (13) ...to here\n                  |      |            |         (17) ...to here\n                  |      |            (10) following 'true' branch...\n                  |      |            (14) following 'true' branch...\n                  |      |            (18) following 'true' branch...\n                  |   11 |             *i = *j;\n                  |      |             ~~~~~~~\n                  |      |                | |\n                  |      |                | (11) ...to here\n                  |      |                | (15) ...to here\n                  |      |                | (19) ...to here\n                  |      |                (20) write to string literal here\n                  |\ncollected_code/problem-27-0.c:17:8: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   17 |     *i = '\0';\n      |     ~~~^~~~~~\n  'main': events 1-2\n    |\n    |   26 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   30 |     removeDigitsFromList(list, size);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeDigitsFromList' from 'main'\n    |\n    +--> 'removeDigitsFromList': events 3-6\n           |\n           |   20 | void removeDigitsFromList(char **list, int size) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeDigitsFromList'\n           |   21 |     for (int i = 0; i < size; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < size')...\n           |   22 |         removeDigits(list[i]);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~\n           |      |         |                |\n           |      |         |                (5) ...to here\n           |      |         (6) calling 'removeDigits' from 'removeDigitsFromList'\n           |\n           +--> 'removeDigits': events 7-28\n                  |\n                  |    5 | void removeDigits(char *str) {\n                  |      |      ^~~~~~~~~~~~\n                  |      |      |\n                  |      |      (7) entry to 'removeDigits'\n                  |......\n                  |    9 |     while (*j != '\0') {\n                  |      |            ~~~~~~~~~~\n                  |      |               |\n                  |      |               (8) following 'true' branch...\n                  |      |               (12) following 'true' branch...\n                  |      |               (16) following 'true' branch...\n                  |      |               (20) following 'true' branch...\n                  |   10 |         if (!isdigit(*j)) {\n                  |      |            ~         ~~\n                  |      |            |         |\n                  |      |            |         (9) ...to here\n                  |      |            |         (13) ...to here\n                  |      |            |         (17) ...to here\n                  |      |            |         (21) ...to here\n                  |      |            (10) following 'true' branch...\n                  |      |            (14) following 'true' branch...\n                  |      |            (18) following 'true' branch...\n                  |      |            (22) following 'false' branch...\n                  |      |            (24) following 'false' branch...\n                  |      |            (26) following 'false' branch...\n                  |   11 |             *i = *j;\n                  |      |                  ~~\n                  |      |                  |\n                  |      |                  (11) ...to here\n                  |      |                  (15) ...to here\n                  |      |                  (19) ...to here\n                  |......\n                  |   14 |         j++;\n                  |      |         ~~~\n                  |      |          |\n                  |      |          (23) ...to here\n                  |      |          (25) ...to here\n                  |      |          (27) ...to here\n                  |......\n                  |   17 |     *i = '\0';\n                  |      |     ~~~~~~~~~\n                  |      |        |\n                  |      |        (28) write to string literal here\n                  |\n
28§True§"collected_code/problem-28-0.c:17:20: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d%d"", &n, &k);\n                   ^\ncollected_code/problem-28-0.c:17:24: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n    scanf(""%d%d"", &n, &k);\n                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-28-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (2849 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
29§True§collected_code/problem-29-0.c:8:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                   ^\ncollected_code/problem-29-0.c:8:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                             ^\ncollected_code/problem-29-0.c:12:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            return arr[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-29-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.56 seconds (45 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
30§True§collected_code/problem-30-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-30-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-30-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 24 in approximately 0.25 seconds (95 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]  50 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
31§True§"collected_code/problem-31-0.c:117:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\ncollected_code/problem-31-0.c:125:18: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &k);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-31-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 129 in approximately 0.01 seconds (13461 lines/second)\nPhysical Source Lines of Code (SLOC) = 104\nHits@level = [0]   8 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   8 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-31-0.c: In function 'createHeap':\ncollected_code/problem-31-0.c:19:15: warning: dereference of possibly-NULL 'heap' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n      |     ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'createHeap': events 1-2\n    |\n    |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |               |\n    |      |               (2) 'heap' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-31-0.c: In function 'heapify':\ncollected_code/problem-31-0.c:36:45: warning: use of uninitialized value '*_4 + _6.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n      |                              ~~~~~~~~~~~~~~~^~~~~~\n  'buildHeap': events 1-2\n    |\n    |   48 | Heap* buildHeap(Element *arr, int size) {\n    |      |       ^~~~~~~~~\n    |      |       |\n    |      |       (1) entry to 'buildHeap'\n    |   49 |     Heap* heap = createHeap(size);\n    |      |                  ~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'createHeap' from 'buildHeap'\n    |\n    +--> 'createHeap': events 3-4\n           |\n           |   17 | Heap* createHeap(int capacity) {\n           |      |       ^~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'createHeap'\n           |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n           |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n           |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                            |\n           |      |                            (4) region created on heap here\n           |\n    <------+\n    |\n  'buildHeap': events 5-8\n    |\n    |   49 |     Heap* heap = createHeap(size);\n    |      |                  ^~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (5) returning to 'buildHeap' from 'createHeap'\n    |......\n    |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n    |      |                                  ~~~~~~\n    |      |                                    |\n    |      |                                    (6) following 'true' branch (when 'i >= 0')...\n    |   53 |         heapify(heap, i);\n    |      |         ~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (7) ...to here\n    |      |         (8) calling 'heapify' from 'buildHeap'\n    |\n    +--> 'heapify': events 9-12\n           |\n           |   31 | void heapify(Heap *heap, int index) {\n           |      |      ^~~~~~~\n           |      |      |\n           |      |      (9) entry to 'heapify'\n           |......\n           |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n           |      |        ~                     ~~~~~~~~~~~~~~~~~~~~~\n           |      |        |                         |          |\n           |      |        |                         |          (12) use of uninitialized value '*_4 + _6.count' here\n           |      |        |                         (11) ...to here\n           |      |        (10) following 'true' branch...\n           |\ncollected_code/problem-31-0.c:36:45: warning: use of uninitialized value '*_4 + _6.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n      |                              ~~~~~~~~~~~~~~~^~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) region created on heap here\n                  |\n           <------+\n           |\n         'buildHeap': events 7-10\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |......\n           |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n           |      |                                  ~~~~~~\n           |      |                                    |\n           |      |                                    (8) following 'true' branch (when 'i >= 0')...\n           |   53 |         heapify(heap, i);\n           |      |         ~~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (9) ...to here\n           |      |         (10) calling 'heapify' from 'buildHeap'\n           |\n           +--> 'heapify': events 11-14\n                  |\n                  |   31 | void heapify(Heap *heap, int index) {\n                  |      |      ^~~~~~~\n                  |      |      |\n                  |      |      (11) entry to 'heapify'\n                  |......\n                  |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                  |      |        ~                     ~~~~~~~~~~~~~~~~~~~~~\n                  |      |        |                         |          |\n                  |      |        |                         |          (14) use of uninitialized value '*_4 + _6.count' here\n                  |      |        |                         (13) ...to here\n                  |      |        (12) following 'true' branch...\n                  |\ncollected_code/problem-31-0.c:36:45: warning: use of uninitialized value '*_4 + _6.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n      |                              ~~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |  112 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |  127 |     findTopKFrequent(arr, size, k);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'findTopKFrequent' from 'main'\n    |\n    +--> 'findTopKFrequent': events 3-4\n           |\n           |   77 | void findTopKFrequent(int arr[], int size, int k) {\n           |      |      ^~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'findTopKFrequent'\n           |   78 |     Heap* heap = buildHeap(NULL, k);\n           |      |                  ~~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'buildHeap' from 'findTopKFrequent'\n           |\n           +--> 'buildHeap': events 5-6\n                  |\n                  |   48 | Heap* buildHeap(Element *arr, int size) {\n                  |      |       ^~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'buildHeap'\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ~~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (6) calling 'createHeap' from 'buildHeap'\n                  |\n                  +--> 'createHeap': events 7-8\n                         |\n                         |   17 | Heap* createHeap(int capacity) {\n                         |      |       ^~~~~~~~~~\n                         |      |       |\n                         |      |       (7) entry to 'createHeap'\n                         |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                         |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                         |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                         |      |                            |\n                         |      |                            (8) region created on heap here\n                         |\n                  <------+\n                  |\n                'buildHeap': events 9-12\n                  |\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ^~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (9) returning to 'buildHeap' from 'createHeap'\n                  |......\n                  |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n                  |      |                                  ~~~~~~\n                  |      |                                    |\n                  |      |                                    (10) following 'true' branch (when 'i >= 0')...\n                  |   53 |         heapify(heap, i);\n                  |      |         ~~~~~~~~~~~~~~~~\n                  |      |         |\n                  |      |         (11) ...to here\n                  |      |         (12) calling 'heapify' from 'buildHeap'\n                  |\n                  +--> 'heapify': events 13-16\n                         |\n                         |   31 | void heapify(Heap *heap, int index) {\n                         |      |      ^~~~~~~\n                         |      |      |\n                         |      |      (13) entry to 'heapify'\n                         |......\n                         |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                         |      |        ~                     ~~~~~~~~~~~~~~~~~~~~~\n                         |      |        |                         |          |\n                         |      |        |                         |          (16) use of uninitialized value '*_4 + _6.count' here\n                         |      |        |                         (15) ...to here\n                         |      |        (14) following 'true' branch...\n                         |\ncollected_code/problem-31-0.c:36:72: warning: use of uninitialized value '*_9 + _11.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n      |                                                      ~~~~~~~~~~~~~~~~~~^~~~~~\n  'buildHeap': events 1-2\n    |\n    |   48 | Heap* buildHeap(Element *arr, int size) {\n    |      |       ^~~~~~~~~\n    |      |       |\n    |      |       (1) entry to 'buildHeap'\n    |   49 |     Heap* heap = createHeap(size);\n    |      |                  ~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'createHeap' from 'buildHeap'\n    |\n    +--> 'createHeap': events 3-4\n           |\n           |   17 | Heap* createHeap(int capacity) {\n           |      |       ^~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'createHeap'\n           |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n           |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n           |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                            |\n           |      |                            (4) region created on heap here\n           |\n    <------+\n    |\n  'buildHeap': events 5-8\n    |\n    |   49 |     Heap* heap = createHeap(size);\n    |      |                  ^~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (5) returning to 'buildHeap' from 'createHeap'\n    |......\n    |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n    |      |                                  ~~~~~~\n    |      |                                    |\n    |      |                                    (6) following 'true' branch (when 'i >= 0')...\n    |   53 |         heapify(heap, i);\n    |      |         ~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (7) ...to here\n    |      |         (8) calling 'heapify' from 'buildHeap'\n    |\n    +--> 'heapify': events 9-15\n           |\n           |   31 | void heapify(Heap *heap, int index) {\n           |      |      ^~~~~~~\n           |      |      |\n           |      |      (9) entry to 'heapify'\n           |......\n           |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n           |      |        ~\n           |      |        |\n           |      |        (10) following 'false' branch...\n           |......\n           |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n           |      |        ~        ~~~~~~~~~~\n           |      |        |            |\n           |      |        |            (11) ...to here\n           |      |        (12) following 'false' branch...\n           |......\n           |   42 |     if (largest != index) {\n           |      |        ~\n           |      |        |\n           |      |        (13) ...to here\n           |      |        (14) following 'false' branch (when 'largest == index')...\n           |......\n           |   46 | }\n           |      | ~     \n           |      | |\n           |      | (15) ...to here\n           |\n    <------+\n    |\n  'buildHeap': events 16-19\n    |\n    |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n    |      |                                  ~~~~~~\n    |      |                                    |\n    |      |                                    (17) following 'true' branch (when 'i >= 0')...\n    |   53 |         heapify(heap, i);\n    |      |         ^~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (16) returning to 'buildHeap' from 'heapify'\n    |      |         (18) ...to here\n    |      |         (19) calling 'heapify' from 'buildHeap'\n    |\n    +--> 'heapify': events 20-21\n           |\n           |   31 | void heapify(Heap *heap, int index) {\n           |      |      ^~~~~~~\n           |      |      |\n           |      |      (20) entry to 'heapify'\n           |......\n           |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n           |      |                                                      ~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                                                        |\n           |      |                                                                        (21) use of uninitialized value '*_9 + _11.count' here\n           |\ncollected_code/problem-31-0.c:36:72: warning: use of uninitialized value '*_9 + _11.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n      |                                                      ~~~~~~~~~~~~~~~~~~^~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) region created on heap here\n                  |\n           <------+\n           |\n         'buildHeap': events 7-10\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |......\n           |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n           |      |                                  ~~~~~~\n           |      |                                    |\n           |      |                                    (8) following 'true' branch (when 'i >= 0')...\n           |   53 |         heapify(heap, i);\n           |      |         ~~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (9) ...to here\n           |      |         (10) calling 'heapify' from 'buildHeap'\n           |\n           +--> 'heapify': events 11-17\n                  |\n                  |   31 | void heapify(Heap *heap, int index) {\n                  |      |      ^~~~~~~\n                  |      |      |\n                  |      |      (11) entry to 'heapify'\n                  |......\n                  |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                  |      |        ~\n                  |      |        |\n                  |      |        (12) following 'false' branch...\n                  |......\n                  |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n                  |      |        ~        ~~~~~~~~~~\n                  |      |        |            |\n                  |      |        |            (13) ...to here\n                  |      |        (14) following 'false' branch...\n                  |......\n                  |   42 |     if (largest != index) {\n                  |      |        ~\n                  |      |        |\n                  |      |        (15) ...to here\n                  |      |        (16) following 'false' branch (when 'largest == index')...\n                  |......\n                  |   46 | }\n                  |      | ~     \n                  |      | |\n                  |      | (17) ...to here\n                  |\n           <------+\n           |\n         'buildHeap': events 18-21\n           |\n           |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n           |      |                                  ~~~~~~\n           |      |                                    |\n           |      |                                    (19) following 'true' branch (when 'i >= 0')...\n           |   53 |         heapify(heap, i);\n           |      |         ^~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (18) returning to 'buildHeap' from 'heapify'\n           |      |         (20) ...to here\n           |      |         (21) calling 'heapify' from 'buildHeap'\n           |\n           +--> 'heapify': events 22-23\n                  |\n                  |   31 | void heapify(Heap *heap, int index) {\n                  |      |      ^~~~~~~\n                  |      |      |\n                  |      |      (22) entry to 'heapify'\n                  |......\n                  |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                  |      |                                                      ~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                                                                        |\n                  |      |                                                                        (23) use of uninitialized value '*_9 + _11.count' here\n                  |\ncollected_code/problem-31-0.c:36:72: warning: use of uninitialized value '*_9 + _11.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n      |                                                      ~~~~~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |  112 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |  127 |     findTopKFrequent(arr, size, k);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'findTopKFrequent' from 'main'\n    |\n    +--> 'findTopKFrequent': events 3-4\n           |\n           |   77 | void findTopKFrequent(int arr[], int size, int k) {\n           |      |      ^~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'findTopKFrequent'\n           |   78 |     Heap* heap = buildHeap(NULL, k);\n           |      |                  ~~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'buildHeap' from 'findTopKFrequent'\n           |\n           +--> 'buildHeap': events 5-6\n                  |\n                  |   48 | Heap* buildHeap(Element *arr, int size) {\n                  |      |       ^~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'buildHeap'\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ~~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (6) calling 'createHeap' from 'buildHeap'\n                  |\n                  +--> 'createHeap': events 7-8\n                         |\n                         |   17 | Heap* createHeap(int capacity) {\n                         |      |       ^~~~~~~~~~\n                         |      |       |\n                         |      |       (7) entry to 'createHeap'\n                         |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                         |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                         |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                         |      |                            |\n                         |      |                            (8) region created on heap here\n                         |\n                  <------+\n                  |\n                'buildHeap': events 9-12\n                  |\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ^~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (9) returning to 'buildHeap' from 'createHeap'\n                  |......\n                  |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n                  |      |                                  ~~~~~~\n                  |      |                                    |\n                  |      |                                    (10) following 'true' branch (when 'i >= 0')...\n                  |   53 |         heapify(heap, i);\n                  |      |         ~~~~~~~~~~~~~~~~\n                  |      |         |\n                  |      |         (11) ...to here\n                  |      |         (12) calling 'heapify' from 'buildHeap'\n                  |\n                  +--> 'heapify': events 13-19\n                         |\n                         |   31 | void heapify(Heap *heap, int index) {\n                         |      |      ^~~~~~~\n                         |      |      |\n                         |      |      (13) entry to 'heapify'\n                         |......\n                         |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                         |      |        ~\n                         |      |        |\n                         |      |        (14) following 'false' branch...\n                         |......\n                         |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n                         |      |        ~        ~~~~~~~~~~\n                         |      |        |            |\n                         |      |        |            (15) ...to here\n                         |      |        (16) following 'false' branch...\n                         |......\n                         |   42 |     if (largest != index) {\n                         |      |        ~\n                         |      |        |\n                         |      |        (17) ...to here\n                         |      |        (18) following 'false' branch (when 'largest == index')...\n                         |......\n                         |   46 | }\n                         |      | ~     \n                         |      | |\n                         |      | (19) ...to here\n                         |\n                  <------+\n                  |\n                'buildHeap': events 20-23\n                  |\n                  |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n                  |      |                                  ~~~~~~\n                  |      |                                    |\n                  |      |                                    (21) following 'true' branch (when 'i >= 0')...\n                  |   53 |         heapify(heap, i);\n                  |      |         ^~~~~~~~~~~~~~~~\n                  |      |         |\n                  |      |         (20) returning to 'buildHeap' from 'heapify'\n                  |      |         (22) ...to here\n                  |      |         (23) calling 'heapify' from 'buildHeap'\n                  |\n                  +--> 'heapify': events 24-25\n                         |\n                         |   31 | void heapify(Heap *heap, int index) {\n                         |      |      ^~~~~~~\n                         |      |      |\n                         |      |      (24) entry to 'heapify'\n                         |......\n                         |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                         |      |                                                      ~~~~~~~~~~~~~~~~~~~~~~~~\n                         |      |                                                                        |\n                         |      |                                                                        (25) use of uninitialized value '*_9 + _11.count' here\n                         |\ncollected_code/problem-31-0.c:39:47: warning: use of uninitialized value '*_15 + _17.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n      |                               ~~~~~~~~~~~~~~~~^~~~~~\n  'buildHeap': events 1-2\n    |\n    |   48 | Heap* buildHeap(Element *arr, int size) {\n    |      |       ^~~~~~~~~\n    |      |       |\n    |      |       (1) entry to 'buildHeap'\n    |   49 |     Heap* heap = createHeap(size);\n    |      |                  ~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'createHeap' from 'buildHeap'\n    |\n    +--> 'createHeap': events 3-4\n           |\n           |   17 | Heap* createHeap(int capacity) {\n           |      |       ^~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'createHeap'\n           |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n           |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n           |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                            |\n           |      |                            (4) region created on heap here\n           |\n    <------+\n    |\n  'buildHeap': events 5-8\n    |\n    |   49 |     Heap* heap = createHeap(size);\n    |      |                  ^~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (5) returning to 'buildHeap' from 'createHeap'\n    |......\n    |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n    |      |                                  ~~~~~~\n    |      |                                    |\n    |      |                                    (6) following 'true' branch (when 'i >= 0')...\n    |   53 |         heapify(heap, i);\n    |      |         ~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (7) ...to here\n    |      |         (8) calling 'heapify' from 'buildHeap'\n    |\n    +--> 'heapify': events 9-14\n           |\n           |   31 | void heapify(Heap *heap, int index) {\n           |      |      ^~~~~~~\n           |      |      |\n           |      |      (9) entry to 'heapify'\n           |......\n           |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n           |      |        ~\n           |      |        |\n           |      |        (10) following 'false' branch...\n           |......\n           |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n           |      |        ~        ~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~\n           |      |        |            |             |           |\n           |      |        |            |             |           (14) use of uninitialized value '*_15 + _17.count' here\n           |      |        |            |             (13) ...to here\n           |      |        |            (11) ...to here\n           |      |        (12) following 'true' branch...\n           |\ncollected_code/problem-31-0.c:39:47: warning: use of uninitialized value '*_15 + _17.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n      |                               ~~~~~~~~~~~~~~~~^~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) region created on heap here\n                  |\n           <------+\n           |\n         'buildHeap': events 7-10\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |......\n           |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n           |      |                                  ~~~~~~\n           |      |                                    |\n           |      |                                    (8) following 'true' branch (when 'i >= 0')...\n           |   53 |         heapify(heap, i);\n           |      |         ~~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (9) ...to here\n           |      |         (10) calling 'heapify' from 'buildHeap'\n           |\n           +--> 'heapify': events 11-16\n                  |\n                  |   31 | void heapify(Heap *heap, int index) {\n                  |      |      ^~~~~~~\n                  |      |      |\n                  |      |      (11) entry to 'heapify'\n                  |......\n                  |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                  |      |        ~\n                  |      |        |\n                  |      |        (12) following 'false' branch...\n                  |......\n                  |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n                  |      |        ~        ~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~\n                  |      |        |            |             |           |\n                  |      |        |            |             |           (16) use of uninitialized value '*_15 + _17.count' here\n                  |      |        |            |             (15) ...to here\n                  |      |        |            (13) ...to here\n                  |      |        (14) following 'true' branch...\n                  |\ncollected_code/problem-31-0.c:39:47: warning: use of uninitialized value '*_15 + _17.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n      |                               ~~~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |  112 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |  127 |     findTopKFrequent(arr, size, k);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'findTopKFrequent' from 'main'\n    |\n    +--> 'findTopKFrequent': events 3-4\n           |\n           |   77 | void findTopKFrequent(int arr[], int size, int k) {\n           |      |      ^~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'findTopKFrequent'\n           |   78 |     Heap* heap = buildHeap(NULL, k);\n           |      |                  ~~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'buildHeap' from 'findTopKFrequent'\n           |\n           +--> 'buildHeap': events 5-6\n                  |\n                  |   48 | Heap* buildHeap(Element *arr, int size) {\n                  |      |       ^~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'buildHeap'\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ~~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (6) calling 'createHeap' from 'buildHeap'\n                  |\n                  +--> 'createHeap': events 7-8\n                         |\n                         |   17 | Heap* createHeap(int capacity) {\n                         |      |       ^~~~~~~~~~\n                         |      |       |\n                         |      |       (7) entry to 'createHeap'\n                         |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                         |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                         |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                         |      |                            |\n                         |      |                            (8) region created on heap here\n                         |\n                  <------+\n                  |\n                'buildHeap': events 9-12\n                  |\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ^~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (9) returning to 'buildHeap' from 'createHeap'\n                  |......\n                  |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n                  |      |                                  ~~~~~~\n                  |      |                                    |\n                  |      |                                    (10) following 'true' branch (when 'i >= 0')...\n                  |   53 |         heapify(heap, i);\n                  |      |         ~~~~~~~~~~~~~~~~\n                  |      |         |\n                  |      |         (11) ...to here\n                  |      |         (12) calling 'heapify' from 'buildHeap'\n                  |\n                  +--> 'heapify': events 13-18\n                         |\n                         |   31 | void heapify(Heap *heap, int index) {\n                         |      |      ^~~~~~~\n                         |      |      |\n                         |      |      (13) entry to 'heapify'\n                         |......\n                         |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                         |      |        ~\n                         |      |        |\n                         |      |        (14) following 'false' branch...\n                         |......\n                         |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n                         |      |        ~        ~~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~\n                         |      |        |            |             |           |\n                         |      |        |            |             |           (18) use of uninitialized value '*_15 + _17.count' here\n                         |      |        |            |             (17) ...to here\n                         |      |        |            (15) ...to here\n                         |      |        (16) following 'true' branch...\n                         |\ncollected_code/problem-31-0.c:39:74: warning: use of uninitialized value '*_20 + _22.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n      |                                                        ~~~~~~~~~~~~~~~~~~^~~~~~\n  'buildHeap': events 1-2\n    |\n    |   48 | Heap* buildHeap(Element *arr, int size) {\n    |      |       ^~~~~~~~~\n    |      |       |\n    |      |       (1) entry to 'buildHeap'\n    |   49 |     Heap* heap = createHeap(size);\n    |      |                  ~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'createHeap' from 'buildHeap'\n    |\n    +--> 'createHeap': events 3-4\n           |\n           |   17 | Heap* createHeap(int capacity) {\n           |      |       ^~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'createHeap'\n           |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n           |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n           |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                            |\n           |      |                            (4) region created on heap here\n           |\n    <------+\n    |\n  'buildHeap': events 5-8\n    |\n    |   49 |     Heap* heap = createHeap(size);\n    |      |                  ^~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (5) returning to 'buildHeap' from 'createHeap'\n    |......\n    |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n    |      |                                  ~~~~~~\n    |      |                                    |\n    |      |                                    (6) following 'true' branch (when 'i >= 0')...\n    |   53 |         heapify(heap, i);\n    |      |         ~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (7) ...to here\n    |      |         (8) calling 'heapify' from 'buildHeap'\n    |\n    +--> 'heapify': events 9-15\n           |\n           |   31 | void heapify(Heap *heap, int index) {\n           |      |      ^~~~~~~\n           |      |      |\n           |      |      (9) entry to 'heapify'\n           |......\n           |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n           |      |        ~\n           |      |        |\n           |      |        (10) following 'false' branch...\n           |......\n           |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n           |      |        ~        ~~~~~~~~~~\n           |      |        |            |\n           |      |        |            (11) ...to here\n           |      |        (12) following 'false' branch...\n           |......\n           |   42 |     if (largest != index) {\n           |      |        ~\n           |      |        |\n           |      |        (13) ...to here\n           |      |        (14) following 'false' branch (when 'largest == index')...\n           |......\n           |   46 | }\n           |      | ~     \n           |      | |\n           |      | (15) ...to here\n           |\n    <------+\n    |\n  'buildHeap': events 16-19\n    |\n    |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n    |      |                                  ~~~~~~\n    |      |                                    |\n    |      |                                    (17) following 'true' branch (when 'i >= 0')...\n    |   53 |         heapify(heap, i);\n    |      |         ^~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (16) returning to 'buildHeap' from 'heapify'\n    |      |         (18) ...to here\n    |      |         (19) calling 'heapify' from 'buildHeap'\n    |\n    +--> 'heapify': events 20-23\n           |\n           |   31 | void heapify(Heap *heap, int index) {\n           |      |      ^~~~~~~\n           |      |      |\n           |      |      (20) entry to 'heapify'\n           |......\n           |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n           |      |        ~\n           |      |        |\n           |      |        (21) following 'false' branch...\n           |......\n           |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n           |      |                 ~~~~~~~~~~                             ~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                     |                                                    |\n           |      |                     (22) ...to here                                      (23) use of uninitialized value '*_20 + _22.count' here\n           |\ncollected_code/problem-31-0.c:39:74: warning: use of uninitialized value '*_20 + _22.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n      |                                                        ~~~~~~~~~~~~~~~~~~^~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) region created on heap here\n                  |\n           <------+\n           |\n         'buildHeap': events 7-10\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |......\n           |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n           |      |                                  ~~~~~~\n           |      |                                    |\n           |      |                                    (8) following 'true' branch (when 'i >= 0')...\n           |   53 |         heapify(heap, i);\n           |      |         ~~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (9) ...to here\n           |      |         (10) calling 'heapify' from 'buildHeap'\n           |\n           +--> 'heapify': events 11-17\n                  |\n                  |   31 | void heapify(Heap *heap, int index) {\n                  |      |      ^~~~~~~\n                  |      |      |\n                  |      |      (11) entry to 'heapify'\n                  |......\n                  |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                  |      |        ~\n                  |      |        |\n                  |      |        (12) following 'false' branch...\n                  |......\n                  |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n                  |      |        ~        ~~~~~~~~~~\n                  |      |        |            |\n                  |      |        |            (13) ...to here\n                  |      |        (14) following 'false' branch...\n                  |......\n                  |   42 |     if (largest != index) {\n                  |      |        ~\n                  |      |        |\n                  |      |        (15) ...to here\n                  |      |        (16) following 'false' branch (when 'largest == index')...\n                  |......\n                  |   46 | }\n                  |      | ~     \n                  |      | |\n                  |      | (17) ...to here\n                  |\n           <------+\n           |\n         'buildHeap': events 18-21\n           |\n           |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n           |      |                                  ~~~~~~\n           |      |                                    |\n           |      |                                    (19) following 'true' branch (when 'i >= 0')...\n           |   53 |         heapify(heap, i);\n           |      |         ^~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (18) returning to 'buildHeap' from 'heapify'\n           |      |         (20) ...to here\n           |      |         (21) calling 'heapify' from 'buildHeap'\n           |\n           +--> 'heapify': events 22-25\n                  |\n                  |   31 | void heapify(Heap *heap, int index) {\n                  |      |      ^~~~~~~\n                  |      |      |\n                  |      |      (22) entry to 'heapify'\n                  |......\n                  |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                  |      |        ~\n                  |      |        |\n                  |      |        (23) following 'false' branch...\n                  |......\n                  |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n                  |      |                 ~~~~~~~~~~                             ~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                     |                                                    |\n                  |      |                     (24) ...to here                                      (25) use of uninitialized value '*_20 + _22.count' here\n                  |\ncollected_code/problem-31-0.c:39:74: warning: use of uninitialized value '*_20 + _22.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n      |                                                        ~~~~~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |  112 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |  127 |     findTopKFrequent(arr, size, k);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'findTopKFrequent' from 'main'\n    |\n    +--> 'findTopKFrequent': events 3-4\n           |\n           |   77 | void findTopKFrequent(int arr[], int size, int k) {\n           |      |      ^~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'findTopKFrequent'\n           |   78 |     Heap* heap = buildHeap(NULL, k);\n           |      |                  ~~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'buildHeap' from 'findTopKFrequent'\n           |\n           +--> 'buildHeap': events 5-6\n                  |\n                  |   48 | Heap* buildHeap(Element *arr, int size) {\n                  |      |       ^~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'buildHeap'\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ~~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (6) calling 'createHeap' from 'buildHeap'\n                  |\n                  +--> 'createHeap': events 7-8\n                         |\n                         |   17 | Heap* createHeap(int capacity) {\n                         |      |       ^~~~~~~~~~\n                         |      |       |\n                         |      |       (7) entry to 'createHeap'\n                         |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                         |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                         |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                         |      |                            |\n                         |      |                            (8) region created on heap here\n                         |\n                  <------+\n                  |\n                'buildHeap': events 9-12\n                  |\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ^~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (9) returning to 'buildHeap' from 'createHeap'\n                  |......\n                  |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n                  |      |                                  ~~~~~~\n                  |      |                                    |\n                  |      |                                    (10) following 'true' branch (when 'i >= 0')...\n                  |   53 |         heapify(heap, i);\n                  |      |         ~~~~~~~~~~~~~~~~\n                  |      |         |\n                  |      |         (11) ...to here\n                  |      |         (12) calling 'heapify' from 'buildHeap'\n                  |\n                  +--> 'heapify': events 13-19\n                         |\n                         |   31 | void heapify(Heap *heap, int index) {\n                         |      |      ^~~~~~~\n                         |      |      |\n                         |      |      (13) entry to 'heapify'\n                         |......\n                         |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                         |      |        ~\n                         |      |        |\n                         |      |        (14) following 'false' branch...\n                         |......\n                         |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n                         |      |        ~        ~~~~~~~~~~\n                         |      |        |            |\n                         |      |        |            (15) ...to here\n                         |      |        (16) following 'false' branch...\n                         |......\n                         |   42 |     if (largest != index) {\n                         |      |        ~\n                         |      |        |\n                         |      |        (17) ...to here\n                         |      |        (18) following 'false' branch (when 'largest == index')...\n                         |......\n                         |   46 | }\n                         |      | ~     \n                         |      | |\n                         |      | (19) ...to here\n                         |\n                  <------+\n                  |\n                'buildHeap': events 20-23\n                  |\n                  |   52 |     for (int i = (size - 2) / 2; i >= 0; --i) {\n                  |      |                                  ~~~~~~\n                  |      |                                    |\n                  |      |                                    (21) following 'true' branch (when 'i >= 0')...\n                  |   53 |         heapify(heap, i);\n                  |      |         ^~~~~~~~~~~~~~~~\n                  |      |         |\n                  |      |         (20) returning to 'buildHeap' from 'heapify'\n                  |      |         (22) ...to here\n                  |      |         (23) calling 'heapify' from 'buildHeap'\n                  |\n                  +--> 'heapify': events 24-27\n                         |\n                         |   31 | void heapify(Heap *heap, int index) {\n                         |      |      ^~~~~~~\n                         |      |      |\n                         |      |      (24) entry to 'heapify'\n                         |......\n                         |   36 |     if (left < heap->size && heap->arr[left].count > heap->arr[largest].count)\n                         |      |        ~\n                         |      |        |\n                         |      |        (25) following 'false' branch...\n                         |......\n                         |   39 |     if (right < heap->size && heap->arr[right].count > heap->arr[largest].count)\n                         |      |                 ~~~~~~~~~~                             ~~~~~~~~~~~~~~~~~~~~~~~~\n                         |      |                     |                                                    |\n                         |      |                     (26) ...to here                                      (27) use of uninitialized value '*_20 + _22.count' here\n                         |\ncollected_code/problem-31-0.c: In function 'findTopKFrequent':\ncollected_code/problem-31-0.c:83:29: warning: use of uninitialized value '*_1 + _3.value' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   83 |             if (heap->arr[j].value == arr[i]) {\n      |                 ~~~~~~~~~~~~^~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) region created on heap here\n                  |\n           <------+\n           |\n         'buildHeap': event 7\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |\n    <------+\n    |\n  'findTopKFrequent': events 8-13\n    |\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ^~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (8) returning to 'findTopKFrequent' from 'buildHeap'\n    |   79 | \n    |   80 |     for (int i = 0; i < size; ++i) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (9) following 'true' branch (when 'i < size')...\n    |   81 |         int j;\n    |   82 |         for (j = 0; j < heap->size; ++j) {\n    |      |              ~~~~~  ~~~~~~~~~~~~~~\n    |      |                |      |\n    |      |                |      (11) following 'true' branch...\n    |      |                (10) ...to here\n    |   83 |             if (heap->arr[j].value == arr[i]) {\n    |      |                 ~~~~~~~~~~~~~~~~~~\n    |      |                     |       |\n    |      |                     |       (13) use of uninitialized value '*_1 + _3.value' here\n    |      |                     (12) ...to here\n    |\ncollected_code/problem-31-0.c:83:29: warning: dereference of possibly-NULL '*heap.arr + (long unsigned int)j * 8' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   83 |             if (heap->arr[j].value == arr[i]) {\n      |                 ~~~~~~~~~~~~^~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) this call could return NULL\n                  |\n           <------+\n           |\n         'buildHeap': event 7\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |\n    <------+\n    |\n  'findTopKFrequent': events 8-13\n    |\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ^~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (8) returning to 'findTopKFrequent' from 'buildHeap'\n    |   79 | \n    |   80 |     for (int i = 0; i < size; ++i) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (9) following 'true' branch (when 'i < size')...\n    |   81 |         int j;\n    |   82 |         for (j = 0; j < heap->size; ++j) {\n    |      |              ~~~~~  ~~~~~~~~~~~~~~\n    |      |                |      |\n    |      |                |      (11) following 'true' branch...\n    |      |                (10) ...to here\n    |   83 |             if (heap->arr[j].value == arr[i]) {\n    |      |                 ~~~~~~~~~~~~~~~~~~\n    |      |                     |       |\n    |      |                     |       (13) '*heap.arr + (long unsigned int)j * 8' could be NULL: unchecked value from (6)\n    |      |                     (12) ...to here\n    |\ncollected_code/problem-31-0.c:95:34: warning: use of uninitialized value '*heap_60->arr.count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   95 |             else if (heap->arr[0].count < 1) {\n      |                      ~~~~~~~~~~~~^~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) region created on heap here\n                  |\n           <------+\n           |\n         'buildHeap': event 7\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |\n    <------+\n    |\n  'findTopKFrequent': events 8-17\n    |\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ^~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (8) returning to 'findTopKFrequent' from 'buildHeap'\n    |   79 | \n    |   80 |     for (int i = 0; i < size; ++i) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (9) following 'true' branch (when 'i < size')...\n    |   81 |         int j;\n    |   82 |         for (j = 0; j < heap->size; ++j) {\n    |      |              ~~~~~  ~~~~~~~~~~~~~~\n    |      |                |      |\n    |      |                |      (11) following 'false' branch...\n    |      |                (10) ...to here\n    |......\n    |   89 |         if (j == heap->size) {\n    |      |            ~     ~~~~~~~~~~\n    |      |            |         |\n    |      |            |         (12) ...to here\n    |      |            (13) following 'true' branch...\n    |   90 |             if (heap->size < k) {\n    |      |                ~~~~~~~~~~~\n    |      |                |    |\n    |      |                |    (14) ...to here\n    |      |                (15) following 'false' branch...\n    |......\n    |   95 |             else if (heap->arr[0].count < 1) {\n    |      |                      ~~~~~~~~~~~~~~~~~~\n    |      |                          |       |\n    |      |                          |       (17) use of uninitialized value '*heap_60->arr.count' here\n    |      |                          (16) ...to here\n    |\ncollected_code/problem-31-0.c:95:34: warning: dereference of possibly-NULL '*heap.arr' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   95 |             else if (heap->arr[0].count < 1) {\n      |                      ~~~~~~~~~~~~^~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) this call could return NULL\n                  |\n           <------+\n           |\n         'buildHeap': event 7\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |\n    <------+\n    |\n  'findTopKFrequent': events 8-17\n    |\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ^~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (8) returning to 'findTopKFrequent' from 'buildHeap'\n    |   79 | \n    |   80 |     for (int i = 0; i < size; ++i) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (9) following 'true' branch (when 'i < size')...\n    |   81 |         int j;\n    |   82 |         for (j = 0; j < heap->size; ++j) {\n    |      |              ~~~~~  ~~~~~~~~~~~~~~\n    |      |                |      |\n    |      |                |      (11) following 'false' branch...\n    |      |                (10) ...to here\n    |......\n    |   89 |         if (j == heap->size) {\n    |      |            ~     ~~~~~~~~~~\n    |      |            |         |\n    |      |            |         (12) ...to here\n    |      |            (13) following 'true' branch...\n    |   90 |             if (heap->size < k) {\n    |      |                ~~~~~~~~~~~\n    |      |                |    |\n    |      |                |    (14) ...to here\n    |      |                (15) following 'false' branch...\n    |......\n    |   95 |             else if (heap->arr[0].count < 1) {\n    |      |                      ~~~~~~~~~~~~~~~~~~\n    |      |                          |       |\n    |      |                          |       (17) '*heap.arr' could be NULL: unchecked value from (6)\n    |      |                          (16) ...to here\n    |\ncollected_code/problem-31-0.c:105:9: warning: use of uninitialized value '*_44 + _46.value' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n  105 |         printf(""%d "", heap->arr[i].value);\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'findTopKFrequent': events 1-2\n    |\n    |   77 | void findTopKFrequent(int arr[], int size, int k) {\n    |      |      ^~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'findTopKFrequent'\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'buildHeap' from 'findTopKFrequent'\n    |\n    +--> 'buildHeap': events 3-4\n           |\n           |   48 | Heap* buildHeap(Element *arr, int size) {\n           |      |       ^~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'buildHeap'\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'buildHeap'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   17 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                  |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (6) region created on heap here\n                  |\n           <------+\n           |\n         'buildHeap': event 7\n           |\n           |   49 |     Heap* heap = createHeap(size);\n           |      |                  ^~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'buildHeap' from 'createHeap'\n           |\n    <------+\n    |\n  'findTopKFrequent': events 8-11\n    |\n    |   78 |     Heap* heap = buildHeap(NULL, k);\n    |      |                  ^~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (8) returning to 'findTopKFrequent' from 'buildHeap'\n    |......\n    |  104 |     for (int i = heap->size - 1; i >= 0; --i) {\n    |      |                                  ~~~~~~\n    |      |                                    |\n    |      |                                    (9) following 'true' branch (when 'i >= 0')...\n    |  105 |         printf(""%d "", heap->arr[i].value);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |                 |\n    |      |         |                 (10) ...to here\n    |      |         (11) use of uninitialized value '*_44 + _46.value' here\n    |\ncollected_code/problem-31-0.c:105:9: warning: use of uninitialized value '*_44 + _46.value' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n  105 |         printf(""%d "", heap->arr[i].value);\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |  112 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |  127 |     findTopKFrequent(arr, size, k);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'findTopKFrequent' from 'main'\n    |\n    +--> 'findTopKFrequent': events 3-4\n           |\n           |   77 | void findTopKFrequent(int arr[], int size, int k) {\n           |      |      ^~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'findTopKFrequent'\n           |   78 |     Heap* heap = buildHeap(NULL, k);\n           |      |                  ~~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'buildHeap' from 'findTopKFrequent'\n           |\n           +--> 'buildHeap': events 5-6\n                  |\n                  |   48 | Heap* buildHeap(Element *arr, int size) {\n                  |      |       ^~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'buildHeap'\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ~~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (6) calling 'createHeap' from 'buildHeap'\n                  |\n                  +--> 'createHeap': events 7-8\n                         |\n                         |   17 | Heap* createHeap(int capacity) {\n                         |      |       ^~~~~~~~~~\n                         |      |       |\n                         |      |       (7) entry to 'createHeap'\n                         |   18 |     Heap* heap = (Heap*) malloc(sizeof(Heap));\n                         |   19 |     heap->arr = (Element*) malloc(capacity * sizeof(Element));\n                         |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                         |      |                            |\n                         |      |                            (8) region created on heap here\n                         |\n                  <------+\n                  |\n                'buildHeap': event 9\n                  |\n                  |   49 |     Heap* heap = createHeap(size);\n                  |      |                  ^~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (9) returning to 'buildHeap' from 'createHeap'\n                  |\n           <------+\n           |\n         'findTopKFrequent': events 10-13\n           |\n           |   78 |     Heap* heap = buildHeap(NULL, k);\n           |      |                  ^~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (10) returning to 'findTopKFrequent' from 'buildHeap'\n           |......\n           |  104 |     for (int i = heap->size - 1; i >= 0; --i) {\n           |      |                                  ~~~~~~\n           |      |                                    |\n           |      |                                    (11) following 'true' branch (when 'i >= 0')...\n           |  105 |         printf(""%d "", heap->arr[i].value);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |         |                 |\n           |      |         |                 (12) ...to here\n           |      |         (13) use of uninitialized value '*_44 + _46.value' here\n           |\n"
32§True§"collected_code/problem-32-0.c:29:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-32-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.34 seconds (91 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 115.385 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-32-0.c: In function 'largestPrimeFactor':\ncollected_code/problem-32-0.c:12:22: warning: implicit declaration of function 'sqrt' [-Wimplicit-function-declaration]\n   12 |     for (i = 3; i <= sqrt(number); i += 2) {\n      |                      ^~~~\ncollected_code/problem-32-0.c:2:1: note: include '<math.h>' or provide a declaration of 'sqrt'\n    1 | #include<stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-32-0.c:12:22: warning: incompatible implicit declaration of built-in function 'sqrt' [-Wbuiltin-declaration-mismatch]\n   12 |     for (i = 3; i <= sqrt(number); i += 2) {\n      |                      ^~~~\ncollected_code/problem-32-0.c:12:22: note: include '<math.h>' or provide a declaration of 'sqrt'\n
33§True§"collected_code/problem-33-0.c:14:34: error: Cannot determine that 'binaryNumber[j]' is initialized [premium-bughuntingUninit]\n        printf(""%d"", binaryNumber[j]);\n                                 ^\ncollected_code/problem-33-0.c:21:18: error: Cannot determine that 'decimalNumber' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &decimalNumber);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-33-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.01 seconds (4775 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 190.476 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
34§True§collected_code/problem-34-0.c:11:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] != mid + 1 && arr[mid - 1] == mid) {\n               ^\ncollected_code/problem-34-0.c:11:39: error: Cannot determine that 'arr[mid-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] != mid + 1 && arr[mid - 1] == mid) {\n                                      ^\ncollected_code/problem-34-0.c:14:21: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[mid] != mid + 1) {\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-34-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.43 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
35§False§Checking collected_code/problem-35-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-35-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 4 in approximately 0.01 seconds (719 lines/second)\nPhysical Source Lines of Code (SLOC) = 4\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
36§True§"collected_code/problem-36-0.c:17:13: error: Cannot determine that 'fractionString[0]' is initialized [premium-bughuntingUninit]\n    sprintf(fractionString, ""%.15f"", properFraction);\n            ^\ncollected_code/problem-36-0.c:28:18: error: Cannot determine that 'numerator' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &numerator);\n                 ^\ncollected_code/problem-36-0.c:30:18: error: Cannot determine that 'denominator' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &denominator);\n                 ^\ncollected_code/problem-36-0.c:32:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-36-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-36-0.c:16:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-36-0.c:17:  [2] (buffer) sprintf:\n  Does not check for buffer overflows (CWE-120). Use sprintf_s, snprintf, or\n  vsnprintf. Risk is low because the source has a constant maximum length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 40 in approximately 0.14 seconds (285 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   8 [1]   0 [2]   2 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]  10 [1+]   2 [2+]   2 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 357.143 [1+] 71.4286 [2+] 71.4286 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
37§True§Checking collected_code/problem-37-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-37-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.35 seconds (111 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 88.2353 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
38§True§collected_code/problem-38-0.c:8:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] % 2 == 0) {\n                ^\ncollected_code/problem-38-0.c:9:24: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            even = list[i];\n                       ^\ncollected_code/problem-38-0.c:15:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] % 2 != 0) {\n                ^\ncollected_code/problem-38-0.c:16:23: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            odd = list[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-38-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (6687 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.037 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
39§True§"collected_code/problem-39-0.c:8:15: error: Cannot determine that 'str[len]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[len] != '\0') {\n              ^\ncollected_code/problem-39-0.c:9:18: error: Cannot determine that 'str[len]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[str[len] - 'a']++;\n                 ^\ncollected_code/problem-39-0.c:25:17: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-39-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-39-0.c:25:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-39-0.c:23:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 33 in approximately 0.01 seconds (5546 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 185.185 [1+] 74.0741 [2+] 74.0741 [3+] 37.037 [4+] 37.037 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
40§True§collected_code/problem-40-0.c:10:31: error: Cannot determine that 'lists[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            frequency[lists[i][j]]++;\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-40-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.01 seconds (4274 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
41§True§"collected_code/problem-41-0.c:7:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(arr[i] % 2 == 0)\n              ^\ncollected_code/problem-41-0.c:9:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", arr[i]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-41-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.39 seconds (53 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
42§True§collected_code/problem-42-0.c:11:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                   ^\ncollected_code/problem-42-0.c:11:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                             ^\ncollected_code/problem-42-0.c:15:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += arr[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-42-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.31 seconds (83 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
43§True§collected_code/problem-43-0.c:12:28: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    result = regexec(&reg, str, 0, NULL, 0);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-43-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.49 seconds (55 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
44§True§collected_code/problem-44-0.c:5:29: error: Cannot determine that 'word[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int wordLength = strlen(word);\n                            ^\ncollected_code/problem-44-0.c:6:17: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (strncmp(string, word, wordLength) == 0) {\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-44-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-44-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 20 in approximately 0.01 seconds (2906 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+] 52.6316 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
45§True§collected_code/problem-45-0.c:11:21: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int result = arr[0];\n                    ^\ncollected_code/problem-45-0.c:13:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result = gcd(arr[i], result);\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-45-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.38 seconds (69 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
46§True§collected_code/problem-46-0.c:6:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                   ^\ncollected_code/problem-46-0.c:6:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-46-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.38 seconds (71 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
47§True§"collected_code/problem-47-0.c:32:21: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &a, &b);\n                    ^\ncollected_code/problem-47-0.c:32:25: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &a, &b);\n                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-47-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.62 seconds (68 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 121.212 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
48§True§collected_code/problem-48-0.c:4:13: error: Cannot determine that '*num' is initialized [premium-bughuntingUninit]\n    *num = (*num | 0xAAAAAAAA);\n            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-48-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.70 seconds (20 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
49§True§"collected_code/problem-49-0.c:9:23: error: Cannot determine that 'arr[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i][j] == extract_value) {\n                      ^\ncollected_code/problem-49-0.c:10:37: error: Cannot determine that 'arr[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                printf(""%d "", arr[i][0]);\n                                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-49-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.59 seconds (46 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
50§False§collected_code/problem-50-0.c:8:34: error: Cannot determine that 'lists[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length = findLength(lists[i]);\n                                 ^\ncollected_code/problem-50-0.c:26:13: error: Cannot determine that 'list[length]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  while(list[length] != '\0') {\n            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-50-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (4902 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-50-0.c: In function 'minListLength':\ncollected_code/problem-50-0.c:8:18: warning: implicit declaration of function 'findLength'; did you mean 'minListLength'? [-Wimplicit-function-declaration]\n    8 |     int length = findLength(lists[i]);\n      |                  ^~~~~~~~~~\n      |                  minListLength\nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
51§True§"collected_code/problem-51-0.c:14:24: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                       ^\ncollected_code/problem-51-0.c:14:32: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                               ^\ncollected_code/problem-51-0.c:14:40: error: Cannot determine that 'side3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-51-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (2447 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 235.294 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
52§True§"collected_code/problem-52-0.c:11:18: error: Cannot determine that 'base' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &base);\n                 ^\ncollected_code/problem-52-0.c:13:18: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &height);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-52-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2198 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
53§False§collected_code/problem-53-0.c:6:15: error: Cannot determine that 'str[len]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[len] != '\0') {\n              ^\ncollected_code/problem-53-0.c:12:16: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    return (str[0] == str[len - 1]);\n               ^\ncollected_code/problem-53-0.c:12:26: error: Cannot determine that 'str[len-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    return (str[0] == str[len - 1]);\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-53-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.01 seconds (1794 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
54§True§collected_code/problem-54-0.c:29:18: warning: Uninitialized variable: output [uninitvar]\n        arr[i] = output[i];\n                 ^\ncollected_code/problem-54-0.c:23:23: note: Assuming condition is false\n    for (i = n - 1; i >= 0; i--) {\n                      ^\ncollected_code/problem-54-0.c:29:18: note: Uninitialized variable: output\n        arr[i] = output[i];\n                 ^\ncollected_code/problem-54-0.c:6:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max = arr[0];\n                 ^\ncollected_code/problem-54-0.c:10:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > max) {\n               ^\ncollected_code/problem-54-0.c:11:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = arr[i];\n                     ^\ncollected_code/problem-54-0.c:16:18: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[arr[i]]++;\n                 ^\ncollected_code/problem-54-0.c:24:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        output[count[arr[i]] - 1] = arr[i];\n                        ^\ncollected_code/problem-54-0.c:25:18: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[arr[i]]--;\n                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-54-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 45 in approximately 0.52 seconds (86 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
55§True§"collected_code/problem-55-0.c:18:19: error: Cannot determine that 'firstTerm' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &firstTerm);\n                  ^\ncollected_code/problem-55-0.c:21:19: error: Cannot determine that 'commonRatio' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &commonRatio);\n                  ^\ncollected_code/problem-55-0.c:24:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-55-0.c:26:40: error: Cannot determine that 'firstTerm' is initialized [premium-bughuntingUninit]\n    double nthTerm = findGeometricTerm(firstTerm, commonRatio, n);\n                                       ^\ncollected_code/problem-55-0.c:26:51: error: Cannot determine that 'commonRatio' is initialized [premium-bughuntingUninit]\n    double nthTerm = findGeometricTerm(firstTerm, commonRatio, n);\n                                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-55-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.54 seconds (56 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
56§True§"collected_code/problem-56-0.c:23:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-56-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.39 seconds (74 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
57§True§"collected_code/problem-57-0.c:4:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-57-0.c:5:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-57-0.c:12:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] < arr[j]) {\n                   ^\ncollected_code/problem-57-0.c:12:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] < arr[j]) {\n                            ^\ncollected_code/problem-57-0.c:20:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d"", arr[i]);\n                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-57-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (4011 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  80 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
58§True§"collected_code/problem-58-0.c:12:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-58-0.c:14:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-58-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.20 seconds (128 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 272.727 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
59§True§"collected_code/problem-59-0.c:12:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-59-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (2132 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
60§True§collected_code/problem-60-0.c:4:38: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max = 1, curr = 1, diff = arr[1] - arr[0];\n                                     ^\ncollected_code/problem-60-0.c:4:47: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max = 1, curr = 1, diff = arr[1] - arr[0];\n                                              ^\ncollected_code/problem-60-0.c:6:16: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i + 1] - arr[i] == diff) {\n               ^\ncollected_code/problem-60-0.c:6:29: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i + 1] - arr[i] == diff) {\n                            ^\ncollected_code/problem-60-0.c:13:23: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            diff = arr[i + 1] - arr[i];\n                      ^\ncollected_code/problem-60-0.c:13:36: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            diff = arr[i + 1] - arr[i];\n                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-60-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.42 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
61§True§collected_code/problem-61-0.c:7:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++)\n                       ^\ncollected_code/problem-61-0.c:11:28: error: Cannot determine that 'str[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        for (int j = i; str[j] != '\0'; j++)\n                           ^\ncollected_code/problem-61-0.c:13:23: error: Cannot determine that 'str[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += str[j] - '0';\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-61-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.01 seconds (4747 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
62§True§collected_code/problem-62-0.c:4:22: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n   int smallest = arr[0];\n                     ^\ncollected_code/problem-62-0.c:6:13: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if(arr[i] < smallest) {\n            ^\ncollected_code/problem-62-0.c:7:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n         smallest = arr[i];  // update smallest if current element is smaller\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-62-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.60 seconds (30 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
63§True§collected_code/problem-63-0.c:8:33: error: Cannot determine that 'tupleList[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int diff = tupleList[j] - tupleList[i];\n                                ^\ncollected_code/problem-63-0.c:8:48: error: Cannot determine that 'tupleList[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int diff = tupleList[j] - tupleList[i];\n                                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-63-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.54 seconds (46 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
64§True§Checking collected_code/problem-64-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-64-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.01 seconds (3612 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-64-0.c: In function 'main':\ncollected_code/problem-64-0.c:29:5: warning: implicit declaration of function 'qsort' [-Wimplicit-function-declaration]\n   29 |     qsort(tuples, num_tuples, sizeof(tuples[0]), compare_tuples);\n      |     ^~~~~\n
65§True§collected_code/problem-65-0.c:7:19: error: Cannot determine that 'arr[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return arr[size-1] + listSum(arr, size-1);\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-65-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.25 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
66§True§collected_code/problem-66-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-66-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.33 seconds (67 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
67§True§"collected_code/problem-67-0.c:32:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-67-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (3182 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 115.385 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
68§False§collected_code/problem-68-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < arr[i - 1]) {\n               ^\ncollected_code/problem-68-0.c:8:25: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < arr[i - 1]) {\n                        ^\ncollected_code/problem-68-0.c:11:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > arr[i - 1]) {\n               ^\ncollected_code/problem-68-0.c:11:25: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > arr[i - 1]) {\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-68-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2709 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
69§True§collected_code/problem-69-0.c:8:21: error: Cannot determine that 'list[i+j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[i+j] != sublist[j]) {\n                    ^\ncollected_code/problem-69-0.c:8:37: error: Cannot determine that 'sublist[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[i+j] != sublist[j]) {\n                                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-69-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.01 seconds (5157 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
70§True§Checking collected_code/problem-70-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-70-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.33 seconds (91 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
71§True§"collected_code/problem-71-0.c:5:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-71-0.c:6:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-71-0.c:29:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[i + gap]) {\n                   ^\ncollected_code/problem-71-0.c:29:29: error: Cannot determine that 'arr[i+gap]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[i + gap]) {\n                            ^\ncollected_code/problem-71-0.c:40:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr[i]);\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-71-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 58 in approximately 0.01 seconds (8793 lines/second)\nPhysical Source Lines of Code (SLOC) = 43\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 93.0233 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
72§True§"collected_code/problem-72-0.c:8:29: warning: Invalid sqrt() argument nr 1. The value is -1 but the valid values are '0.0:'. [invalidFunctionArg]\n        int sqrtDiff = sqrt(diff);\n                            ^\ncollected_code/problem-72-0.c:6:18: note: Assignment 'i=1', assigned value is 1\n    for (int i = 1; i * i <= num; i++) {\n                 ^\ncollected_code/problem-72-0.c:7:18: note: diff is assigned 'num-i*i' here.\n        int diff = num - i * i;\n                 ^\ncollected_code/problem-72-0.c:8:29: note: Invalid argument\n        int sqrtDiff = sqrt(diff);\n                            ^\ncollected_code/problem-72-0.c:19:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-72-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.51 seconds (53 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
73§True§collected_code/problem-73-0.c:7:31: error: Cannot determine that 'delimiters[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int res = regcomp(&regex, delimiters, REG_EXTENDED);\n                              ^\ncollected_code/problem-73-0.c:14:26: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char *token = strtok(string, delimiters);\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-73-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (4436 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-73-0.c: In function 'split_string':\ncollected_code/problem-73-0.c:14:19: warning: implicit declaration of function 'strtok' [-Wimplicit-function-declaration]\n   14 |     char *token = strtok(string, delimiters);\n      |                   ^~~~~~\ncollected_code/problem-73-0.c:14:19: warning: initialization of 'char *' from 'int' makes pointer from integer without a cast [-Wint-conversion]\ncollected_code/problem-73-0.c:17:15: warning: assignment to 'char *' from 'int' makes pointer from integer without a cast [-Wint-conversion]\n   17 |         token = strtok(NULL, delimiters);\n      |               ^\n
74§False§collected_code/problem-74-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == patterns[patternIndex]) {\n               ^\ncollected_code/problem-74-0.c:6:31: error: Cannot determine that 'patterns[patternIndex]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == patterns[patternIndex]) {\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-74-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.36 seconds (37 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
75§False§"collected_code/problem-75-0.c:6:22: error: Cannot determine that 'tuples[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuples[i][0] % k == 0 && tuples[i][1] % k == 0) {\n                     ^\ncollected_code/problem-75-0.c:6:47: error: Cannot determine that 'tuples[i][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuples[i][0] % k == 0 && tuples[i][1] % k == 0) {\n                                              ^\ncollected_code/problem-75-0.c:7:43: error: Cannot determine that 'tuples[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""(%d, %d)\n"", tuples[i][0], tuples[i][1]);\n                                          ^\ncollected_code/problem-75-0.c:7:57: error: Cannot determine that 'tuples[i][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""(%d, %d)\n"", tuples[i][0], tuples[i][1]);\n                                                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-75-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.02 seconds (1161 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-75-0.c: In function 'main':\ncollected_code/problem-75-0.c:16:24: error: variable-sized object may not be initialized except with an empty initializer\n   16 |     int tuples[n][2] = {{1, 6}, {9, -3}, {4, 8}, {10, 12}};\n      |                        ^\n
76§True§"collected_code/problem-76-0.c:18:21: error: Cannot determine that 'width' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &width, &height);\n                    ^\ncollected_code/problem-76-0.c:18:29: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &width, &height);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-76-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2317 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
77§True§"collected_code/problem-77-0.c:23:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-77-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.45 seconds (62 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 130.435 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
78§True§collected_code/problem-78-0.c:18:29: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (countSetBits(arr[i]) % 2 != 0) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-78-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.01 seconds (2665 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
79§False§collected_code/problem-79-0.c:6:16: error: Cannot determine that 'word[length]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (word[length] != '\0') {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-79-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 10 in approximately 0.01 seconds (1493 lines/second)\nPhysical Source Lines of Code (SLOC) = 8\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
80§True§Checking collected_code/problem-80-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-80-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.01 seconds (1922 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
81§True§collected_code/problem-81-0.c:10:29: error: Cannot determine that 'tuple1[i/2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        zipTuple[i] = tuple1[i / 2];\n                            ^\ncollected_code/problem-81-0.c:11:33: error: Cannot determine that 'tuple2[i/2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        zipTuple[i + 1] = tuple2[i / 2];\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-81-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.57 seconds (56 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
82§True§"collected_code/problem-82-0.c:12:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-82-0.c:13:30: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    volume = calculateVolume(radius);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-82-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (2172 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
83§True§"collected_code/problem-83-0.c:7:14: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while(str[i] != '\0') {\n             ^\ncollected_code/problem-83-0.c:8:22: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result += str[i];\n                     ^\ncollected_code/problem-83-0.c:18:17: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-83-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-83-0.c:18:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-83-0.c:16:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 23 in approximately 0.55 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+] 111.111 [2+] 111.111 [3+] 55.5556 [4+] 55.5556 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
84§True§"collected_code/problem-84-0.c:14:16: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n  scanf(""%d"", &n);\n               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-84-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2550 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
85§True§"collected_code/problem-85-0.c:12:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-85-0.c:13:34: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    float area = findSurfaceArea(radius);\n                                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-85-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (1816 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
86§True§"collected_code/problem-86-0.c:14:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-86-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.35 seconds (55 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
87§True§"collected_code/problem-87-0.c:39:29: error: Cannot determine that 'result[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", result[i]);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-87-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (5493 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 30.303 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
88§True§"collected_code/problem-88-0.c:8:18: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[arr[i]]++;\n                 ^\ncollected_code/problem-88-0.c:13:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (count[arr[i]] != 0) {\n                     ^\ncollected_code/problem-88-0.c:14:35: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d: %d\n"", arr[i], count[arr[i]]);\n                                  ^\ncollected_code/problem-88-0.c:15:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            count[arr[i]] = 0;\n                     ^\ncollected_code/problem-88-0.c:23:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-88-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.31 seconds (105 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
89§True§"collected_code/problem-89-0.c:10:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-89-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (1550 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
90§True§collected_code/problem-90-0.c:8:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-90-0.c:9:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] != ' ') {\n               ^\ncollected_code/problem-90-0.c:29:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, MAX_SIZE, stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-90-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-90-0.c:27:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 35 in approximately 0.01 seconds (4378 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 107.143 [1+] 35.7143 [2+] 35.7143 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
91§True§collected_code/problem-91-0.c:7:27: error: Cannot determine that 'strings[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strstr(strings[i], substring) != NULL) {\n                          ^\ncollected_code/problem-91-0.c:7:32: error: Cannot determine that 'substring[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strstr(strings[i], substring) != NULL) {\n                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-91-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (2734 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
92§True§"collected_code/problem-92-0.c:47:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-92-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 55 in approximately 0.01 seconds (8153 lines/second)\nPhysical Source Lines of Code (SLOC) = 44\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
93§True§"collected_code/problem-93-0.c:26:18: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &a);\n                 ^\ncollected_code/problem-93-0.c:29:18: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &b);\n                 ^\ncollected_code/problem-93-0.c:31:62: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    printf(""The value of %.2f to the power of %d is %.2f\n"", a, b, power(a, b));\n                                                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-93-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (3628 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 192.308 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
94§True§Checking collected_code/problem-94-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-94-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (4370 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
95§False§collected_code/problem-95-0.c:9:22: error: Cannot determine that 'arr[end++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n           sum += arr[end++];\n                     ^\ncollected_code/problem-95-0.c:16:22: error: Cannot determine that 'arr[start++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n           sum -= arr[start++];\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-95-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.36 seconds (55 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
96§True§"collected_code/problem-96-0.c:16:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-96-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.46 seconds (40 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
97§True§collected_code/problem-97-0.c:13:17: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        freq[arr[i]]++;\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-97-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (3533 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
98§True§collected_code/problem-98-0.c:8:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    product *= arr[i];\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-98-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3260 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
99§True§"collected_code/problem-99-0.c:14:28: error: Cannot determine that 'binary[j]' is initialized [premium-bughuntingUninit]\n        printf(""%d"", binary[j]);\n                           ^\ncollected_code/problem-99-0.c:21:18: error: Cannot determine that 'decimal' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &decimal);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-99-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3799 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 190.476 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
100§True§"collected_code/problem-100-0.c:9:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        char temp = str[i];\n                       ^\ncollected_code/problem-100-0.c:10:21: error: Cannot determine that 'str[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        str[i] = str[j];\n                    ^\ncollected_code/problem-100-0.c:21:24: error: Cannot determine that 'num[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int digit = num[i] - '0' + carry;\n                       ^\ncollected_code/problem-100-0.c:29:22: error: Cannot determine that 'num[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(num);\n                     ^\ncollected_code/problem-100-0.c:55:17: error: Cannot determine that 'num[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", num);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-100-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-100-0.c:55:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-100-0.c:53:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-100-0.c:29:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 60 in approximately 0.33 seconds (181 lines/second)\nPhysical Source Lines of Code (SLOC) = 45\nHits@level = [0]   2 [1]   1 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   3 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+] 66.6667 [2+] 44.4444 [3+] 22.2222 [4+] 22.2222 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
101§True§Checking collected_code/problem-101-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-101-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (4886 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
102§True§collected_code/problem-102-0.c:5:22: error: Cannot determine that 's[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(s);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-102-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-102-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 27 in approximately 0.01 seconds (2957 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+] 45.4545 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-102-0.c: In function 'main':\ncollected_code/problem-102-0.c:25:5: warning: implicit declaration of function 'printf' [-Wimplicit-function-declaration]\n   25 |     printf(""%s\n"", str);\n      |     ^~~~~~\ncollected_code/problem-102-0.c:2:1: note: include '<stdio.h>' or provide a declaration of 'printf'\n    1 | #include <string.h>\n  +++ |+#include <stdio.h>\n    2 | \ncollected_code/problem-102-0.c:25:5: warning: incompatible implicit declaration of built-in function 'printf' [-Wbuiltin-declaration-mismatch]\n   25 |     printf(""%s\n"", str);\n      |     ^~~~~~\ncollected_code/problem-102-0.c:25:5: note: include '<stdio.h>' or provide a declaration of 'printf'\n"
103§True§"collected_code/problem-103-0.c:46:21: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &n, &m);\n                    ^\ncollected_code/problem-103-0.c:46:25: error: Cannot determine that 'm' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &n, &m);\n                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-103-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 50 in approximately 0.01 seconds (9429 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
104§True§"collected_code/problem-104-0.c:7:38: error: Cannot determine that 'listSizes[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        for (int j = 0; j < listSizes[i]; j++) {\n                                     ^\ncollected_code/problem-104-0.c:8:42: error: Cannot determine that 'listSizes[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            for (int k = 0; k < listSizes[i] - j - 1; k++) {\n                                         ^\ncollected_code/problem-104-0.c:31:18: error: Cannot determine that 'lists' is initialized [premium-bughuntingUninit]\n    sortSublists(lists, 3, listSizes);\n                 ^\ncollected_code/problem-104-0.c:35:27: error: Cannot determine that 'lists' is initialized [premium-bughuntingUninit]\n            printf(""%s "", lists[i][j]);\n                          ^\ncollected_code/problem-104-0.c:40:10: error: Cannot determine that 'lists' is initialized [premium-bughuntingUninit]\n    free(lists);\n         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-104-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (5734 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 57.1429 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-104-0.c: In function 'main':\ncollected_code/problem-104-0.c:27:14: warning: dereference of possibly-NULL 'lists' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   27 |     lists[0] = list1;\n      |     ~~~~~~~~~^~~~~~~\n  'main': events 1-2\n    |\n    |   24 |     char*** lists = (char***) malloc(3 * sizeof(char**));\n    |      |                               ^~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                               |\n    |      |                               (1) this call could return NULL\n    |......\n    |   27 |     lists[0] = list1;\n    |      |     ~~~~~~~~~~~~~~~~           \n    |      |              |\n    |      |              (2) 'lists' could be NULL: unchecked value from (1)\n    |\n
105§False§collected_code/problem-105-0.c:4:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i]) {\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-105-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 8 in approximately 0.01 seconds (891 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-105-0.c:1:23: error: unknown type name 'bool'\n    1 | int countTrueBooleans(bool list[], int size) {\n      |                       ^~~~\ncollected_code/problem-105-0.c:1:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n  +++ |+#include <stdbool.h>\n    1 | int countTrueBooleans(bool list[], int size) {\n
106§True§collected_code/problem-106-0.c:8:33: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            tuples[i][j] += list[j];\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-106-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.04 seconds (726 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
107§True§"collected_code/problem-107-0.c:27:18: error: Cannot determine that 'start' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &start);\n                 ^\ncollected_code/problem-107-0.c:30:18: error: Cannot determine that 'end' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &end);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-107-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.01 seconds (3476 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
108§False§Checking collected_code/problem-108-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-108-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 72 in approximately 0.01 seconds (5422 lines/second)\nPhysical Source Lines of Code (SLOC) = 55\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 18.1818 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-108-0.c: In function 'mergeSortedInputs':\ncollected_code/problem-108-0.c:53:29: error: 'INT_MAX' undeclared (first use in this function)\n   53 |             heap[0].value = INT_MAX;\n      |                             ^~~~~~~\ncollected_code/problem-108-0.c:3:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n    2 | #include <stdlib.h>\n  +++ |+#include <limits.h>\n    3 | \ncollected_code/problem-108-0.c:53:29: note: each undeclared identifier is reported only once for each function it appears in\n   53 |             heap[0].value = INT_MAX;\n      |                             ^~~~~~~\n
109§True§collected_code/problem-109-0.c:6:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i] != '\0') {\n              ^\ncollected_code/problem-109-0.c:7:22: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int num = str[i] - '0';\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-109-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (3692 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
110§True§"collected_code/problem-110-0.c:10:13: error: Cannot determine that 'list[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (list[0] > startRange) {\n            ^\ncollected_code/problem-110-0.c:11:42: error: Cannot determine that 'list[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d-%d "", startRange, list[0] - 1);\n                                         ^\ncollected_code/problem-110-0.c:16:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] - list[i-1] > 1) {\n                ^\ncollected_code/problem-110-0.c:16:27: error: Cannot determine that 'list[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] - list[i-1] > 1) {\n                          ^\ncollected_code/problem-110-0.c:17:34: error: Cannot determine that 'list[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d-%d "", list[i-1] + 1, list[i] - 1);\n                                 ^\ncollected_code/problem-110-0.c:17:49: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d-%d "", list[i-1] + 1, list[i] - 1);\n                                                ^\ncollected_code/problem-110-0.c:22:24: error: Cannot determine that 'list[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (endRange > list[size-1]) {\n                       ^\ncollected_code/problem-110-0.c:23:30: error: Cannot determine that 'list[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d-%d "", list[size-1] + 1, endRange);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-110-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.25 seconds (146 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 192.308 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
111§True§"collected_code/problem-111-0.c:6:21: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr1[i] == arr2[j]) {\n                    ^\ncollected_code/problem-111-0.c:6:32: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr1[i] == arr2[j]) {\n                               ^\ncollected_code/problem-111-0.c:7:35: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                printf(""%d "", arr1[i]);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-111-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2998 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
112§True§"collected_code/problem-112-0.c:13:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-112-0.c:16:18: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &height);\n                 ^\ncollected_code/problem-112-0.c:18:47: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    float perimeter = findPerimeterOfCylinder(radius, height);\n                                              ^\ncollected_code/problem-112-0.c:18:55: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    float perimeter = findPerimeterOfCylinder(radius, height);\n                                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-112-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3447 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 312.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
113§False§Checking collected_code/problem-113-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-113-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2542 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-113-0.c: In function 'isInteger':\ncollected_code/problem-113-0.c:4:14: error: 'NULL' undeclared (first use in this function)\n    4 |   if (str == NULL || *str == '\0') {\n      |              ^~~~\ncollected_code/problem-113-0.c:2:1: note: 'NULL' is defined in header '<stddef.h>'; did you forget to '#include <stddef.h>'?\n    1 | #include <stdbool.h>\n  +++ |+#include <stddef.h>\n    2 | \ncollected_code/problem-113-0.c:4:14: note: each undeclared identifier is reported only once for each function it appears in\n    4 |   if (str == NULL || *str == '\0') {\n      |              ^~~~\n
114§True§"collected_code/problem-114-0.c:49:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-114-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 67 in approximately 0.01 seconds (4965 lines/second)\nPhysical Source Lines of Code (SLOC) = 51\nHits@level = [0]  10 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]  10 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 196.078 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
115§True§collected_code/problem-115-0.c:5:19: error: Cannot determine that 'list[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(list[i][0] != 0)\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-115-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.51 seconds (49 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
116§True§collected_code/problem-116-0.c:7:24: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result += tuple[i] * pow(10, size - i - 1);\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-116-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2678 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
117§True§collected_code/problem-117-0.c:6:29: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i] = (float) arr[i];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-117-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (4005 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-117-0.c: In function 'main':\ncollected_code/problem-117-0.c:15:20: warning: passing argument 1 of 'convertToFloat' from incompatible pointer type [-Wincompatible-pointer-types]\n   15 |     convertToFloat(arr, len);\n      |                    ^~~\n      |                    |\n      |                    int *\ncollected_code/problem-117-0.c:4:28: note: expected 'float *' but argument is of type 'int *'\n    4 | void convertToFloat(float* arr, int len) {\n      |                     ~~~~~~~^~~\n
118§True§Checking collected_code/problem-118-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-118-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 57 in approximately 0.19 seconds (307 lines/second)\nPhysical Source Lines of Code (SLOC) = 45\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 22.2222 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-118-0.c: In function 'createNode':\ncollected_code/problem-118-0.c:13:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   13 |     newNode->data = value;\n      |     ~~~~~~~~~~~~~~^~~~~~~\n  'stringToList': events 1-4\n    |\n    |   19 | Node* stringToList(char* str)\n    |      |       ^~~~~~~~~~~~\n    |      |       |\n    |      |       (1) entry to 'stringToList'\n    |   20 | {\n    |   21 |     if (str == NULL)\n    |      |        ~\n    |      |        |\n    |      |        (2) following 'false' branch (when 'str' is non-NULL)...\n    |......\n    |   24 |     Node* head = createNode(str[0]);\n    |      |                  ~~~~~~~~~~~~~~~~~~\n    |      |                  |             |\n    |      |                  |             (3) ...to here\n    |      |                  (4) calling 'createNode' from 'stringToList'\n    |\n    +--> 'createNode': events 5-7\n           |\n           |   10 | Node* createNode(char value)\n           |      |       ^~~~~~~~~~\n           |      |       |\n           |      |       (5) entry to 'createNode'\n           |   11 | {\n           |   12 |     Node* newNode = (Node*)malloc(sizeof(Node));\n           |      |                            ~~~~~~~~~~~~~~~~~~~~\n           |      |                            |\n           |      |                            (6) this call could return NULL\n           |   13 |     newNode->data = value;\n           |      |     ~~~~~~~~~~~~~~~~~~~~~\n           |      |                   |\n           |      |                   (7) 'newNode' could be NULL: unchecked value from (6)\n           |\n
119§True§collected_code/problem-119-0.c:4:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int ans = arr[0];\n                 ^\ncollected_code/problem-119-0.c:6:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        ans ^= arr[i];\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-119-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.29 seconds (63 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
120§True§collected_code/problem-120-0.c:4:25: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int maxProduct = arr[0]*arr[1];\n                        ^\ncollected_code/problem-120-0.c:4:32: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int maxProduct = arr[0]*arr[1];\n                               ^\ncollected_code/problem-120-0.c:6:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int product = arr[i]*arr[i+1];\n                         ^\ncollected_code/problem-120-0.c:6:33: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int product = arr[i]*arr[i+1];\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-120-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (3178 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
121§True§"collected_code/problem-121-0.c:7:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (arr[i] + arr[j] + arr[k] == targetSum) {\n                       ^\ncollected_code/problem-121-0.c:7:33: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (arr[i] + arr[j] + arr[k] == targetSum) {\n                                ^\ncollected_code/problem-121-0.c:7:42: error: Cannot determine that 'arr[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (arr[i] + arr[j] + arr[k] == targetSum) {\n                                         ^\ncollected_code/problem-121-0.c:8:47: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                    printf(""%d, %d, %d\n"", arr[i], arr[j], arr[k]);\n                                              ^\ncollected_code/problem-121-0.c:8:55: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                    printf(""%d, %d, %d\n"", arr[i], arr[j], arr[k]);\n                                                      ^\ncollected_code/problem-121-0.c:8:63: error: Cannot determine that 'arr[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                    printf(""%d, %d, %d\n"", arr[i], arr[j], arr[k]);\n                                                              ^\ncollected_code/problem-121-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-121-0.c:25:18: error: Cannot determine that 'targetSum' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &targetSum);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-121-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (2171 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   8 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   8 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 296.296 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
122§True§"collected_code/problem-122-0.c:36:17: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n   scanf(""%d"", &n);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-122-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (5872 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 93.75 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
123§True§"collected_code/problem-123-0.c:37:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-123-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (5786 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
124§True§"collected_code/problem-124-0.c:11:19: error: Cannot determine that 'real' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &real);\n                  ^\ncollected_code/problem-124-0.c:13:19: error: Cannot determine that 'imag' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &imag);\n                  ^\ncollected_code/problem-124-0.c:14:68: error: Cannot determine that 'real' is initialized [premium-bughuntingUninit]\n    printf(""The angle of the complex number is: %.2lf\n"", getAngle(real, imag));\n                                                                   ^\ncollected_code/problem-124-0.c:14:74: error: Cannot determine that 'imag' is initialized [premium-bughuntingUninit]\n    printf(""The angle of the complex number is: %.2lf\n"", getAngle(real, imag));\n                                                                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-124-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (1966 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 357.143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
125§True§"collected_code/problem-125-0.c:8:24: error: Cannot determine that 'binaryString[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (binaryString[i] != '\0') {\n                       ^\ncollected_code/problem-125-0.c:9:25: error: Cannot determine that 'binaryString[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (binaryString[i] == '0') {\n                        ^\ncollected_code/problem-125-0.c:11:32: error: Cannot determine that 'binaryString[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (binaryString[i] == '1') {\n                               ^\ncollected_code/problem-125-0.c:34:17: error: Cannot determine that 'binaryString[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", binaryString);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-125-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-125-0.c:34:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-125-0.c:32:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 39 in approximately 0.30 seconds (130 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 129.032 [1+] 64.5161 [2+] 64.5161 [3+] 32.2581 [4+] 32.2581 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
126§True§"collected_code/problem-126-0.c:32:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-126-0.c:35:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-126-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.01 seconds (6722 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 172.414 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
127§True§"collected_code/problem-127-0.c:31:21: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                    ^\ncollected_code/problem-127-0.c:31:28: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-127-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.01 seconds (5841 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 115.385 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-127-0.c: In function 'multiply':\ncollected_code/problem-127-0.c:12:12: warning: implicit declaration of function 'abs' [-Wimplicit-function-declaration]\n   12 |     num1 = abs(num1);\n      |            ^~~\ncollected_code/problem-127-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'abs'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \n
128§True§"collected_code/problem-128-0.c:8:25: error: Cannot determine that 'words[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strlen(words[i]) > n) {\n                        ^\ncollected_code/problem-128-0.c:9:33: error: Cannot determine that 'words[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%s\n"", words[i]);\n                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-128-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-128-0.c:8:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 21 in approximately 0.01 seconds (4042 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   2 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+] 58.8235 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
129§True§"collected_code/problem-129-0.c:30:37: error: Cannot determine that 'square[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%3d "", square[i][j]);\n                                    ^\ncollected_code/problem-129-0.c:39:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-129-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 48 in approximately 0.01 seconds (6170 lines/second)\nPhysical Source Lines of Code (SLOC) = 39\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 128.205 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
130§True§"collected_code/problem-130-0.c:7:23: warning: Uninitialized variable: arr [uninitvar]\n    int maxFreqItem = arr[0];\n                      ^\ncollected_code/problem-130-0.c:37:23: note: Assuming condition is false\n    for (int i = 0; i < size; i++)\n                      ^\ncollected_code/problem-130-0.c:40:40: note: Calling function 'findMaxFrequency', 1st argument 'arr' value is <Uninit>\n    int maxFreqItem = findMaxFrequency(arr, size);\n                                       ^\ncollected_code/problem-130-0.c:7:23: note: Uninitialized variable: arr\n    int maxFreqItem = arr[0];\n                      ^\ncollected_code/problem-130-0.c:7:26: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int maxFreqItem = arr[0];\n                         ^\ncollected_code/problem-130-0.c:14:20: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j] == arr[i])\n                   ^\ncollected_code/problem-130-0.c:14:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j] == arr[i])\n                             ^\ncollected_code/problem-130-0.c:21:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            maxFreqItem = arr[i];\n                             ^\ncollected_code/problem-130-0.c:34:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-130-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 43 in approximately 0.07 seconds (592 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
131§True§"collected_code/problem-131-0.c:10:27: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int i = 0, j = strlen(str) - 1;\n                          ^\ncollected_code/problem-131-0.c:31:22: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%[^\n]s"", str);\n                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-131-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-131-0.c:29:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-131-0.c:10:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 35 in approximately 0.46 seconds (75 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   3 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 156.25 [1+] 62.5 [2+] 31.25 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-131-0.c: In function 'isVowel':\ncollected_code/problem-131-0.c:5:10: warning: implicit declaration of function 'tolower' [-Wimplicit-function-declaration]\n    5 |     ch = tolower(ch);\n      |          ^~~~~~~\ncollected_code/problem-131-0.c:3:1: note: include '<ctype.h>' or provide a declaration of 'tolower'\n    2 | #include <string.h>\n  +++ |+#include <ctype.h>\n    3 | \n
132§True§"collected_code/problem-132-0.c:5:13: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    sprintf(str, ""(%d, %d, %d)"", tuple >> 16, (tuple >> 8) & 0xFF, tuple & 0xFF);\n            ^\ncollected_code/problem-132-0.c:14:20: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    printf(""%s\n"", str);\n                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-132-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-132-0.c:5:  [2] (buffer) sprintf:\n  Does not check for buffer overflows (CWE-120). Use sprintf_s, snprintf, or\n  vsnprintf. Risk is low because the source has a constant maximum length.\ncollected_code/problem-132-0.c:10:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 16 in approximately 0.24 seconds (67 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   1 [1]   0 [2]   2 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   2 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+] 166.667 [2+] 166.667 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
133§True§collected_code/problem-133-0.c:6:20: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (numbers[i] < 0) {\n                   ^\ncollected_code/problem-133-0.c:7:27: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += numbers[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-133-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.38 seconds (52 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
134§True§collected_code/problem-134-0.c:8:26: error: Cannot determine that 'arr[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int lastElement = arr[size-1];\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-134-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.01 seconds (4844 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 120 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
135§True§"collected_code/problem-135-0.c:10:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-135-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.01 seconds (1758 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 272.727 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
136§True§"collected_code/problem-136-0.c:24:18: error: Cannot determine that 'units' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &units);\n                 ^\ncollected_code/problem-136-0.c:26:8: error: Cannot determine that 'units' is initialized [premium-bughuntingUninit]\n    if(units < 0) {\n       ^\ncollected_code/problem-136-0.c:31:43: error: Cannot determine that 'units' is initialized [premium-bughuntingUninit]\n    float bill = calculateElectricityBill(units);\n                                          ^\ncollected_code/problem-136-0.c:32:56: error: Cannot determine that 'units' is initialized [premium-bughuntingUninit]\n    printf(""Electricity bill for %.2f units: $%.2f\n"", units, bill);\n                                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-136-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.26 seconds (128 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
137§False§collected_code/problem-137-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-137-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 10 in approximately 0.01 seconds (690 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
138§False§Checking collected_code/problem-138-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-138-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.00 seconds (6018 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
139§True§"collected_code/problem-139-0.c:15:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-139-0.c:17:45: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    float circumference = findCircumference(radius);\n                                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-139-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.05 seconds (424 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
140§True§"collected_code/problem-140-0.c:7:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                   ^\ncollected_code/problem-140-0.c:7:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                             ^\ncollected_code/problem-140-0.c:12:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", arr[i]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-140-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2740 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
141§True§collected_code/problem-141-0.c:6:19: error: Cannot determine that 'arr[start]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        temp = arr[start];\n                  ^\ncollected_code/problem-141-0.c:7:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[start] = arr[i];\n                        ^\ncollected_code/problem-141-0.c:17:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > arr[maxIndex]) {\n               ^\ncollected_code/problem-141-0.c:17:25: error: Cannot determine that 'arr[maxIndex]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > arr[maxIndex]) {\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-141-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (7128 lines/second)\nPhysical Source Lines of Code (SLOC) = 39\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 51.2821 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
142§True§collected_code/problem-142-0.c:8:22: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list1[i] == list2[j]) {\n                     ^\ncollected_code/problem-142-0.c:8:34: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list1[i] == list2[j]) {\n                                 ^\ncollected_code/problem-142-0.c:10:30: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                    if (list1[i] == list3[k]) {\n                             ^\ncollected_code/problem-142-0.c:10:42: error: Cannot determine that 'list3[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                    if (list1[i] == list3[k]) {\n                                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-142-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.31 seconds (99 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
143§False§Checking collected_code/problem-143-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-143-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2106 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-143-0.c: In function 'count_lists':\ncollected_code/problem-143-0.c:5:31: warning: 'sizeof' on array function parameter 'tuple' will return size of 'int *' [-Wsizeof-array-argument]\n    5 |     for (int i = 0; i < sizeof(tuple); i++) {\n      |                               ^\ncollected_code/problem-143-0.c:3:21: note: declared here\n    3 | int count_lists(int tuple[]) {\n      |                 ~~~~^~~~~~~\ncollected_code/problem-143-0.c:6:13: error: expected expression before 'typeof'\n    6 |         if (typeof(tuple[i]) == list) {\n      |             ^~~~~~\ncollected_code/problem-143-0.c: In function 'main':\ncollected_code/problem-143-0.c:14:31: error: expected ']' before ',' token\n   14 |     int tuple[] = {1, 2, 3, [4, 5], [6, 7]};\n      |                               ^\n      |                               ]\ncollected_code/problem-143-0.c:14:35: error: expected expression before ',' token\n   14 |     int tuple[] = {1, 2, 3, [4, 5], [6, 7]};\n      |                                   ^\n
144§True§collected_code/problem-144-0.c:11:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += abs(arr[i] - arr[j]);\n                          ^\ncollected_code/problem-144-0.c:11:36: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += abs(arr[i] - arr[j]);\n                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-144-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.60 seconds (45 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-144-0.c: In function 'getSumOfAbsoluteDifferences':\ncollected_code/problem-144-0.c:11:20: warning: implicit declaration of function 'abs' [-Wimplicit-function-declaration]\n   11 |             sum += abs(arr[i] - arr[j]);\n      |                    ^~~\ncollected_code/problem-144-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'abs'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \n
145§True§collected_code/problem-145-0.c:8:20: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j] - arr[i] > maxDiff) {\n                   ^\ncollected_code/problem-145-0.c:8:29: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j] - arr[i] > maxDiff) {\n                            ^\ncollected_code/problem-145-0.c:9:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                maxDiff = arr[j] - arr[i];\n                             ^\ncollected_code/problem-145-0.c:9:39: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                maxDiff = arr[j] - arr[i];\n                                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-145-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3265 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
146§True§collected_code/problem-146-0.c:5:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-146-0.c:6:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += (int)str[i];\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-146-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (2372 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
147§True§"collected_code/problem-147-0.c:14:23: error: Cannot determine that 'triangle[0][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    return triangle[0][0];\n                      ^\ncollected_code/problem-147-0.c:21:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-147-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (2916 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 178.571 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
148§True§"collected_code/problem-148-0.c:20:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\ncollected_code/problem-148-0.c:22:24: error: Cannot determine that 'part1' is initialized [premium-bughuntingUninit]\n    divideNumber(num, &part1, &part2);\n                       ^\ncollected_code/problem-148-0.c:22:32: error: Cannot determine that 'part2' is initialized [premium-bughuntingUninit]\n    divideNumber(num, &part1, &part2);\n                               ^\ncollected_code/problem-148-0.c:24:28: error: Cannot determine that 'part1' is initialized [premium-bughuntingUninit]\n    printf(""Part 1: %d\n"", part1);\n                           ^\ncollected_code/problem-148-0.c:25:28: error: Cannot determine that 'part2' is initialized [premium-bughuntingUninit]\n    printf(""Part 2: %d\n"", part2);\n                           ^\ncollected_code/problem-148-0.c:26:47: error: Cannot determine that 'part1' is initialized [premium-bughuntingUninit]\n    printf(""Sum of digits: %d\n"", sumOfDigits(part1) + sumOfDigits(part2));\n                                              ^\ncollected_code/problem-148-0.c:26:68: error: Cannot determine that 'part2' is initialized [premium-bughuntingUninit]\n    printf(""Sum of digits: %d\n"", sumOfDigits(part1) + sumOfDigits(part2));\n                                                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-148-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.03 seconds (818 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 217.391 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
149§False§collected_code/problem-149-0.c:11:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] - arr[j] == 1 || arr[i] - arr[j] == -1) {\n                   ^\ncollected_code/problem-149-0.c:11:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] - arr[j] == 1 || arr[i] - arr[j] == -1) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-149-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.01 seconds (4899 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-149-0.c: In function 'longestSubsequence':\ncollected_code/problem-149-0.c:16:15: warning: implicit declaration of function 'max' [-Wimplicit-function-declaration]\n   16 |         ans = max(ans, dp[i]);\n      |               ^~~\nUndefined symbols for architecture x86_64:\n  ""_max"", referenced from:\n      _longestSubsequence in ccc2Pc2x.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
150§True§"collected_code/problem-150-0.c:21:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-150-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.40 seconds (73 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 181.818 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
151§True§"collected_code/problem-151-0.c:16:21: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                    ^\ncollected_code/problem-151-0.c:16:28: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-151-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3098 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 210.526 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
152§True§"collected_code/problem-152-0.c:31:14: warning: Uninitialized variable: L [uninitvar]\n    arr[k] = L[i];\n             ^\ncollected_code/problem-152-0.c:10:17: note: Assuming condition is false\n  for (i = 0; i < n1; i++)\n                ^\ncollected_code/problem-152-0.c:31:14: note: Uninitialized variable: L\n    arr[k] = L[i];\n             ^\ncollected_code/problem-152-0.c:37:14: warning: Uninitialized variable: R [uninitvar]\n    arr[k] = R[j];\n             ^\ncollected_code/problem-152-0.c:12:17: note: Assuming condition is false\n  for (j = 0; j < n2; j++)\n                ^\ncollected_code/problem-152-0.c:37:14: note: Uninitialized variable: R\n    arr[k] = R[j];\n             ^\ncollected_code/problem-152-0.c:11:15: error: Cannot determine that 'arr[left+i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    L[i] = arr[left + i];\n              ^\ncollected_code/problem-152-0.c:13:15: error: Cannot determine that 'arr[mid+1+j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    R[j] = arr[mid + 1 + j];\n              ^\ncollected_code/problem-152-0.c:57:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    printf(""%d "", arr[i]);\n                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-152-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 73 in approximately 0.38 seconds (192 lines/second)\nPhysical Source Lines of Code (SLOC) = 58\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 68.9655 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
153§True§"collected_code/problem-153-0.c:12:24: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &a, &b, &c);\n                       ^\ncollected_code/problem-153-0.c:12:28: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &a, &b, &c);\n                           ^\ncollected_code/problem-153-0.c:12:32: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &a, &b, &c);\n                               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-153-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (2384 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 230.769 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
154§True§collected_code/problem-154-0.c:5:31: error: Cannot determine that 'elements[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int element = elements[i];\n                              ^\ncollected_code/problem-154-0.c:10:29: error: Cannot determine that 'list[row][col]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if(list[row][col] == element) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-154-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.01 seconds (6017 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 64.5161 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
155§True§Checking collected_code/problem-155-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-155-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (2517 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 181.818 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
156§True§"collected_code/problem-156-0.c:8:31: error: Cannot determine that 'input[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        output[i] = atoi(input[i]);\n                              ^\ncollected_code/problem-156-0.c:24:29: error: Cannot determine that 'output[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", output[i]);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-156-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-156-0.c:8:  [2] (integer) atoi:\n  Unless checked, the resulting number can exceed the expected range\n  (CWE-190). If source untrusted, check both minimum and maximum, even if the\n  input had no minus sign (large numbers can roll over into negative number;\n  consider saving to an unsigned value if that is intended).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 27 in approximately 0.01 seconds (2917 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+] 55.5556 [2+] 55.5556 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
157§True§"collected_code/problem-157-0.c:9:32: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (i < n - 1 && arr[i] == arr[i + 1]) {\n                               ^\ncollected_code/problem-157-0.c:9:42: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (i < n - 1 && arr[i] == arr[i + 1]) {\n                                         ^\ncollected_code/problem-157-0.c:15:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d%d"", arr[i], count);\n                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-157-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.03 seconds (793 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
158§False§collected_code/problem-158-0.c:2:22: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max_val = arr[0];\n                     ^\ncollected_code/problem-158-0.c:3:22: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min_val = arr[0];\n                     ^\ncollected_code/problem-158-0.c:5:35: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        max_val = max(max_val, arr[i]);\n                                  ^\ncollected_code/problem-158-0.c:6:35: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        min_val = min(min_val, arr[i]);\n                                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-158-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (2710 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-158-0.c: In function 'findOperations':\ncollected_code/problem-158-0.c:5:19: warning: implicit declaration of function 'max' [-Wimplicit-function-declaration]\n    5 |         max_val = max(max_val, arr[i]);\n      |                   ^~~\ncollected_code/problem-158-0.c:6:19: warning: implicit declaration of function 'min' [-Wimplicit-function-declaration]\n    6 |         min_val = min(min_val, arr[i]);\n      |                   ^~~\nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\n  ""_max"", referenced from:\n      _findOperations in ccLxM0Vv.o\n  ""_min"", referenced from:\n      _findOperations in ccLxM0Vv.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
159§True§"collected_code/problem-159-0.c:18:18: error: Cannot determine that 'month' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &month);\n                 ^\ncollected_code/problem-159-0.c:20:18: error: Cannot determine that 'day' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &day);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-159-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3519 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   8 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   8 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 380.952 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
160§True§"collected_code/problem-160-0.c:32:24: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &a, &b, &n);\n                       ^\ncollected_code/problem-160-0.c:32:28: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &a, &b, &n);\n                           ^\ncollected_code/problem-160-0.c:32:32: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &a, &b, &n);\n                               ^\ncollected_code/problem-160-0.c:34:23: error: Cannot determine that 'x' is initialized [premium-bughuntingUninit]\n    find_xy(a, b, n, &x, &y);\n                      ^\ncollected_code/problem-160-0.c:34:27: error: Cannot determine that 'y' is initialized [premium-bughuntingUninit]\n    find_xy(a, b, n, &x, &y);\n                          ^\ncollected_code/problem-160-0.c:35:32: error: Cannot determine that 'x' is initialized [premium-bughuntingUninit]\n    printf(""x = %d, y = %d\n"", x, y);\n                               ^\ncollected_code/problem-160-0.c:35:35: error: Cannot determine that 'y' is initialized [premium-bughuntingUninit]\n    printf(""x = %d, y = %d\n"", x, y);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-160-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.38 seconds (96 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
161§True§Checking collected_code/problem-161-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-161-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 43 in approximately 0.01 seconds (6020 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-161-0.c: In function 'RemoveElements':\ncollected_code/problem-161-0.c:27:22: warning: dereference of NULL 'prev' [CWE-476] [-Wanalyzer-null-dereference]\n   27 |             current1 = prev->next;\n      |             ~~~~~~~~~^~~~~~~~~~~~\n  'RemoveElements': events 1-2\n    |\n    |   11 |     struct Node* prev = NULL;\n    |      |                  ^~~~\n    |      |                  |\n    |      |                  (1) 'prev' is NULL\n    |      |                  (2) 'prev' is NULL\n    |\n  'RemoveElements': events 3-9\n    |\n    |   13 |     while (current1 != NULL) {\n    |      |                     ^\n    |      |                     |\n    |      |                     (3) following 'true' branch (when 'current1' is non-NULL)...\n    |   14 |         struct Node* current2 = list2;\n    |      |                      ~~~~~~~~\n    |      |                      |\n    |      |                      (4) ...to here\n    |......\n    |   20 |         if (current2 != NULL) {\n    |      |            ~         \n    |      |            |\n    |      |            (5) following 'true' branch (when 'current2' is non-NULL)...\n    |   21 |             if (prev == NULL) {\n    |      |                ~     \n    |      |                |\n    |      |                (6) ...to here\n    |      |                (7) following 'true' branch (when 'prev' is NULL)...\n    |   22 |                 *list1 = current1->next;\n    |      |                          ~~~~~~~~~~~~~~\n    |      |                                  |\n    |      |                                  (8) ...to here\n    |......\n    |   27 |             current1 = prev->next;\n    |      |             ~~~~~~~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (9) dereference of NULL 'prev'\n    |\n
162§True§"collected_code/problem-162-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-162-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (4500 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
163§True§"collected_code/problem-163-0.c:14:18: error: Cannot determine that 'numSides' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &numSides);\n                 ^\ncollected_code/problem-163-0.c:16:18: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &sideLength);\n                 ^\ncollected_code/problem-163-0.c:17:98: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    printf(""The area of the regular polygon is: %.2f\n"", calculateAreaOfRegularPolygon(numSides, sideLength));\n                                                                                                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-163-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.02 seconds (1031 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 294.118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
164§True§"collected_code/problem-164-0.c:20:21: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                    ^\ncollected_code/problem-164-0.c:20:28: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-164-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (4009 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 160 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
165§True§collected_code/problem-165-0.c:6:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-165-0.c:7:17: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if ((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z')) {\n                ^\ncollected_code/problem-165-0.c:8:28: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (tolower(str[i]) - 'a' == i || toupper(str[i]) - 'A' == i) {\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-165-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.22 seconds (100 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-165-0.c: In function 'countCharacters':\ncollected_code/problem-165-0.c:8:17: warning: implicit declaration of function 'tolower' [-Wimplicit-function-declaration]\n    8 |             if (tolower(str[i]) - 'a' == i || toupper(str[i]) - 'A' == i) {\n      |                 ^~~~~~~\ncollected_code/problem-165-0.c:2:1: note: include '<ctype.h>' or provide a declaration of 'tolower'\n    1 | #include <stdio.h>\n  +++ |+#include <ctype.h>\n    2 | \ncollected_code/problem-165-0.c:8:47: warning: implicit declaration of function 'toupper' [-Wimplicit-function-declaration]\n    8 |             if (tolower(str[i]) - 'a' == i || toupper(str[i]) - 'A' == i) {\n      |                                               ^~~~~~~\ncollected_code/problem-165-0.c:8:47: note: include '<ctype.h>' or provide a declaration of 'toupper'\n
166§True§collected_code/problem-166-0.c:11:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if ((arr[i] ^ arr[j]) % 2 == 0)\n                    ^\ncollected_code/problem-166-0.c:11:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if ((arr[i] ^ arr[j]) % 2 == 0)\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-166-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (4131 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 45.4545 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
167§True§Checking collected_code/problem-167-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-167-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (1458 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
168§True§collected_code/problem-168-0.c:6:14: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if (arr[i] == num) {\n             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-168-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.35 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
169§True§"collected_code/problem-169-0.c:22:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-169-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (4222 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
170§True§collected_code/problem-170-0.c:8:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += arr[i];\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-170-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.35 seconds (62 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
171§True§"collected_code/problem-171-0.c:10:18: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &side);\n                 ^\ncollected_code/problem-171-0.c:11:42: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    float perimeter = calculatePerimeter(side);\n                                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-171-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.40 seconds (33 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
172§True§collected_code/problem-172-0.c:6:24: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n   int length = strlen(str);\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-172-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-172-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 24 in approximately 0.37 seconds (65 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+] 55.5556 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
173§True§collected_code/problem-173-0.c:19:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str), stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-173-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-173-0.c:17:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 22 in approximately 0.01 seconds (2020 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+] 47.619 [2+] 47.619 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-173-0.c: In function 'removeNonAlphanumeric':\ncollected_code/problem-173-0.c:9:13: warning: implicit declaration of function 'isalnum' [-Wimplicit-function-declaration]\n    9 |         if (isalnum(str[i])) {\n      |             ^~~~~~~\ncollected_code/problem-173-0.c:2:1: note: include '<ctype.h>' or provide a declaration of 'isalnum'\n    1 | #include <stdio.h>\n  +++ |+#include <ctype.h>\n    2 | \n
174§True§collected_code/problem-174-0.c:25:26: error: Cannot determine that 'key[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strcpy(newNode->key, key);\n                         ^\ncollected_code/problem-174-0.c:26:28: error: Cannot determine that 'value[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strcpy(newNode->value, value);\n                           ^\ncollected_code/problem-174-0.c:46:26: error: Cannot determine that 'input[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        char* key = input[i];\n                         ^\ncollected_code/problem-174-0.c:47:28: error: Cannot determine that 'input[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        char* value = input[i + 1];\n                           ^\ncollected_code/problem-174-0.c:49:40: error: Cannot determine that 'key' is initialized [premium-bughuntingUninit]\n        insertKeyValuePair(dictionary, key, value);\n                                       ^\ncollected_code/problem-174-0.c:49:45: error: Cannot determine that 'value' is initialized [premium-bughuntingUninit]\n        insertKeyValuePair(dictionary, key, value);\n                                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-174-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-174-0.c:25:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-174-0.c:26:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-174-0.c:6:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-174-0.c:7:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 68 in approximately 0.01 seconds (8596 lines/second)\nPhysical Source Lines of Code (SLOC) = 54\nHits@level = [0]   1 [1]   0 [2]   2 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   5 [1+]   4 [2+]   4 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 92.5926 [1+] 74.0741 [2+] 74.0741 [3+] 37.037 [4+] 37.037 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-174-0.c: In function 'createDictionary':\ncollected_code/problem-174-0.c:18:22: warning: dereference of possibly-NULL 'dictionary' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   18 |     dictionary->head = NULL;\n      |                      ^\n  'groupKeyValuePairs': events 1-2\n    |\n    |   42 | void groupKeyValuePairs(char** input, int length) {\n    |      |      ^~~~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'groupKeyValuePairs'\n    |   43 |     Dictionary* dictionary = createDictionary();\n    |      |                              ~~~~~~~~~~~~~~~~~~\n    |      |                              |\n    |      |                              (2) calling 'createDictionary' from 'groupKeyValuePairs'\n    |\n    +--> 'createDictionary': events 3-4\n           |\n           |   16 | Dictionary* createDictionary() {\n           |      |             ^~~~~~~~~~~~~~~~\n           |      |             |\n           |      |             (3) entry to 'createDictionary'\n           |   17 |     Dictionary* dictionary = (Dictionary*)malloc(sizeof(Dictionary));\n           |      |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                           |\n           |      |                                           (4) this call could return NULL\n           |\n         'createDictionary': event 5\n           |\n           |   18 |     dictionary->head = NULL;\n           |      |                      ^\n           |      |                      |\n           |      |                      (5) 'dictionary' could be NULL: unchecked value from (4)\n           |\ncollected_code/problem-174-0.c: In function 'insertKeyValuePair':\ncollected_code/problem-174-0.c:27:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   27 |     newNode->next = NULL;\n      |                   ^\n  'insertKeyValuePair': event 1\n    |\n    |   24 |     Node* newNode = (Node*)malloc(sizeof(Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |\n  'insertKeyValuePair': event 2\n    |\n    |   27 |     newNode->next = NULL;\n    |      |                   ^\n    |      |                   |\n    |      |                   (2) 'newNode' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-174-0.c: In function 'groupKeyValuePairs':\ncollected_code/problem-174-0.c:58:17: warning: leak of 'current' [CWE-401] [-Wanalyzer-malloc-leak]\n   58 |         current = current->next;\n      |         ~~~~~~~~^~~~~~~~~~~~~~~\n  'groupKeyValuePairs': events 1-4\n    |\n    |   42 | void groupKeyValuePairs(char** input, int length) {\n    |      |      ^~~~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'groupKeyValuePairs'\n    |......\n    |   45 |     for (int i = 0; i < length; i++) {\n    |      |                     ~~~~~~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < length')...\n    |   46 |         char* key = input[i];\n    |      |                          ~\n    |      |                          |\n    |      |                          (3) ...to here\n    |......\n    |   49 |         insertKeyValuePair(dictionary, key, value);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (4) calling 'insertKeyValuePair' from 'groupKeyValuePairs'\n    |\n    +--> 'insertKeyValuePair': events 5-6\n           |\n           |   23 | void insertKeyValuePair(Dictionary* dictionary, char* key, char* value) {\n           |      |      ^~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (5) entry to 'insertKeyValuePair'\n           |   24 |     Node* newNode = (Node*)malloc(sizeof(Node));\n           |      |                            ~~~~~~~~~~~~~~~~~~~~\n           |      |                            |\n           |      |                            (6) allocated here\n           |\n         'insertKeyValuePair': events 7-9\n           |\n           |   27 |     newNode->next = NULL;\n           |      |                   ^\n           |      |                   |\n           |      |                   (7) assuming 'newNode' is non-NULL\n           |   28 | \n           |   29 |     if (dictionary->head == NULL) {\n           |      |        ~           \n           |      |        |\n           |      |        (8) following 'true' branch...\n           |   30 |         dictionary->head = newNode;\n           |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                          |\n           |      |                          (9) ...to here\n           |\n    <------+\n    |\n  'groupKeyValuePairs': events 10-12\n    |\n    |   45 |     for (int i = 0; i < length; i++) {\n    |      |                     ~~~~~~~~~~\n    |      |                       |\n    |      |                       (11) following 'false' branch (when 'i >= length')...\n    |......\n    |   49 |         insertKeyValuePair(dictionary, key, value);\n    |      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (10) returning to 'groupKeyValuePairs' from 'insertKeyValuePair'\n    |......\n    |   55 |     Node* current = dictionary->head;\n    |      |           ~~~~~~~\n    |      |           |\n    |      |           (12) ...to here\n    |\n  'groupKeyValuePairs': events 13-14\n    |\n    |   56 |     while (current != NULL) {\n    |      |                    ^\n    |      |                    |\n    |      |                    (13) following 'true' branch (when 'current' is non-NULL)...\n    |   57 |         printf(""%s: %s\n"", current->key, current->value);\n    |      |                                          ~~~~~~~~~~~~~~\n    |      |                                                 |\n    |      |                                                 (14) ...to here\n    |\n  'groupKeyValuePairs': events 15-17\n    |\n    |   56 |     while (current != NULL) {\n    |      |                    ^\n    |      |                    |\n    |      |                    (15) following 'false' branch (when 'current' is NULL)...\n    |   57 |         printf(""%s: %s\n"", current->key, current->value);\n    |   58 |         current = current->next;\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                 |\n    |      |                 (17) 'current' leaks here; was allocated at (6)\n    |   59 |     }\n    |   60 | }\n    |      | ~                   \n    |      | |\n    |      | (16) ...to here\n    |\ncollected_code/problem-174-0.c:60:1: warning: leak of 'dictionary' [CWE-401] [-Wanalyzer-malloc-leak]\n   60 | }\n      | ^\n  'groupKeyValuePairs': events 1-2\n    |\n    |   42 | void groupKeyValuePairs(char** input, int length) {\n    |      |      ^~~~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'groupKeyValuePairs'\n    |   43 |     Dictionary* dictionary = createDictionary();\n    |      |                              ~~~~~~~~~~~~~~~~~~\n    |      |                              |\n    |      |                              (2) calling 'createDictionary' from 'groupKeyValuePairs'\n    |\n    +--> 'createDictionary': events 3-4\n           |\n           |   16 | Dictionary* createDictionary() {\n           |      |             ^~~~~~~~~~~~~~~~\n           |      |             |\n           |      |             (3) entry to 'createDictionary'\n           |   17 |     Dictionary* dictionary = (Dictionary*)malloc(sizeof(Dictionary));\n           |      |                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                           |\n           |      |                                           (4) allocated here\n           |\n         'createDictionary': event 5\n           |\n           |   18 |     dictionary->head = NULL;\n           |      |                      ^\n           |      |                      |\n           |      |                      (5) assuming 'dictionary' is non-NULL\n           |\n    <------+\n    |\n  'groupKeyValuePairs': events 6-8\n    |\n    |   43 |     Dictionary* dictionary = createDictionary();\n    |      |                              ^~~~~~~~~~~~~~~~~~\n    |      |                              |\n    |      |                              (6) returning to 'groupKeyValuePairs' from 'createDictionary'\n    |   44 | \n    |   45 |     for (int i = 0; i < length; i++) {\n    |      |                     ~~~~~~~~~~\n    |      |                       |\n    |      |                       (7) following 'false' branch (when 'i >= length')...\n    |......\n    |   55 |     Node* current = dictionary->head;\n    |      |           ~~~~~~~             \n    |      |           |\n    |      |           (8) ...to here\n    |\n  'groupKeyValuePairs': events 9-11\n    |\n    |   56 |     while (current != NULL) {\n    |      |                    ^\n    |      |                    |\n    |      |                    (9) following 'false' branch (when 'current' is NULL)...\n    |......\n    |   60 | }\n    |      | ~                   \n    |      | |\n    |      | (10) ...to here\n    |      | (11) 'dictionary' leaks here; was allocated at (4)\n    |\ncollected_code/problem-174-0.c:60:1: warning: leak of '<unknown>' [CWE-401] [-Wanalyzer-malloc-leak]\n   60 | }\n      | ^\n  'groupKeyValuePairs': events 1-4\n    |\n    |   42 | void groupKeyValuePairs(char** input, int length) {\n    |      |      ^~~~~~~~~~~~~~~~~~\n    |      |      |\n    |      |      (1) entry to 'groupKeyValuePairs'\n    |......\n    |   45 |     for (int i = 0; i < length; i++) {\n    |      |                     ~~~~~~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < length')...\n    |   46 |         char* key = input[i];\n    |      |                          ~\n    |      |                          |\n    |      |                          (3) ...to here\n    |......\n    |   49 |         insertKeyValuePair(dictionary, key, value);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (4) calling 'insertKeyValuePair' from 'groupKeyValuePairs'\n    |\n    +--> 'insertKeyValuePair': events 5-7\n           |\n           |   23 | void insertKeyValuePair(Dictionary* dictionary, char* key, char* value) {\n           |      |      ^~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (5) entry to 'insertKeyValuePair'\n           |......\n           |   29 |     if (dictionary->head == NULL) {\n           |      |        ~\n           |      |        |\n           |      |        (6) following 'true' branch...\n           |   30 |         dictionary->head = newNode;\n           |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                          |\n           |      |                          (7) ...to here\n           |\n    <------+\n    |\n  'groupKeyValuePairs': events 8-11\n    |\n    |   45 |     for (int i = 0; i < length; i++) {\n    |      |                     ~~~~~~~~~~\n    |      |                       |\n    |      |                       (9) following 'true' branch (when 'i < length')...\n    |   46 |         char* key = input[i];\n    |      |                          ~\n    |      |                          |\n    |      |                          (10) ...to here\n    |......\n    |   49 |         insertKeyValuePair(dictionary, key, value);\n    |      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (8) returning to 'groupKeyValuePairs' from 'insertKeyValuePair'\n    |      |         (11) calling 'insertKeyValuePair' from 'groupKeyValuePairs'\n    |\n    +--> 'insertKeyValuePair': events 12-13\n           |\n           |   23 | void insertKeyValuePair(Dictionary* dictionary, char* key, char* value) {\n           |      |      ^~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (12) entry to 'insertKeyValuePair'\n           |   24 |     Node* newNode = (Node*)malloc(sizeof(Node));\n           |      |                            ~~~~~~~~~~~~~~~~~~~~\n           |      |                            |\n           |      |                            (13) allocated here\n           |\n         'insertKeyValuePair': events 14-16\n           |\n           |   27 |     newNode->next = NULL;\n           |      |                   ^\n           |      |                   |\n           |      |                   (14) assuming 'newNode' is non-NULL\n           |   28 | \n           |   29 |     if (dictionary->head == NULL) {\n           |      |        ~           \n           |      |        |\n           |      |        (15) following 'false' branch...\n           |......\n           |   32 |         Node* current = dictionary->head;\n           |      |               ~~~~~~~\n           |      |               |\n           |      |               (16) ...to here\n           |\n         'insertKeyValuePair': events 17-18\n           |\n           |   33 |         while (current->next != NULL) {\n           |      |                              ^\n           |      |                              |\n           |      |                              (17) following 'false' branch...\n           |......\n           |   36 |         current->next = newNode;\n           |      |         ~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (18) ...to here\n           |\n    <------+\n    |\n  'groupKeyValuePairs': events 19-21\n    |\n    |   45 |     for (int i = 0; i < length; i++) {\n    |      |                     ~~~~~~~~~~\n    |      |                       |\n    |      |                       (20) following 'false' branch (when 'i >= length')...\n    |......\n    |   49 |         insertKeyValuePair(dictionary, key, value);\n    |      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (19) returning to 'groupKeyValuePairs' from 'insertKeyValuePair'\n    |......\n    |   55 |     Node* current = dictionary->head;\n    |      |           ~~~~~~~\n    |      |           |\n    |      |           (21) ...to here\n    |\n  'groupKeyValuePairs': events 22-23\n    |\n    |   56 |     while (current != NULL) {\n    |      |                    ^\n    |      |                    |\n    |      |                    (22) following 'true' branch (when 'current' is non-NULL)...\n    |   57 |         printf(""%s: %s\n"", current->key, current->value);\n    |      |                                          ~~~~~~~~~~~~~~\n    |      |                                                 |\n    |      |                                                 (23) ...to here\n    |\n  'groupKeyValuePairs': events 24-25\n    |\n    |   56 |     while (current != NULL) {\n    |      |                    ^\n    |      |                    |\n    |      |                    (24) following 'true' branch (when 'current' is non-NULL)...\n    |   57 |         printf(""%s: %s\n"", current->key, current->value);\n    |      |                                          ~~~~~~~~~~~~~~\n    |      |                                                 |\n    |      |                                                 (25) ...to here\n    |\n  'groupKeyValuePairs': events 26-28\n    |\n    |   56 |     while (current != NULL) {\n    |      |                    ^\n    |      |                    |\n    |      |                    (26) following 'false' branch (when 'current' is NULL)...\n    |......\n    |   60 | }\n    |      | ~                   \n    |      | |\n    |      | (27) ...to here\n    |      | (28) '<unknown>' leaks here; was allocated at (13)\n    |\n"
175§False§collected_code/problem-175-0.c:6:22: error: Cannot determine that 's[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; s[i] != '\0'; i++) {\n                     ^\ncollected_code/problem-175-0.c:7:14: error: Cannot determine that 's[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (s[i] == '(')\n             ^\ncollected_code/problem-175-0.c:9:19: error: Cannot determine that 's[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (s[i] == ')') {\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-175-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2640 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
176§True§"collected_code/problem-176-0.c:10:24: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &side1, &side2, &side3);\n                       ^\ncollected_code/problem-176-0.c:10:32: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &side1, &side2, &side3);\n                               ^\ncollected_code/problem-176-0.c:10:40: error: Cannot determine that 'side3' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &side1, &side2, &side3);\n                                       ^\ncollected_code/problem-176-0.c:12:30: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n    float result = perimeter(side1, side2, side3);\n                             ^\ncollected_code/problem-176-0.c:12:37: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n    float result = perimeter(side1, side2, side3);\n                                    ^\ncollected_code/problem-176-0.c:12:44: error: Cannot determine that 'side3' is initialized [premium-bughuntingUninit]\n    float result = perimeter(side1, side2, side3);\n                                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-176-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (2052 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
177§True§"collected_code/problem-177-0.c:39:18: error: Cannot determine that 'range' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &range);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-177-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 43 in approximately 0.01 seconds (5842 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
178§True§collected_code/problem-178-0.c:6:28: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int stringLen = strlen(string);\n                           ^\ncollected_code/problem-178-0.c:7:26: error: Cannot determine that 'searchWord[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int wordLen = strlen(searchWord);\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-178-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-178-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-178-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 30 in approximately 0.00 seconds (6352 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 120 [1+]  80 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
179§True§"collected_code/problem-179-0.c:47:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-179-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 55 in approximately 0.01 seconds (8301 lines/second)\nPhysical Source Lines of Code (SLOC) = 46\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
180§True§Checking collected_code/problem-180-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-180-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (6522 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
181§True§collected_code/problem-181-0.c:9:24: error: Cannot determine that 'strs[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char* prefix = strs[0];\n                       ^\ncollected_code/problem-181-0.c:14:36: error: Cannot determine that 'strs[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (prefix[j] && strs[i][j] && prefix[j] == strs[i][j]) {\n                                   ^\ncollected_code/problem-181-0.c:18:9: error: Cannot determine that 'prefix' is initialized [premium-bughuntingUninit]\n        prefix[j] = '\0';\n        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-181-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.32 seconds (99 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-181-0.c: In function 'longestCommonPrefix':\ncollected_code/problem-181-0.c:18:19: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   18 |         prefix[j] = '\0';\n      |         ~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   24 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   28 |     char* commonPrefix = longestCommonPrefix(strings, size);\n    |      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (2) calling 'longestCommonPrefix' from 'main'\n    |\n    +--> 'longestCommonPrefix': events 3-10\n           |\n           |    4 | char* longestCommonPrefix(char** strs, int size) {\n           |      |       ^~~~~~~~~~~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'longestCommonPrefix'\n           |    5 |     if (size == 0) {\n           |      |        ~\n           |      |        |\n           |      |        (4) following 'false' branch (when 'size != 0')...\n           |......\n           |    9 |     char* prefix = strs[0];\n           |      |           ~~~~~~\n           |      |           |\n           |      |           (5) ...to here\n           |......\n           |   12 |     for (i = 1; i < size; i++) {\n           |      |                 ~~~~~~~~\n           |      |                   |\n           |      |                   (6) following 'true' branch (when 'i < size')...\n           |   13 |         j = 0;\n           |      |         ~~~~~\n           |      |           |\n           |      |           (7) ...to here\n           |   14 |         while (prefix[j] && strs[i][j] && prefix[j] == strs[i][j]) {\n           |      |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                        |\n           |      |                                        (8) following 'true' branch...\n           |   15 |             j++;\n           |      |             ~~~\n           |      |              |\n           |      |              (9) ...to here\n           |......\n           |   18 |         prefix[j] = '\0';\n           |      |         ~~~~~~~~~~~~~~~~\n           |      |                   |\n           |      |                   (10) write to string literal here\n           |\n
182§True§"collected_code/problem-182-0.c:11:53: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n    printf(""Uppercase letter found: %.*s\n"", matches[0].rm_eo - matches[0].rm_so, &str[matches[0].rm_so]);\n                                                    ^\ncollected_code/problem-182-0.c:12:19: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n    str += matches[0].rm_eo;\n                  ^\ncollected_code/problem-182-0.c:19:53: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n    printf(""Lowercase letter found: %.*s\n"", matches[0].rm_eo - matches[0].rm_so, &str[matches[0].rm_so]);\n                                                    ^\ncollected_code/problem-182-0.c:20:19: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n    str += matches[0].rm_eo;\n                  ^\ncollected_code/problem-182-0.c:27:54: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n    printf(""Special character found: %.*s\n"", matches[0].rm_eo - matches[0].rm_so, &str[matches[0].rm_so]);\n                                                     ^\ncollected_code/problem-182-0.c:28:19: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n    str += matches[0].rm_eo;\n                  ^\ncollected_code/problem-182-0.c:35:50: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n    printf(""Numeric value found: %.*s\n"", matches[0].rm_eo - matches[0].rm_so, &str[matches[0].rm_so]);\n                                                 ^\ncollected_code/problem-182-0.c:36:19: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n    str += matches[0].rm_eo;\n                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-182-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 44 in approximately 0.01 seconds (6137 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 114.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
183§True§collected_code/problem-183-0.c:10:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] - arr[j] == k || arr[j] - arr[i] == k) {\n                   ^\ncollected_code/problem-183-0.c:10:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] - arr[j] == k || arr[j] - arr[i] == k) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-183-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.02 seconds (1305 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
184§True§"collected_code/problem-184-0.c:5:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] > target) {\n                ^\ncollected_code/problem-184-0.c:6:32: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d\n"", list[i]);\n                               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-184-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (2028 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
185§True§"collected_code/problem-185-0.c:10:24: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                       ^\ncollected_code/problem-185-0.c:10:28: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                           ^\ncollected_code/problem-185-0.c:10:32: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                               ^\ncollected_code/problem-185-0.c:12:29: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    float focus = findFocus(a, b, c);\n                            ^\ncollected_code/problem-185-0.c:12:32: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    float focus = findFocus(a, b, c);\n                               ^\ncollected_code/problem-185-0.c:12:35: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    float focus = findFocus(a, b, c);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-185-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.39 seconds (41 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
186§True§collected_code/problem-186-0.c:9:27: error: Cannot determine that 'pattern[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    ret = regcomp(&regex, pattern, REG_EXTENDED);\n                          ^\ncollected_code/problem-186-0.c:15:27: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    ret = regexec(&regex, string, 0, NULL, 0);\n                          ^\ncollected_code/problem-186-0.c:22:31: error: Cannot determine that 'error_message[0]' is initialized [premium-bughuntingUninit]\n        regerror(ret, &regex, error_message, sizeof(error_message));\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-186-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-186-0.c:21:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 36 in approximately 0.20 seconds (176 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   4 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+] 33.3333 [2+] 33.3333 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
187§True§"collected_code/problem-187-0.c:15:23: error: Cannot determine that 'X[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            else if (X[i - 1] == Y[j - 1])\n                      ^\ncollected_code/problem-187-0.c:15:35: error: Cannot determine that 'Y[j-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            else if (X[i - 1] == Y[j - 1])\n                                  ^\ncollected_code/problem-187-0.c:29:14: error: Cannot determine that 'X[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (X[i - 1] == Y[j - 1]) {\n             ^\ncollected_code/problem-187-0.c:29:26: error: Cannot determine that 'Y[j-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (X[i - 1] == Y[j - 1]) {\n                         ^\ncollected_code/problem-187-0.c:30:31: error: Cannot determine that 'X[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            lcs[index - 1] = X[i - 1];\n                              ^\ncollected_code/problem-187-0.c:41:46: error: Cannot determine that 'lcs[0]' is initialized [premium-bughuntingUninit]\n    printf(""Longest Common Subsequence: %s"", lcs);\n                                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-187-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-187-0.c:23:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-187-0.c:54:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-187-0.c:55:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 59 in approximately 0.01 seconds (8761 lines/second)\nPhysical Source Lines of Code (SLOC) = 49\nHits@level = [0]   1 [1]   2 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   3 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 81.6327 [1+] 61.2245 [2+] 20.4082 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
188§True§"collected_code/problem-188-0.c:9:32: error: Division by zero. [zerodiv]\n        int remaining = number / (i * i);\n                               ^\ncollected_code/problem-188-0.c:8:18: note: Assignment 'i=0', assigned value is 0\n    for (int i = 0; i * i <= number; i++) {\n                 ^\ncollected_code/problem-188-0.c:9:32: note: Division by zero\n        int remaining = number / (i * i);\n                               ^\ncollected_code/problem-188-0.c:20:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-188-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.56 seconds (50 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 160 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
189§True§collected_code/problem-189-0.c:9:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == 1) {\n               ^\ncollected_code/problem-189-0.c:21:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] <= 0 || arr[i] > n) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-189-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 50 in approximately 0.28 seconds (176 lines/second)\nPhysical Source Lines of Code (SLOC) = 38\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 26.3158 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-189-0.c: In function 'findMissingPositive':\ncollected_code/problem-189-0.c:28:21: warning: implicit declaration of function 'abs' [-Wimplicit-function-declaration]\n   28 |         int index = abs(arr[i]) - 1;\n      |                     ^~~\ncollected_code/problem-189-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'abs'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \n
190§True§"collected_code/problem-190-0.c:16:18: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &sideLength);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-190-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.49 seconds (39 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
191§True§"collected_code/problem-191-0.c:5:16: error: Cannot determine that 'month[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (strcmp(month, ""January"") == 0 || strcmp(month, ""March"") == 0 || strcmp(month, ""May"") == 0 ||\n               ^\ncollected_code/problem-191-0.c:20:17: error: Cannot determine that 'month[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", month);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-191-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-191-0.c:20:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-191-0.c:18:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 32 in approximately 0.01 seconds (3099 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   4 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   6 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+] 71.4286 [2+] 71.4286 [3+] 35.7143 [4+] 35.7143 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
192§True§"collected_code/problem-192-0.c:8:23: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for(int i = 0; str[i] != '\0'; i++) {\n                      ^\ncollected_code/problem-192-0.c:9:23: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(isalpha(str[i]))\n                      ^\ncollected_code/problem-192-0.c:11:28: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if(isdigit(str[i]))\n                           ^\ncollected_code/problem-192-0.c:24:17: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-192-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-192-0.c:24:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-192-0.c:22:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 31 in approximately 0.01 seconds (3464 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]  80 [2+]  80 [3+]  40 [4+]  40 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
193§True§Checking collected_code/problem-193-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-193-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (4548 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
194§True§"collected_code/problem-194-0.c:19:18: error: Cannot determine that 'octalNumber' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &octalNumber);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-194-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3278 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-194-0.c: In function 'convertOctalToDecimal':\ncollected_code/problem-194-0.c:7:47: warning: implicit declaration of function 'pow' [-Wimplicit-function-declaration]\n    7 |         decimalNumber += (octalNumber % 10) * pow(8, i);\n      |                                               ^~~\ncollected_code/problem-194-0.c:2:1: note: include '<math.h>' or provide a declaration of 'pow'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-194-0.c:7:47: warning: incompatible implicit declaration of built-in function 'pow' [-Wbuiltin-declaration-mismatch]\n    7 |         decimalNumber += (octalNumber % 10) * pow(8, i);\n      |                                               ^~~\ncollected_code/problem-194-0.c:7:47: note: include '<math.h>' or provide a declaration of 'pow'\n
195§False§collected_code/problem-195-0.c:9:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] == target) {\n               ^\ncollected_code/problem-195-0.c:13:21: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[mid] < target) {\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-195-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.09 seconds (236 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
196§True§collected_code/problem-196-0.c:6:18: error: Cannot determine that 'array[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (array[i] != k) {\n                 ^\ncollected_code/problem-196-0.c:7:33: error: Cannot determine that 'array[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            array[count] = array[i];\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-196-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (6010 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
197§True§"collected_code/problem-197-0.c:14:18: error: Cannot determine that 'base' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &base);\n                 ^\ncollected_code/problem-197-0.c:16:18: error: Cannot determine that 'power' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &power);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-197-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.02 seconds (1368 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 277.778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
198§True§"collected_code/problem-198-0.c:30:17: error: Cannot determine that 'semiMajorAxis' is initialized [premium-bughuntingUninit]\n  scanf(""%lf"", &semiMajorAxis);\n                ^\ncollected_code/problem-198-0.c:33:17: error: Cannot determine that 'semiMinorAxis' is initialized [premium-bughuntingUninit]\n  scanf(""%lf"", &semiMinorAxis);\n                ^\ncollected_code/problem-198-0.c:35:32: error: Cannot determine that 'semiMajorAxis' is initialized [premium-bughuntingUninit]\n  findLargestTriangleInEllipse(semiMajorAxis, semiMinorAxis);\n                               ^\ncollected_code/problem-198-0.c:35:47: error: Cannot determine that 'semiMinorAxis' is initialized [premium-bughuntingUninit]\n  findLargestTriangleInEllipse(semiMajorAxis, semiMinorAxis);\n                                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-198-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.63 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
199§True§"collected_code/problem-199-0.c:15:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-199-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.09 seconds (191 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
200§True§"collected_code/problem-200-0.c:5:21: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int maxVal = arr[0];\n                    ^\ncollected_code/problem-200-0.c:10:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > maxVal)\n               ^\ncollected_code/problem-200-0.c:12:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            maxVal = arr[i];\n                        ^\ncollected_code/problem-200-0.c:15:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[i] == maxVal)\n                    ^\ncollected_code/problem-200-0.c:34:36: error: Cannot determine that 'maxIndexes[0]' is initialized [premium-bughuntingUninit]\n    for (int i = 1; i <= maxIndexes[0]; i++)\n                                   ^\ncollected_code/problem-200-0.c:36:33: error: Cannot determine that 'maxIndexes[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", maxIndexes[i]);\n                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-200-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.06 seconds (682 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
201§False§collected_code/problem-201-0.c:4:27: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int firstElement = arr[0];\n                          ^\ncollected_code/problem-201-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] != firstElement) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-201-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 10 in approximately 0.02 seconds (520 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
202§True§collected_code/problem-202-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-202-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-202-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 16 in approximately 0.01 seconds (2576 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 133.333 [1+] 66.6667 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-202-0.c: In function 'removeEvenChars':\ncollected_code/problem-202-0.c:8:21: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n    8 |         str[j] = str[i];\n      |                  ~~~^~~\n  'main': events 1-3\n    |\n    |   12 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   13 |     char str[] = ""Hello World!"";\n    |      |          ~~~\n    |      |          |\n    |      |          (2) capacity: 13 bytes\n    |   14 |     removeEvenChars(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (3) calling 'removeEvenChars' from 'main'\n    |\n    +--> 'removeEvenChars': events 4-21\n           |\n           |    4 | void removeEvenChars(char* str) {\n           |      |      ^~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'removeEvenChars'\n           |......\n           |    7 |     for (i = 0, j = 0; i < len; i += 2, j++)\n           |      |                        ~~~~~~~\n           |      |                          |\n           |      |                          (5) following 'true' branch (when 'i < len')...\n           |      |                          (7) following 'true' branch (when 'i < len')...\n           |      |                          (9) following 'true' branch (when 'i < len')...\n           |      |                          (11) following 'true' branch (when 'i < len')...\n           |      |                          (13) following 'true' branch (when 'i < len')...\n           |      |                          (15) following 'true' branch (when 'i < len')...\n           |      |                          (17) following 'true' branch (when 'i < len')...\n           |      |                          (19) following 'true' branch (when 'i < len')...\n           |    8 |         str[j] = str[i];\n           |      |                  ~~~~~~\n           |      |                     |\n           |      |                     (6) ...to here\n           |      |                     (8) ...to here\n           |      |                     (10) ...to here\n           |      |                     (12) ...to here\n           |      |                     (14) ...to here\n           |      |                     (16) ...to here\n           |      |                     (18) ...to here\n           |      |                     (20) ...to here\n           |      |                     (21) out-of-bounds read at byte 14 but 'str' ends at byte 13\n           |\ncollected_code/problem-202-0.c:8:21: note: read of 1 byte from after the end of 'str'\n    8 |         str[j] = str[i];\n      |                  ~~~^~~\ncollected_code/problem-202-0.c:8:21: note: valid subscripts for 'str' are '[0]' to '[12]'\ncollected_code/problem-202-0.c:8:21: warning: use of uninitialized value '*str_13(D) + _2' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n  'main': events 1-3\n    |\n    |   12 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   13 |     char str[] = ""Hello World!"";\n    |      |          ~~~\n    |      |          |\n    |      |          (2) region created on stack here\n    |   14 |     removeEvenChars(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (3) calling 'removeEvenChars' from 'main'\n    |\n    +--> 'removeEvenChars': events 4-21\n           |\n           |    4 | void removeEvenChars(char* str) {\n           |      |      ^~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'removeEvenChars'\n           |......\n           |    7 |     for (i = 0, j = 0; i < len; i += 2, j++)\n           |      |                        ~~~~~~~\n           |      |                          |\n           |      |                          (5) following 'true' branch (when 'i < len')...\n           |      |                          (7) following 'true' branch (when 'i < len')...\n           |      |                          (9) following 'true' branch (when 'i < len')...\n           |      |                          (11) following 'true' branch (when 'i < len')...\n           |      |                          (13) following 'true' branch (when 'i < len')...\n           |      |                          (15) following 'true' branch (when 'i < len')...\n           |      |                          (17) following 'true' branch (when 'i < len')...\n           |      |                          (19) following 'true' branch (when 'i < len')...\n           |    8 |         str[j] = str[i];\n           |      |                  ~~~~~~\n           |      |                     |\n           |      |                     (6) ...to here\n           |      |                     (8) ...to here\n           |      |                     (10) ...to here\n           |      |                     (12) ...to here\n           |      |                     (14) ...to here\n           |      |                     (16) ...to here\n           |      |                     (18) ...to here\n           |      |                     (20) ...to here\n           |      |                     (21) use of uninitialized value '*str_13(D) + _2' here\n           |\n"
203§True§Checking collected_code/problem-203-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-203-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.35 seconds (69 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
204§True§collected_code/problem-204-0.c:5:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-204-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == ch) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-204-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2434 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
205§True§"collected_code/problem-205-0.c:31:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-205-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (7398 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
206§True§Checking collected_code/problem-206-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-206-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (3215 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 133.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
207§True§collected_code/problem-207-0.c:5:20: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int n = strlen(str);\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-207-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-207-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 31 in approximately 0.01 seconds (5120 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+] 38.4615 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
208§False§"collected_code/problem-208-0.c:13:14: error: Cannot determine that 'buffer[0]' is initialized [premium-bughuntingUninit]\n    snprintf(buffer, sizeof(buffer), ""%.2f"", decimal);\n             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-208-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-208-0.c:12:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 18 in approximately 0.51 seconds (35 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+] 71.4286 [2+] 71.4286 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-208-0.c: In function 'checkPrecision':\ncollected_code/problem-208-0.c:13:5: warning: implicit declaration of function 'snprintf' [-Wimplicit-function-declaration]\n   13 |     snprintf(buffer, sizeof(buffer), ""%.2f"", decimal);\n      |     ^~~~~~~~\ncollected_code/problem-208-0.c:2:1: note: include '<stdio.h>' or provide a declaration of 'snprintf'\n    1 | #include <regex.h>\n  +++ |+#include <stdio.h>\n    2 | \ncollected_code/problem-208-0.c:13:5: warning: incompatible implicit declaration of built-in function 'snprintf' [-Wbuiltin-declaration-mismatch]\n   13 |     snprintf(buffer, sizeof(buffer), ""%.2f"", decimal);\n      |     ^~~~~~~~\ncollected_code/problem-208-0.c:13:5: note: include '<stdio.h>' or provide a declaration of 'snprintf'\ncollected_code/problem-208-0.c:15:39: error: 'NULL' undeclared (first use in this function)\n   15 |     reti = regexec(&regex, buffer, 0, NULL, 0);\n      |                                       ^~~~\ncollected_code/problem-208-0.c:2:1: note: 'NULL' is defined in header '<stddef.h>'; did you forget to '#include <stddef.h>'?\n    1 | #include <regex.h>\n  +++ |+#include <stddef.h>\n    2 | \ncollected_code/problem-208-0.c:15:39: note: each undeclared identifier is reported only once for each function it appears in\n   15 |     reti = regexec(&regex, buffer, 0, NULL, 0);\n      |                                       ^~~~\n"
209§True§"collected_code/problem-209-0.c:5:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-209-0.c:6:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-209-0.c:16:24: error: Cannot determine that 'arr[left]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] < arr[smallest])\n                       ^\ncollected_code/problem-209-0.c:16:36: error: Cannot determine that 'arr[smallest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] < arr[smallest])\n                                   ^\ncollected_code/problem-209-0.c:19:25: error: Cannot determine that 'arr[right]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] < arr[smallest])\n                        ^\ncollected_code/problem-209-0.c:19:38: error: Cannot determine that 'arr[smallest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] < arr[smallest])\n                                     ^\ncollected_code/problem-209-0.c:40:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr[i]);\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-209-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 57 in approximately 0.47 seconds (121 lines/second)\nPhysical Source Lines of Code (SLOC) = 40\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
210§True§Checking collected_code/problem-210-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-210-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.38 seconds (103 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
211§True§"collected_code/problem-211-0.c:15:21: error: Cannot determine that 'oth' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &oth, &nth);\n                    ^\ncollected_code/problem-211-0.c:15:27: error: Cannot determine that 'nth' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &oth, &nth);\n                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-211-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2117 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
212§True§"collected_code/problem-212-0.c:14:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-212-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (1897 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
213§False§collected_code/problem-213-0.c:4:12: error: Cannot determine that 'result[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strcpy(result, str1);\n           ^\ncollected_code/problem-213-0.c:4:20: error: Cannot determine that 'str1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strcpy(result, str1);\n                   ^\ncollected_code/problem-213-0.c:5:20: error: Cannot determine that 'str2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strcat(result, str2);\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-213-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-213-0.c:4:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-213-0.c:5:  [4] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 5 in approximately 0.40 seconds (12 lines/second)\nPhysical Source Lines of Code (SLOC) = 5\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   2 [1+]   2 [2+]   2 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 400 [1+] 400 [2+] 400 [3+] 400 [4+] 400 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
214§True§Checking collected_code/problem-214-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-214-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.01 seconds (2589 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
215§True§collected_code/problem-215-0.c:7:33: error: Cannot determine that 'encoded_list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; encoded_list[i] != '\0'; i += 2) {\n                                ^\ncollected_code/problem-215-0.c:8:30: error: Cannot determine that 'encoded_list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        length = encoded_list[i] - '0';\n                             ^\ncollected_code/problem-215-0.c:9:30: error: Cannot determine that 'encoded_list[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        letter = encoded_list[i + 1];\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-215-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (2785 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
216§False§collected_code/problem-216-0.c:10:14: error: Cannot determine that 'list1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (list1[0] == list2[0]) {\n             ^\ncollected_code/problem-216-0.c:10:26: error: Cannot determine that 'list2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (list1[0] == list2[0]) {\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-216-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.01 seconds (2179 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
217§True§collected_code/problem-217-0.c:5:25: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length = strlen(str);\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-217-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-217-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 27 in approximately 0.42 seconds (64 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+] 45.4545 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-217-0.c: In function 'findFirstRepeatedChar':\ncollected_code/problem-217-0.c:5:18: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n    5 |     int length = strlen(str);\n      |                  ^~~~~~\ncollected_code/problem-217-0.c:2:1: note: include '<string.h>' or provide a declaration of 'strlen'\n    1 | #include <stdio.h>\n  +++ |+#include <string.h>\n    2 | \ncollected_code/problem-217-0.c:5:18: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n    5 |     int length = strlen(str);\n      |                  ^~~~~~\ncollected_code/problem-217-0.c:5:18: note: include '<string.h>' or provide a declaration of 'strlen'\n
218§True§"collected_code/problem-218-0.c:22:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-218-0.c:24:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-218-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.53 seconds (57 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 217.391 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
219§False§Checking collected_code/problem-219-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-219-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2714 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
220§True§collected_code/problem-220-0.c:7:12: error: Cannot determine that '*ptr' is initialized [premium-bughuntingUninit]\n    while (*ptr != '\0' && count < n) {\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-220-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.14 seconds (168 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
221§True§collected_code/problem-221-0.c:5:20: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (numbers[i] % 2 == 0) {\n                   ^\ncollected_code/problem-221-0.c:6:27: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            return numbers[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-221-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (3422 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
222§False§Checking collected_code/problem-222-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-222-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 9 in approximately 0.01 seconds (1587 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
223§True§collected_code/problem-223-0.c:9:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == element)\n               ^\ncollected_code/problem-223-0.c:21:30: error: Cannot determine that 'arr[n/2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int majorityElement = arr[n / 2];\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-223-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.01 seconds (6767 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 60.6061 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
224§True§Checking collected_code/problem-224-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-224-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.30 seconds (82 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
225§True§collected_code/problem-225-0.c:6:12: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[low] <= arr[high]) {\n           ^\ncollected_code/problem-225-0.c:6:24: error: Cannot determine that 'arr[high]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[low] <= arr[high]) {\n                       ^\ncollected_code/problem-225-0.c:7:19: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return arr[low];\n                  ^\ncollected_code/problem-225-0.c:12:19: error: Cannot determine that 'arr[high]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return arr[high];\n                  ^\ncollected_code/problem-225-0.c:18:12: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {\n           ^\ncollected_code/problem-225-0.c:18:23: error: Cannot determine that 'arr[mid-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {\n                      ^\ncollected_code/problem-225-0.c:18:50: error: Cannot determine that 'arr[mid+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[mid] < arr[mid - 1] && arr[mid] < arr[mid + 1]) {\n                                                 ^\ncollected_code/problem-225-0.c:19:19: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return arr[mid];\n                  ^\ncollected_code/problem-225-0.c:23:12: error: Cannot determine that 'arr[high]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[high] > arr[mid]) {\n           ^\ncollected_code/problem-225-0.c:23:24: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[high] > arr[mid]) {\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-225-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.01 seconds (7140 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 35.7143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
226§True§collected_code/problem-226-0.c:5:15: error: Cannot determine that 'str[length]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[length] != '\0') {\n              ^\ncollected_code/problem-226-0.c:11:21: error: Cannot determine that 'str[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        str[i] = str[j];\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-226-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.34 seconds (62 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-226-0.c: In function 'removeOddIndexChars':\ncollected_code/problem-226-0.c:11:21: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n   11 |         str[i] = str[j];\n      |                  ~~~^~~\n  'main': events 1-3\n    |\n    |   16 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   17 |     char str[] = ""abcdefgh"";\n    |      |          ~~~\n    |      |          |\n    |      |          (2) capacity: 9 bytes\n    |   18 |     removeOddIndexChars(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (3) calling 'removeOddIndexChars' from 'main'\n    |\n    +--> 'removeOddIndexChars': events 4-9\n           |\n           |    3 | void removeOddIndexChars(char* str) {\n           |      |      ^~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'removeOddIndexChars'\n           |    4 |     int length = 0;\n           |    5 |     while (str[length] != '\0') {\n           |      |            ~~~~~~~~~~~~~~~~~~~\n           |      |                        |\n           |      |                        (5) following 'true' branch...\n           |    6 |         length++;\n           |      |         ~~~~~~~~\n           |      |               |\n           |      |               (6) ...to here\n           |......\n           |   10 |     for (i = 0, j = 1; i < length && j < length; i += 2, j += 2) {\n           |      |                        ~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                   |\n           |      |                                   (7) following 'true' branch...\n           |   11 |         str[i] = str[j];\n           |      |                  ~~~~~~\n           |      |                     |\n           |      |                     (8) ...to here\n           |      |                     (9) out-of-bounds read at byte 9 but 'str' ends at byte 9\n           |\ncollected_code/problem-226-0.c:11:21: note: read of 1 byte from after the end of 'str'\n   11 |         str[i] = str[j];\n      |                  ~~~^~~\ncollected_code/problem-226-0.c:11:21: note: valid subscripts for 'str' are '[0]' to '[8]'\ncollected_code/problem-226-0.c:11:21: warning: use of uninitialized value '*str_16(D) + _4' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n  'main': events 1-3\n    |\n    |   16 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   17 |     char str[] = ""abcdefgh"";\n    |      |          ~~~\n    |      |          |\n    |      |          (2) region created on stack here\n    |   18 |     removeOddIndexChars(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (3) calling 'removeOddIndexChars' from 'main'\n    |\n    +--> 'removeOddIndexChars': events 4-9\n           |\n           |    3 | void removeOddIndexChars(char* str) {\n           |      |      ^~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'removeOddIndexChars'\n           |    4 |     int length = 0;\n           |    5 |     while (str[length] != '\0') {\n           |      |            ~~~~~~~~~~~~~~~~~~~\n           |      |                        |\n           |      |                        (5) following 'true' branch...\n           |    6 |         length++;\n           |      |         ~~~~~~~~\n           |      |               |\n           |      |               (6) ...to here\n           |......\n           |   10 |     for (i = 0, j = 1; i < length && j < length; i += 2, j += 2) {\n           |      |                        ~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                   |\n           |      |                                   (7) following 'true' branch...\n           |   11 |         str[i] = str[j];\n           |      |                  ~~~~~~\n           |      |                     |\n           |      |                     (8) ...to here\n           |      |                     (9) use of uninitialized value '*str_16(D) + _4' here\n           |\n"
227§True§"collected_code/problem-227-0.c:21:24: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &num1, &num2, &num3);\n                       ^\ncollected_code/problem-227-0.c:21:31: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &num1, &num2, &num3);\n                              ^\ncollected_code/problem-227-0.c:21:38: error: Cannot determine that 'num3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &num1, &num2, &num3);\n                                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-227-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.39 seconds (69 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
228§False§Checking collected_code/problem-228-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-228-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 5 in approximately 0.01 seconds (368 lines/second)\nPhysical Source Lines of Code (SLOC) = 5\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
229§True§collected_code/problem-229-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < 0) {\n               ^\ncollected_code/problem-229-0.c:9:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                temp = arr[i];\n                          ^\ncollected_code/problem-229-0.c:10:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                arr[i] = arr[j];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-229-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.38 seconds (71 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
230§True§"collected_code/problem-230-0.c:5:20: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; str[i] != '\0'; i++) {\n                   ^\ncollected_code/problem-230-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == ' ') {\n               ^\ncollected_code/problem-230-0.c:16:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str), stdin);\n          ^\ncollected_code/problem-230-0.c:18:18: error: Cannot determine that 'ch' is initialized [premium-bughuntingUninit]\n    scanf(""%c"", &ch);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-230-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-230-0.c:13:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 21 in approximately 0.02 seconds (946 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   4 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]  50 [2+]  50 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
231§True§"collected_code/problem-231-0.c:16:23: error: Cannot determine that 'triangle[0][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    return triangle[0][0];\n                      ^\ncollected_code/problem-231-0.c:24:18: error: Cannot determine that 'rows' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &rows);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-231-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.16 seconds (237 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 192.308 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
232§True§collected_code/problem-232-0.c:5:12: error: Cannot determine that '*(int*)b' is initialized [premium-bughuntingUninit]\n   return (*(int*)b - *(int*)a);\n           ^\ncollected_code/problem-232-0.c:5:23: error: Cannot determine that '*(int*)a' is initialized [premium-bughuntingUninit]\n   return (*(int*)b - *(int*)a);\n                      ^\ncollected_code/problem-232-0.c:9:10: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n   qsort(arr, size, sizeof(int), cmpfunc);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-232-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.52 seconds (46 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
233§True§Checking collected_code/problem-233-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-233-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (3157 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
234§True§"collected_code/problem-234-0.c:10:18: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &side);\n                 ^\ncollected_code/problem-234-0.c:11:37: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    float volume = findVolumeOfCube(side);\n                                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-234-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.29 seconds (44 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
235§True§"collected_code/problem-235-0.c:11:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%u"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-235-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (1462 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 230.769 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
236§True§Checking collected_code/problem-236-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-236-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.42 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
237§True§"collected_code/problem-237-0.c:13:12: error: Cannot determine that 'count[0]' is initialized [premium-bughuntingUninit]\n    memset(count, 0, sizeof(count));\n           ^\ncollected_code/problem-237-0.c:19:33: error: Cannot determine that 'tuples[i].name[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strcmp(tuples[i].name, tuples[j].name) == 0) {\n                                ^\ncollected_code/problem-237-0.c:36:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-237-0.c:42:27: error: Cannot determine that 'tuples[i] members' is initialized [premium-bughuntingUninit]\n        scanf(""%s"", tuples[i].name);\n                          ^\ncollected_code/problem-237-0.c:50:36: error: Cannot determine that 'tuples[i] members' is initialized [premium-bughuntingUninit]\n        printf(""Name: %s\n"", tuples[i].name);\n                                   ^\ncollected_code/problem-237-0.c:51:43: error: Cannot determine that 'tuples[i] members' is initialized [premium-bughuntingUninit]\n        printf(""Occurrences: %d\n"", tuples[i].occurrence);\n                                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-237-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-237-0.c:42:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-237-0.c:7:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 55 in approximately 0.01 seconds (6285 lines/second)\nPhysical Source Lines of Code (SLOC) = 44\nHits@level = [0]  10 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]  12 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 272.727 [1+] 45.4545 [2+] 45.4545 [3+] 22.7273 [4+] 22.7273 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
238§True§"collected_code/problem-238-0.c:5:25: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length = strlen(str);\n                        ^\ncollected_code/problem-238-0.c:20:21: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%[^\n]"", str);\n                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-238-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-238-0.c:18:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-238-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 25 in approximately 0.22 seconds (113 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+] 100 [2+]  50 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
239§True§Checking collected_code/problem-239-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-239-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.41 seconds (48 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
240§True§Checking collected_code/problem-240-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-240-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 70 in approximately 0.01 seconds (12411 lines/second)\nPhysical Source Lines of Code (SLOC) = 50\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  20 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-240-0.c: In function 'main':\ncollected_code/problem-240-0.c:30:17: warning: dereference of possibly-NULL 'head1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   30 |     head1->data = 1;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   29 |     head1 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |   30 |     head1->data = 1;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'head1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-240-0.c:34:19: warning: dereference of possibly-NULL 'second1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   34 |     second1->data = 2;\n      |     ~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   33 |     struct Node* second1 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                          |\n    |      |                                          (1) this call could return NULL\n    |   34 |     second1->data = 2;\n    |      |     ~~~~~~~~~~~~~~~~~                     \n    |      |                   |\n    |      |                   (2) 'second1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-240-0.c:38:18: warning: dereference of possibly-NULL 'third1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   38 |     third1->data = 3;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   37 |     struct Node* third1 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                         |\n    |      |                                         (1) this call could return NULL\n    |   38 |     third1->data = 3;\n    |      |     ~~~~~~~~~~~~~~~~                     \n    |      |                  |\n    |      |                  (2) 'third1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-240-0.c:46:17: warning: dereference of possibly-NULL 'head2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   46 |     head2->data = 4;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   45 |     head2 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |   46 |     head2->data = 4;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'head2' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-240-0.c:50:19: warning: dereference of possibly-NULL 'second2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   50 |     second2->data = 5;\n      |     ~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   49 |     struct Node* second2 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                          |\n    |      |                                          (1) this call could return NULL\n    |   50 |     second2->data = 5;\n    |      |     ~~~~~~~~~~~~~~~~~                     \n    |      |                   |\n    |      |                   (2) 'second2' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-240-0.c:54:18: warning: dereference of possibly-NULL 'third2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   54 |     third2->data = 6;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   53 |     struct Node* third2 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                         |\n    |      |                                         (1) this call could return NULL\n    |   54 |     third2->data = 6;\n    |      |     ~~~~~~~~~~~~~~~~                     \n    |      |                  |\n    |      |                  (2) 'third2' could be NULL: unchecked value from (1)\n    |\n
241§True§"collected_code/problem-241-0.c:22:40: error: Cannot determine that 'arr[i][j][k]' is initialized [premium-bughuntingUninit]\n                printf(""%c "", arr[i][j][k]);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-241-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-241-0.c:15:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 29 in approximately 0.35 seconds (82 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 160 [1+]  40 [2+]  40 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
242§True§collected_code/problem-242-0.c:6:11: error: Cannot determine that '*str' is initialized [premium-bughuntingUninit]\n   while (*str != '\0') {\n          ^\ncollected_code/problem-242-0.c:18:10: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n   fgets(str, sizeof(str), stdin);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-242-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-242-0.c:15:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 24 in approximately 0.01 seconds (3674 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+] 58.8235 [2+] 58.8235 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
243§True§collected_code/problem-243-0.c:4:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-243-0.c:5:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-243-0.c:12:20: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j] > arr[j+1]) {\n                   ^\ncollected_code/problem-243-0.c:12:29: error: Cannot determine that 'arr[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j] > arr[j+1]) {\n                            ^\ncollected_code/problem-243-0.c:22:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == target) {\n               ^\ncollected_code/problem-243-0.c:30:27: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int firstElement = arr[0];\n                          ^\ncollected_code/problem-243-0.c:35:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (arr[i] != firstElement) {\n                  ^\ncollected_code/problem-243-0.c:39:19: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (arr[j] == firstElement) {\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-243-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 57 in approximately 0.01 seconds (9770 lines/second)\nPhysical Source Lines of Code (SLOC) = 50\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  20 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
244§True§"collected_code/problem-244-0.c:16:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-244-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2972 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
245§True§collected_code/problem-245-0.c:32:18: warning: Uninitialized variable: asc [uninitvar]\n    int maxSum = asc[0] + desc[0] - arr[0];\n                 ^\ncollected_code/problem-245-0.c:12:23: note: Assuming condition is false\n    for (int i = 0; i < n; i++) {\n                      ^\ncollected_code/problem-245-0.c:32:18: note: Uninitialized variable: asc\n    int maxSum = asc[0] + desc[0] - arr[0];\n                 ^\ncollected_code/problem-245-0.c:32:27: warning: Uninitialized variable: desc [uninitvar]\n    int maxSum = asc[0] + desc[0] - arr[0];\n                          ^\ncollected_code/problem-245-0.c:22:27: note: Assuming condition is false\n    for (int i = n - 1; i >= 0; i--) {\n                          ^\ncollected_code/problem-245-0.c:32:27: note: Uninitialized variable: desc\n    int maxSum = asc[0] + desc[0] - arr[0];\n                          ^\ncollected_code/problem-245-0.c:13:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        asc[i] = arr[i];\n                    ^\ncollected_code/problem-245-0.c:15:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j]) {\n                   ^\ncollected_code/problem-245-0.c:15:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j]) {\n                            ^\ncollected_code/problem-245-0.c:16:50: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                asc[i] = max(asc[i], asc[j] + arr[i]);\n                                                 ^\ncollected_code/problem-245-0.c:23:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        desc[i] = arr[i];\n                     ^\ncollected_code/problem-245-0.c:25:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j]) {\n                   ^\ncollected_code/problem-245-0.c:25:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j]) {\n                            ^\ncollected_code/problem-245-0.c:26:53: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                desc[i] = max(desc[i], desc[j] + arr[i]);\n                                                    ^\ncollected_code/problem-245-0.c:32:21: error: Cannot determine that 'asc[0]' is initialized [premium-bughuntingUninit]\n    int maxSum = asc[0] + desc[0] - arr[0];\n                    ^\ncollected_code/problem-245-0.c:32:31: error: Cannot determine that 'desc[0]' is initialized [premium-bughuntingUninit]\n    int maxSum = asc[0] + desc[0] - arr[0];\n                              ^\ncollected_code/problem-245-0.c:32:40: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int maxSum = asc[0] + desc[0] - arr[0];\n                                       ^\ncollected_code/problem-245-0.c:34:52: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        maxSum = max(maxSum, asc[i] + desc[i] - arr[i]);\n                                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-245-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 47 in approximately 0.61 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 27.7778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
246§True§"collected_code/problem-246-0.c:18:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &number);\n                 ^\ncollected_code/problem-246-0.c:20:44: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    printf(""Square root of %.2f = %.6f\n"", number, squareRoot(number));\n                                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-246-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (1858 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
247§True§collected_code/problem-247-0.c:9:20: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int n = strlen(str);\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-247-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-247-0.c:9:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 37 in approximately 0.64 seconds (58 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+] 31.25 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
248§True§Checking collected_code/problem-248-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-248-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (1924 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
249§True§"collected_code/problem-249-0.c:6:21: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr1[i] == arr2[j]) {\n                    ^\ncollected_code/problem-249-0.c:6:32: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr1[i] == arr2[j]) {\n                               ^\ncollected_code/problem-249-0.c:7:35: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                printf(""%d "", arr1[i]);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-249-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3315 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
250§True§collected_code/problem-250-0.c:7:18: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple[i] == element) {\n                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-250-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3692 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
251§True§Checking collected_code/problem-251-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-251-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.01 seconds (5741 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.037 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-251-0.c: In function 'insertBeforeEach':\ncollected_code/problem-251-0.c:13:20: warning: dereference of possibly-NULL 'new_node' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   13 |     new_node->data = new_data;\n      |     ~~~~~~~~~~~~~~~^~~~~~~~~~\n  'insertBeforeEach': events 1-2\n    |\n    |   12 |     struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                           |\n    |      |                                           (1) this call could return NULL\n    |   13 |     new_node->data = new_data;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~              \n    |      |                    |\n    |      |                    (2) 'new_node' could be NULL: unchecked value from (1)\n    |\n
252§False§Checking collected_code/problem-252-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-252-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (2203 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
253§True§collected_code/problem-253-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] >= 0 && arr[i] <= 9) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-253-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3980 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
254§True§collected_code/problem-254-0.c:9:12: error: Cannot determine that '*str' is initialized [premium-bughuntingUninit]\n    while (*str != '\0') {\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-254-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.49 seconds (78 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 60.6061 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
255§True§"collected_code/problem-255-0.c:11:38: error: Cannot determine that 'combination[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", combination[i]);\n                                     ^\ncollected_code/problem-255-0.c:18:43: error: Cannot determine that 'colors[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        combination[currentIndex] = colors[i];\n                                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-255-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.16 seconds (190 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  80 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-255-0.c: In function 'generateColorCombinations':\ncollected_code/problem-255-0.c:5:5: warning: implicit declaration of function 'generateCombinations'; did you mean 'generateColorCombinations'? [-Wimplicit-function-declaration]\n    5 |     generateCombinations(colors, numColors, combination, numCombinations, 0);\n      |     ^~~~~~~~~~~~~~~~~~~~\n      |     generateColorCombinations\ncollected_code/problem-255-0.c: At top level:\ncollected_code/problem-255-0.c:8:6: warning: conflicting types for 'generateCombinations'; have 'void(int *, int,  int *, int,  int)'\n    8 | void generateCombinations(int colors[], int numColors, int combination[], int numCombinations, int currentIndex) {\n      |      ^~~~~~~~~~~~~~~~~~~~\ncollected_code/problem-255-0.c:5:5: note: previous implicit declaration of 'generateCombinations' with type 'void(int *, int,  int *, int,  int)'\n    5 |     generateCombinations(colors, numColors, combination, numCombinations, 0);\n      |     ^~~~~~~~~~~~~~~~~~~~\n
256§True§"collected_code/problem-256-0.c:34:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-256-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.34 seconds (119 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
257§False§collected_code/problem-257-0.c:2:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-257-0.c:3:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-257-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 4 in approximately 0.01 seconds (754 lines/second)\nPhysical Source Lines of Code (SLOC) = 5\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
258§False§collected_code/problem-258-0.c:7:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(arr[i] % 2 != 0) {\n              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-258-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.49 seconds (24 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
259§True§collected_code/problem-259-0.c:5:19: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple1[i] < tuple2[i]) {\n                  ^\ncollected_code/problem-259-0.c:5:31: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple1[i] < tuple2[i]) {\n                              ^\ncollected_code/problem-259-0.c:6:31: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            tuple1[i] = tuple2[i];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-259-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2177 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
260§False§Checking collected_code/problem-260-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-260-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.47 seconds (74 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 34.4828 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-260-0.c: In function 'countPrimes':\ncollected_code/problem-260-0.c:19:20: error: 'n' undeclared (first use in this function)\n   19 |     while (count < n) {\n      |                    ^\ncollected_code/problem-260-0.c:19:20: note: each undeclared identifier is reported only once for each function it appears in\n
261§True§"collected_code/problem-261-0.c:5:42: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d / %d = %.2f\n"", tuple1[i], tuple2[i], (float)tuple1[i] / tuple2[i]);\n                                         ^\ncollected_code/problem-261-0.c:5:53: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d / %d = %.2f\n"", tuple1[i], tuple2[i], (float)tuple1[i] / tuple2[i]);\n                                                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-261-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (1872 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
262§True§Checking collected_code/problem-262-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-262-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 70 in approximately 0.41 seconds (169 lines/second)\nPhysical Source Lines of Code (SLOC) = 58\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 68.9655 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-262-0.c: In function 'main':\ncollected_code/problem-262-0.c:40:26: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   40 |     head = (struct Node*)malloc(sizeof(struct Node));\n      |                          ^~~~~~\ncollected_code/problem-262-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include<stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-262-0.c:40:26: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   40 |     head = (struct Node*)malloc(sizeof(struct Node));\n      |                          ^~~~~~\ncollected_code/problem-262-0.c:40:26: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-262-0.c:45:16: warning: dereference of possibly-NULL 'head' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   45 |     head->data = 1;\n      |     ~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   40 |     head = (struct Node*)malloc(sizeof(struct Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |......\n    |   45 |     head->data = 1;\n    |      |     ~~~~~~~~~~~~~~        \n    |      |                |\n    |      |                (2) 'head' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-262-0.c:47:18: warning: dereference of possibly-NULL 'second' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   47 |     second->data = 2;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   41 |     second = (struct Node*)malloc(sizeof(struct Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |......\n    |   47 |     second->data = 2;\n    |      |     ~~~~~~~~~~~~~~~~        \n    |      |                  |\n    |      |                  (2) 'second' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-262-0.c:49:17: warning: dereference of possibly-NULL 'third' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   49 |     third->data = 3;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   42 |     third = (struct Node*)malloc(sizeof(struct Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |......\n    |   49 |     third->data = 3;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'third' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-262-0.c:51:18: warning: dereference of possibly-NULL 'fourth' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   51 |     fourth->data = 4;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   43 |     fourth = (struct Node*)malloc(sizeof(struct Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |......\n    |   51 |     fourth->data = 4;\n    |      |     ~~~~~~~~~~~~~~~~        \n    |      |                  |\n    |      |                  (2) 'fourth' could be NULL: unchecked value from (1)\n    |\n
263§True§"collected_code/problem-263-0.c:11:35: error: Cannot determine that 'dictionary1[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strcmp(dictionary1[j], dictionary2[i]) == 0) {\n                                  ^\ncollected_code/problem-263-0.c:11:51: error: Cannot determine that 'dictionary2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strcmp(dictionary1[j], dictionary2[i]) == 0) {\n                                                  ^\ncollected_code/problem-263-0.c:17:31: error: Cannot determine that 'dictionary1[size1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            strcpy(dictionary1[size1], dictionary2[i]);\n                              ^\ncollected_code/problem-263-0.c:17:51: error: Cannot determine that 'dictionary2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            strcpy(dictionary1[size1], dictionary2[i]);\n                                                  ^\ncollected_code/problem-263-0.c:29:18: error: Cannot determine that 'size1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size1);\n                 ^\ncollected_code/problem-263-0.c:34:32: error: Cannot determine that 'dictionary1[i]' is initialized [premium-bughuntingUninit]\n        scanf(""%s"", dictionary1[i]);\n                               ^\ncollected_code/problem-263-0.c:39:18: error: Cannot determine that 'size2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size2);\n                 ^\ncollected_code/problem-263-0.c:44:32: error: Cannot determine that 'dictionary2[i]' is initialized [premium-bughuntingUninit]\n        scanf(""%s"", dictionary2[i]);\n                               ^\ncollected_code/problem-263-0.c:53:35: error: Cannot determine that 'dictionary1[i]' is initialized [premium-bughuntingUninit]\n        printf(""%s\n"", dictionary1[i]);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-263-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-263-0.c:17:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-263-0.c:34:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-263-0.c:44:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-263-0.c:24:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 56 in approximately 0.01 seconds (6957 lines/second)\nPhysical Source Lines of Code (SLOC) = 40\nHits@level = [0]   8 [1]   0 [2]   1 [3]   0 [4]   3 [5]   0\nHits@level+ = [0+]  12 [1+]   4 [2+]   4 [3+]   3 [4+]   3 [5+]   0\nHits/KSLOC@level+ = [0+] 300 [1+] 100 [2+] 100 [3+]  75 [4+]  75 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
264§True§"collected_code/problem-264-0.c:26:18: error: Cannot determine that 'age' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &age);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-264-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.35 seconds (80 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
265§True§"collected_code/problem-265-0.c:9:27: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", list[i]);\n                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-265-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.30 seconds (68 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 117.647 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
266§True§"collected_code/problem-266-0.c:11:18: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &side);\n                 ^\ncollected_code/problem-266-0.c:13:44: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    float lateralArea = lateralSurfaceArea(side);\n                                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-266-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (1699 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
267§True§"collected_code/problem-267-0.c:15:17: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n   scanf(""%d"", &n);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-267-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.02 seconds (763 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
268§True§Checking collected_code/problem-268-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-268-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.42 seconds (43 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
269§True§"collected_code/problem-269-0.c:10:18: error: Cannot determine that 'character' is initialized [premium-bughuntingUninit]\n    scanf(""%c"", &character);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-269-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.54 seconds (22 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 272.727 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
270§True§collected_code/problem-270-0.c:10:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % 2 == 0) {\n               ^\ncollected_code/problem-270-0.c:11:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += arr[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-270-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3480 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
271§True§"collected_code/problem-271-0.c:16:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-271-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3762 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
272§True§Checking collected_code/problem-272-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-272-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.38 seconds (65 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
273§True§"collected_code/problem-273-0.c:5:27: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] - tuple2[i];\n                          ^\ncollected_code/problem-273-0.c:5:39: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] - tuple2[i];\n                                      ^\ncollected_code/problem-273-0.c:19:29: error: Cannot determine that 'result[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", result[i]);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-273-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.38 seconds (58 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
274§True§"collected_code/problem-274-0.c:25:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-274-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (3952 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 115.385 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
275§True§collected_code/problem-275-0.c:13:12: warning: Uninitialized variable: lastRemovedPos [uninitvar]\n    return lastRemovedPos;\n           ^\ncollected_code/problem-275-0.c:7:19: note: Assuming condition is false\n    for (i = 0; i < n; i++) {\n                  ^\ncollected_code/problem-275-0.c:13:12: note: Uninitialized variable: lastRemovedPos\n    return lastRemovedPos;\n           ^\ncollected_code/problem-275-0.c:5:29: error: Cannot determine that 'arr[n-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int removedElement = arr[n - 1];\n                            ^\ncollected_code/problem-275-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == removedElement) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-275-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.40 seconds (58 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-275-0.c: In function 'lastRemovedElementPosition':\ncollected_code/problem-275-0.c:13:12: warning: use of uninitialized value 'lastRemovedPos' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   13 |     return lastRemovedPos;\n      |            ^~~~~~~~~~~~~~\n  'lastRemovedElementPosition': events 1-3\n    |\n    |    4 |     int i, lastRemovedPos;\n    |      |            ^~~~~~~~~~~~~~\n    |      |            |\n    |      |            (1) region created on stack here\n    |      |            (2) capacity: 4 bytes\n    |......\n    |   13 |     return lastRemovedPos;\n    |      |            ~~~~~~~~~~~~~~\n    |      |            |\n    |      |            (3) use of uninitialized value 'lastRemovedPos' here\n    |\ncollected_code/problem-275-0.c:13:12: warning: use of uninitialized value 'lastRemovedPos' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   13 |     return lastRemovedPos;\n      |            ^~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   16 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   20 |     int lastRemovedPos = lastRemovedElementPosition(arr, n);\n    |      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (2) calling 'lastRemovedElementPosition' from 'main'\n    |\n    +--> 'lastRemovedElementPosition': events 3-10\n           |\n           |    3 | int lastRemovedElementPosition(int arr[], int n) {\n           |      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (3) entry to 'lastRemovedElementPosition'\n           |    4 |     int i, lastRemovedPos;\n           |      |            ~~~~~~~~~~~~~~\n           |      |            |\n           |      |            (4) region created on stack here\n           |      |            (5) capacity: 4 bytes\n           |......\n           |    7 |     for (i = 0; i < n; i++) {\n           |      |                 ~~~~~  ~~~\n           |      |                   |     |\n           |      |                   |     (9) ...to here\n           |      |                   (6) following 'true' branch (when 'i < n')...\n           |    8 |         if (arr[i] == removedElement) {\n           |      |            ~   ~\n           |      |            |   |\n           |      |            |   (7) ...to here\n           |      |            (8) following 'false' branch...\n           |......\n           |   13 |     return lastRemovedPos;\n           |      |            ~~~~~~~~~~~~~~\n           |      |            |\n           |      |            (10) use of uninitialized value 'lastRemovedPos' here\n           |\n
276§True§"collected_code/problem-276-0.c:12:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-276-0.c:14:18: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &height);\n                 ^\ncollected_code/problem-276-0.c:15:35: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    volume = findVolumeOfCylinder(radius, height);\n                                  ^\ncollected_code/problem-276-0.c:15:43: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    volume = findVolumeOfCylinder(radius, height);\n                                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-276-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2198 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 312.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
277§False§"collected_code/problem-277-0.c:6:22: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(dictionary[i] == value) {\n                     ^\ncollected_code/problem-277-0.c:7:38: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d\n"", dictionary[i]);\n                                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-277-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 9 in approximately 0.01 seconds (1289 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
278§True§collected_code/problem-278-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == record) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-278-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (3051 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
279§True§Checking collected_code/problem-279-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-279-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.01 seconds (1964 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
280§True§collected_code/problem-280-0.c:5:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == key) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-280-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3864 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
281§False§collected_code/problem-281-0.c:9:21: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[i] == list[j])\n                    ^\ncollected_code/problem-281-0.c:9:32: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[i] == list[j])\n                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-281-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2706 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
282§True§Checking collected_code/problem-282-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-282-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 73 in approximately 0.01 seconds (7814 lines/second)\nPhysical Source Lines of Code (SLOC) = 61\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 16.3934 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-282-0.c: In function 'subtractLists':\ncollected_code/problem-282-0.c:25:47: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   25 |             struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n      |                                               ^~~~~~\ncollected_code/problem-282-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-282-0.c:25:47: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   25 |             struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n      |                                               ^~~~~~\ncollected_code/problem-282-0.c:25:47: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-282-0.c: In function 'main':\ncollected_code/problem-282-0.c:54:27: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   54 |     list1 = (struct Node*)malloc(sizeof(struct Node));\n      |                           ^~~~~~\ncollected_code/problem-282-0.c:54:27: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-282-0.c: In function 'subtractLists':\ncollected_code/problem-282-0.c:26:24: warning: dereference of possibly-NULL 'node' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   26 |             node->data = list1->data;\n      |             ~~~~~~~~~~~^~~~~~~~~~~~~\n  'subtractLists': events 1-6\n    |\n    |   13 |     while (list1 != NULL) {\n    |      |                  ^\n    |      |                  |\n    |      |                  (1) following 'true' branch (when 'list1' is non-NULL)...\n    |   14 |         int exist = 0;\n    |      |             ~~~~~ \n    |      |             |\n    |      |             (2) ...to here\n    |......\n    |   23 |         if (exist == 0) {\n    |      |            ~      \n    |      |            |\n    |      |            (3) following 'true' branch (when 'exist == 0')...\n    |   24 |             // Add the current node to the result list\n    |   25 |             struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                               |\n    |      |                                               (4) ...to here\n    |      |                                               (5) this call could return NULL\n    |   26 |             node->data = list1->data;\n    |      |             ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                        |\n    |      |                        (6) 'node' could be NULL: unchecked value from (5)\n    |\ncollected_code/problem-282-0.c:47:1: warning: leak of 'result' [CWE-401] [-Wanalyzer-malloc-leak]\n   47 | }\n      | ^\n  'main': events 1-2\n    |\n    |   49 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   71 |     subtractLists(list1, list2);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'subtractLists' from 'main'\n    |\n    +--> 'subtractLists': event 3\n           |\n           |    8 | void subtractLists(struct Node* list1, struct Node* list2) {\n           |      |      ^~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'subtractLists'\n           |\n         'subtractLists': events 4-5\n           |\n           |   13 |     while (list1 != NULL) {\n           |      |                  ^\n           |      |                  |\n           |      |                  (4) following 'true' branch (when 'list1' is non-NULL)...\n           |   14 |         int exist = 0;\n           |      |             ~~~~~ \n           |      |             |\n           |      |             (5) ...to here\n           |\n         'subtractLists': events 6-9\n           |\n           |   16 |         while (temp != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (6) following 'true' branch (when 'temp' is non-NULL)...\n           |   17 |             if (list1->data == temp->data) {\n           |      |                ~~~~~~~~~~~~\n           |      |                |     |\n           |      |                |     (7) ...to here\n           |      |                (8) following 'false' branch...\n           |......\n           |   21 |             temp = temp->next;\n           |      |             ~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (9) ...to here\n           |\n         'subtractLists': events 10-13\n           |\n           |   16 |         while (temp != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (10) following 'true' branch (when 'temp' is non-NULL)...\n           |   17 |             if (list1->data == temp->data) {\n           |      |                ~~~~~~~~~~~~\n           |      |                |     |\n           |      |                |     (11) ...to here\n           |      |                (12) following 'false' branch...\n           |......\n           |   21 |             temp = temp->next;\n           |      |             ~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (13) ...to here\n           |\n         'subtractLists': events 14-17\n           |\n           |   16 |         while (temp != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (14) following 'true' branch (when 'temp' is non-NULL)...\n           |   17 |             if (list1->data == temp->data) {\n           |      |                ~~~~~~~~~~~~\n           |      |                |     |\n           |      |                |     (15) ...to here\n           |      |                (16) following 'false' branch...\n           |......\n           |   21 |             temp = temp->next;\n           |      |             ~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (17) ...to here\n           |\n         'subtractLists': events 18-25\n           |\n           |   16 |         while (temp != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (18) following 'false' branch (when 'temp' is NULL)...\n           |......\n           |   23 |         if (exist == 0) {\n           |      |            ~         \n           |      |            |\n           |      |            (19) ...to here\n           |      |            (20) following 'true' branch (when 'exist == 0')...\n           |   24 |             // Add the current node to the result list\n           |   25 |             struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n           |      |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                               |\n           |      |                                               (21) ...to here\n           |      |                                               (22) allocated here\n           |   26 |             node->data = list1->data;\n           |      |             ~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                        |\n           |      |                        (23) assuming 'node' is non-NULL\n           |   27 |             node->next = NULL;\n           |   28 |             if (result == NULL) {\n           |      |                ~     \n           |      |                |\n           |      |                (24) following 'true' branch (when 'result' is NULL)...\n           |   29 |                 result = node;\n           |      |                 ~~~~~~~~~~~~~\n           |      |                        |\n           |      |                        (25) ...to here\n           |\n         'subtractLists': events 26-27\n           |\n           |   13 |     while (list1 != NULL) {\n           |      |                  ^\n           |      |                  |\n           |      |                  (26) following 'true' branch (when 'list1' is non-NULL)...\n           |   14 |         int exist = 0;\n           |      |             ~~~~~ \n           |      |             |\n           |      |             (27) ...to here\n           |\n         'subtractLists': events 28-33\n           |\n           |   16 |         while (temp != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (28) following 'true' branch (when 'temp' is non-NULL)...\n           |   17 |             if (list1->data == temp->data) {\n           |      |                ~~~~~~~~~~~~\n           |      |                |     |\n           |      |                |     (29) ...to here\n           |      |                (30) following 'true' branch...\n           |   18 |                 exist = 1;\n           |      |                 ~~~~~~~~~\n           |      |                       |\n           |      |                       (31) ...to here\n           |......\n           |   23 |         if (exist == 0) {\n           |      |            ~         \n           |      |            |\n           |      |            (32) following 'false' branch (when 'exist != 0')...\n           |......\n           |   38 |         list1 = list1->next;\n           |      |         ~~~~~~~~~~~~~~~~~~~\n           |      |               |\n           |      |               (33) ...to here\n           |\n         'subtractLists': events 34-35\n           |\n           |   13 |     while (list1 != NULL) {\n           |      |                  ^\n           |      |                  |\n           |      |                  (34) following 'true' branch (when 'list1' is non-NULL)...\n           |   14 |         int exist = 0;\n           |      |             ~~~~~ \n           |      |             |\n           |      |             (35) ...to here\n           |\n         'subtractLists': events 36-39\n           |\n           |   16 |         while (temp != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (36) following 'true' branch (when 'temp' is non-NULL)...\n           |   17 |             if (list1->data == temp->data) {\n           |      |                ~~~~~~~~~~~~\n           |      |                |     |\n           |      |                |     (37) ...to here\n           |      |                (38) following 'false' branch...\n           |......\n           |   21 |             temp = temp->next;\n           |      |             ~~~~~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (39) ...to here\n           |\n         'subtractLists': events 40-45\n           |\n           |   16 |         while (temp != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (40) following 'true' branch (when 'temp' is non-NULL)...\n           |   17 |             if (list1->data == temp->data) {\n           |      |                ~~~~~~~~~~~~\n           |      |                |     |\n           |      |                |     (41) ...to here\n           |      |                (42) following 'true' branch...\n           |   18 |                 exist = 1;\n           |      |                 ~~~~~~~~~\n           |      |                       |\n           |      |                       (43) ...to here\n           |......\n           |   23 |         if (exist == 0) {\n           |      |            ~         \n           |      |            |\n           |      |            (44) following 'false' branch (when 'exist != 0')...\n           |......\n           |   38 |         list1 = list1->next;\n           |      |         ~~~~~~~~~~~~~~~~~~~\n           |      |               |\n           |      |               (45) ...to here\n           |\n         'subtractLists': events 46-47\n           |\n           |   13 |     while (list1 != NULL) {\n           |      |                  ^\n           |      |                  |\n           |      |                  (46) following 'false' branch (when 'list1' is NULL)...\n           |......\n           |   42 |     temp = result;\n           |      |     ~~~~~~~~~~~~~ \n           |      |          |\n           |      |          (47) ...to here\n           |\n         'subtractLists': events 48-49\n           |\n           |   43 |     while (temp != NULL) {\n           |      |                 ^\n           |      |                 |\n           |      |                 (48) following 'true' branch (when 'temp' is non-NULL)...\n           |   44 |         printf(""%d "", temp->data);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (49) ...to here\n           |\n         'subtractLists': events 50-52\n           |\n           |   43 |     while (temp != NULL) {\n           |      |                 ^\n           |      |                 |\n           |      |                 (50) following 'false' branch (when 'temp' is NULL)...\n           |......\n           |   47 | }\n           |      | ~                \n           |      | |\n           |      | (51) ...to here\n           |      | (52) 'result' leaks here; was allocated at (22)\n           |\ncollected_code/problem-282-0.c: In function 'main':\ncollected_code/problem-282-0.c:55:17: warning: dereference of possibly-NULL 'list1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   55 |     list1->data = 1;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   54 |     list1 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |   55 |     list1->data = 1;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'list1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-282-0.c:57:23: warning: dereference of possibly-NULL '*list1.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   57 |     list1->next->data = 2;\n      |     ~~~~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   56 |     list1->next = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                 |\n    |      |                                 (1) this call could return NULL\n    |   57 |     list1->next->data = 2;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~        \n    |      |                       |\n    |      |                       (2) '*list1.next' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-282-0.c:59:29: warning: dereference of possibly-NULL '*list1_21->next.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   59 |     list1->next->next->data = 3;\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   58 |     list1->next->next = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                       |\n    |      |                                       (1) this call could return NULL\n    |   59 |     list1->next->next->data = 3;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~        \n    |      |                             |\n    |      |                             (2) '*list1_21->next.next' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-282-0.c:64:17: warning: dereference of possibly-NULL 'list2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   64 |     list2->data = 2;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   63 |     list2 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |   64 |     list2->data = 2;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'list2' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-282-0.c:66:23: warning: dereference of possibly-NULL '*list2.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   66 |     list2->next->data = 3;\n      |     ~~~~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   65 |     list2->next = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                 |\n    |      |                                 (1) this call could return NULL\n    |   66 |     list2->next->data = 3;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~        \n    |      |                       |\n    |      |                       (2) '*list2.next' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-282-0.c:68:29: warning: dereference of possibly-NULL '*list2_31->next.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   68 |     list2->next->next->data = 4;\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   67 |     list2->next->next = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                       |\n    |      |                                       (1) this call could return NULL\n    |   68 |     list2->next->next->data = 4;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~        \n    |      |                             |\n    |      |                             (2) '*list2_31->next.next' could be NULL: unchecked value from (1)\n    |\n"
283§True§"collected_code/problem-283-0.c:25:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-283-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.44 seconds (75 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
284§False§collected_code/problem-284-0.c:7:24: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strcmp(list[i], str) != 0) {\n                       ^\ncollected_code/problem-284-0.c:7:29: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strcmp(list[i], str) != 0) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-284-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 11 in approximately 0.63 seconds (17 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
285§True§collected_code/problem-285-0.c:6:14: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while(str[i] != '\0') {\n             ^\ncollected_code/problem-285-0.c:7:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(str[i] == 'a') {\n              ^\ncollected_code/problem-285-0.c:8:19: error: Cannot determine that 'str[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(str[i + 1] == 'b' && (str[i + 2] == 'b' || str[i + 2] == '\0')) {\n                  ^\ncollected_code/problem-285-0.c:8:41: error: Cannot determine that 'str[i+2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(str[i + 1] == 'b' && (str[i + 2] == 'b' || str[i + 2] == '\0')) {\n                                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-285-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (3156 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
286§True§collected_code/problem-286-0.c:4:20: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n   int maxSum = arr[0];\n                   ^\ncollected_code/problem-286-0.c:5:24: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n   int currentSum = arr[0];\n                       ^\ncollected_code/problem-286-0.c:8:36: error: Cannot determine that 'arr[i%n]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      currentSum = currentSum + arr[i % n];\n                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-286-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (3168 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
287§True§"collected_code/problem-287-0.c:19:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-287-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (4159 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
288§True§collected_code/problem-288-0.c:17:15: error: Division by zero. [zerodiv]\n        q = a / p;\n              ^\ncollected_code/problem-288-0.c:49:13: note: Assignment 'p=5', assigned value is 5\n    int p = 5;\n            ^\ncollected_code/problem-288-0.c:51:44: note: Calling function 'countArrayElements', 3rd argument 'p' value is 5\n    int count = countArrayElements(arr, n, p);\n                                           ^\ncollected_code/problem-288-0.c:38:32: note: Calling function 'modInverse', 2nd argument 'p' value is 5\n        if (modInverse(arr[i], p) == arr[i]) {\n                               ^\ncollected_code/problem-288-0.c:18:13: note: Assignment 't=p', assigned value is 5\n        t = p;\n            ^\ncollected_code/problem-288-0.c:21:13: note: Assignment 'a=t', assigned value is 5\n        a = t;\n            ^\ncollected_code/problem-288-0.c:20:15: note: Assignment 'p=a%p', assigned value is 0\n        p = a % p;\n              ^\ncollected_code/problem-288-0.c:17:15: note: Division by zero\n        q = a / p;\n              ^\ncollected_code/problem-288-0.c:20:15: error: Division by zero. [zerodiv]\n        p = a % p;\n              ^\ncollected_code/problem-288-0.c:49:13: note: Assignment 'p=5', assigned value is 5\n    int p = 5;\n            ^\ncollected_code/problem-288-0.c:51:44: note: Calling function 'countArrayElements', 3rd argument 'p' value is 5\n    int count = countArrayElements(arr, n, p);\n                                           ^\ncollected_code/problem-288-0.c:38:32: note: Calling function 'modInverse', 2nd argument 'p' value is 5\n        if (modInverse(arr[i], p) == arr[i]) {\n                               ^\ncollected_code/problem-288-0.c:18:13: note: Assignment 't=p', assigned value is 5\n        t = p;\n            ^\ncollected_code/problem-288-0.c:21:13: note: Assignment 'a=t', assigned value is 5\n        a = t;\n            ^\ncollected_code/problem-288-0.c:20:15: note: Assignment 'p=a%p', assigned value is 0\n        p = a % p;\n              ^\ncollected_code/problem-288-0.c:20:15: note: Division by zero\n        p = a % p;\n              ^\ncollected_code/problem-288-0.c:38:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (modInverse(arr[i], p) == arr[i]) {\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-288-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 54 in approximately 0.01 seconds (4938 lines/second)\nPhysical Source Lines of Code (SLOC) = 41\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 24.3902 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
289§True§"collected_code/problem-289-0.c:20:18: error: Cannot determine that 'year' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &year);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-289-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (2947 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
290§True§collected_code/problem-290-0.c:11:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int* list = arr[i];\n                       ^\ncollected_code/problem-290-0.c:13:17: error: Cannot determine that 'list' is initialized [premium-bughuntingUninit]\n        while (*list != -1) {\n                ^\ncollected_code/problem-290-0.c:32:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int* list = arr[i];\n                       ^\ncollected_code/problem-290-0.c:34:17: error: Cannot determine that 'list' is initialized [premium-bughuntingUninit]\n        while (*list != -1) {\n                ^\ncollected_code/problem-290-0.c:40:13: error: Cannot determine that 'max_lists' is initialized [premium-bughuntingUninit]\n            max_lists[index] = arr[i];\n            ^\ncollected_code/problem-290-0.c:40:35: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max_lists[index] = arr[i];\n                                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-290-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 69 in approximately 0.01 seconds (5380 lines/second)\nPhysical Source Lines of Code (SLOC) = 55\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 54.5455 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-290-0.c: In function 'findMaxLists':\ncollected_code/problem-290-0.c:27:30: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   27 |     int** max_lists = (int**)malloc(num_lists * sizeof(int*));\n      |                              ^~~~~~\ncollected_code/problem-290-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-290-0.c:27:30: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   27 |     int** max_lists = (int**)malloc(num_lists * sizeof(int*));\n      |                              ^~~~~~\ncollected_code/problem-290-0.c:27:30: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-290-0.c:40:30: warning: dereference of possibly-NULL 'max_lists' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   40 |             max_lists[index] = arr[i];\n      |             ~~~~~~~~~~~~~~~~~^~~~~~~~\n  'findMaxLists': events 1-6\n    |\n    |   27 |     int** max_lists = (int**)malloc(num_lists * sizeof(int*));\n    |      |                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                              |\n    |      |                              (1) this call could return NULL\n    |......\n    |   30 |     for (int i = 0; i < rows; i++) {\n    |      |                     ~~~~~~~~  \n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < rows')...\n    |   31 |         int length = 0;\n    |      |             ~~~~~~            \n    |      |             |\n    |      |             (3) ...to here\n    |......\n    |   39 |         if (length == max_length) {\n    |      |            ~                  \n    |      |            |\n    |      |            (4) following 'true' branch (when 'length == max_length')...\n    |   40 |             max_lists[index] = arr[i];\n    |      |             ~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                              |    |\n    |      |                              |    (5) ...to here\n    |      |                              (6) 'max_lists + (long unsigned int)index * 8' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-290-0.c: In function 'main':\ncollected_code/problem-290-0.c:61:14: warning: use of uninitialized value '*max_lists_31 + _2' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   61 |         int* list = max_lists[i];\n      |              ^~~~\n  'main': events 1-2\n    |\n    |   48 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   57 |     int** max_lists = findMaxLists(input, 5);\n    |      |                       ~~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (2) calling 'findMaxLists' from 'main'\n    |\n    +--> 'findMaxLists': events 3-14\n           |\n           |    5 | int** findMaxLists(int** arr, int rows) {\n           |      |       ^~~~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'findMaxLists'\n           |......\n           |    9 |     for (int i = 0; i < rows; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < rows')...\n           |   10 |         int length = 0;\n           |      |             ~~~~~~\n           |      |             |\n           |      |             (5) ...to here\n           |......\n           |   13 |         while (*list != -1) {\n           |      |                ~~~~~~~~~~~\n           |      |                      |\n           |      |                      (6) following 'true' branch...\n           |   14 |             length++;\n           |      |             ~~~~~~~~\n           |      |                   |\n           |      |                   (7) ...to here\n           |......\n           |   27 |     int** max_lists = (int**)malloc(num_lists * sizeof(int*));\n           |      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                              |\n           |      |                              (8) region created on heap here\n           |......\n           |   30 |     for (int i = 0; i < rows; i++) {\n           |      |                     ~~~~~~~~  ~~~\n           |      |                       |        |\n           |      |                       |        (14) ...to here\n           |      |                       (9) following 'true' branch (when 'i < rows')...\n           |   31 |         int length = 0;\n           |      |             ~~~~~~\n           |      |             |\n           |      |             (10) ...to here\n           |......\n           |   34 |         while (*list != -1) {\n           |      |                ~~~~~~~~~~~\n           |      |                      |\n           |      |                      (11) following 'true' branch...\n           |   35 |             length++;\n           |      |             ~~~~~~~~\n           |      |                   |\n           |      |                   (12) ...to here\n           |......\n           |   39 |         if (length == max_length) {\n           |      |            ~\n           |      |            |\n           |      |            (13) following 'false' branch (when 'length != max_length')...\n           |\n    <------+\n    |\n  'main': events 15-18\n    |\n    |   57 |     int** max_lists = findMaxLists(input, 5);\n    |      |                       ^~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (15) returning to 'main' from 'findMaxLists'\n    |......\n    |   60 |     for (int i = 0; i < sizeof(max_lists) / sizeof(max_lists[0]); i++) {\n    |      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (16) following 'true' branch (when 'i == 0')...\n    |   61 |         int* list = max_lists[i];\n    |      |              ~~~~            ~\n    |      |              |               |\n    |      |              |               (17) ...to here\n    |      |              (18) use of uninitialized value '*max_lists_31 + _2' here\n    |\ncollected_code/problem-290-0.c:61:14: warning: dereference of possibly-NULL 'max_lists' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   61 |         int* list = max_lists[i];\n      |              ^~~~\n  'main': events 1-2\n    |\n    |   48 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   57 |     int** max_lists = findMaxLists(input, 5);\n    |      |                       ~~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (2) calling 'findMaxLists' from 'main'\n    |\n    +--> 'findMaxLists': events 3-14\n           |\n           |    5 | int** findMaxLists(int** arr, int rows) {\n           |      |       ^~~~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'findMaxLists'\n           |......\n           |    9 |     for (int i = 0; i < rows; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < rows')...\n           |   10 |         int length = 0;\n           |      |             ~~~~~~\n           |      |             |\n           |      |             (5) ...to here\n           |......\n           |   13 |         while (*list != -1) {\n           |      |                ~~~~~~~~~~~\n           |      |                      |\n           |      |                      (6) following 'true' branch...\n           |   14 |             length++;\n           |      |             ~~~~~~~~\n           |      |                   |\n           |      |                   (7) ...to here\n           |......\n           |   27 |     int** max_lists = (int**)malloc(num_lists * sizeof(int*));\n           |      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                              |\n           |      |                              (8) this call could return NULL\n           |......\n           |   30 |     for (int i = 0; i < rows; i++) {\n           |      |                     ~~~~~~~~  ~~~\n           |      |                       |        |\n           |      |                       |        (14) ...to here\n           |      |                       (9) following 'true' branch (when 'i < rows')...\n           |   31 |         int length = 0;\n           |      |             ~~~~~~\n           |      |             |\n           |      |             (10) ...to here\n           |......\n           |   34 |         while (*list != -1) {\n           |      |                ~~~~~~~~~~~\n           |      |                      |\n           |      |                      (11) following 'true' branch...\n           |   35 |             length++;\n           |      |             ~~~~~~~~\n           |      |                   |\n           |      |                   (12) ...to here\n           |......\n           |   39 |         if (length == max_length) {\n           |      |            ~\n           |      |            |\n           |      |            (13) following 'false' branch (when 'length != max_length')...\n           |\n    <------+\n    |\n  'main': events 15-18\n    |\n    |   57 |     int** max_lists = findMaxLists(input, 5);\n    |      |                       ^~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (15) possible return of NULL to 'main' from 'findMaxLists'\n    |......\n    |   60 |     for (int i = 0; i < sizeof(max_lists) / sizeof(max_lists[0]); i++) {\n    |      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (16) following 'true' branch (when 'i == 0')...\n    |   61 |         int* list = max_lists[i];\n    |      |              ~~~~            ~\n    |      |              |               |\n    |      |              |               (17) ...to here\n    |      |              (18) 'max_lists + (long unsigned int)i * 8' could be NULL: unchecked value from (8)\n    |\n
291§False§Checking collected_code/problem-291-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-291-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (1541 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
292§True§"collected_code/problem-292-0.c:14:18: error: Cannot determine that 'number1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number1);\n                 ^\ncollected_code/problem-292-0.c:17:18: error: Cannot determine that 'number2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-292-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.05 seconds (423 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 294.118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
293§True§"collected_code/problem-293-0.c:13:19: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &side1);\n                  ^\ncollected_code/problem-293-0.c:16:19: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &side2);\n                  ^\ncollected_code/problem-293-0.c:18:38: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n    double thirdSide = findThirdSide(side1, side2);\n                                     ^\ncollected_code/problem-293-0.c:18:45: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n    double thirdSide = findThirdSide(side1, side2);\n                                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-293-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.16 seconds (137 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 312.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
294§True§Checking collected_code/problem-294-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-294-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.54 seconds (48 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
295§True§"collected_code/problem-295-0.c:16:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-295-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.18 seconds (98 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
296§True§collected_code/problem-296-0.c:7:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j]) {\n                   ^\ncollected_code/problem-296-0.c:7:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j]) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-296-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3220 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
297§True§"collected_code/problem-297-0.c:5:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == -1) {\n               ^\ncollected_code/problem-297-0.c:8:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", arr[i]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-297-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (1721 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
298§True§"collected_code/problem-298-0.c:8:22: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list1[i] == list2[j]) {\n                     ^\ncollected_code/problem-298-0.c:8:34: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list1[i] == list2[j]) {\n                                 ^\ncollected_code/problem-298-0.c:14:32: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", list1[i]);\n                               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-298-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.02 seconds (1182 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
299§True§collected_code/problem-299-0.c:6:25: error: Cannot determine that 'arr[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int sum = arr[i][0] + arr[i][1];\n                        ^\ncollected_code/problem-299-0.c:6:37: error: Cannot determine that 'arr[i][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int sum = arr[i][0] + arr[i][1];\n                                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-299-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (4246 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
300§True§"collected_code/problem-300-0.c:37:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-300-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (7762 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 88.2353 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
301§True§Checking collected_code/problem-301-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-301-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-301-0.c:4:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-301-0.c:26:  [2] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused). Risk is low because the source is a constant string.\ncollected_code/problem-301-0.c:29:  [2] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused). Risk is low because the source is a constant string.\ncollected_code/problem-301-0.c:32:  [2] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused). Risk is low because the source is a constant string.\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 44 in approximately 0.01 seconds (3116 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   1 [1]   0 [2]   4 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   4 [2+]   4 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 147.059 [1+] 117.647 [2+] 117.647 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-301-0.c: In function 'main':\ncollected_code/problem-301-0.c:25:31: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   25 |     Node* dictionary = (Node*)malloc(sizeof(Node));\n      |                               ^~~~~~\ncollected_code/problem-301-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-301-0.c:25:31: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   25 |     Node* dictionary = (Node*)malloc(sizeof(Node));\n      |                               ^~~~~~\ncollected_code/problem-301-0.c:25:31: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-301-0.c:26:5: warning: implicit declaration of function 'strcpy' [-Wimplicit-function-declaration]\n   26 |     strcpy(dictionary->key, ""root"");\n      |     ^~~~~~\ncollected_code/problem-301-0.c:2:1: note: include '<string.h>' or provide a declaration of 'strcpy'\n    1 | #include <stdio.h>\n  +++ |+#include <string.h>\n    2 | \ncollected_code/problem-301-0.c:26:5: warning: incompatible implicit declaration of built-in function 'strcpy' [-Wbuiltin-declaration-mismatch]\n   26 |     strcpy(dictionary->key, ""root"");\n      |     ^~~~~~\ncollected_code/problem-301-0.c:26:5: note: include '<string.h>' or provide a declaration of 'strcpy'\n"
302§False§Checking collected_code/problem-302-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-302-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 9 in approximately 0.00 seconds (1870 lines/second)\nPhysical Source Lines of Code (SLOC) = 8\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
303§True§collected_code/problem-303-0.c:7:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr[i]>arr[j]){\n                  ^\ncollected_code/problem-303-0.c:7:26: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr[i]>arr[j]){\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-303-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.01 seconds (4530 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 57.1429 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
304§True§collected_code/problem-304-0.c:5:14: error: Cannot determine that 'arr[(index+mod)%n]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n   return arr[(index + mod) % n];\n             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-304-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (2405 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
305§True§"collected_code/problem-305-0.c:6:17: error: Cannot determine that 'words[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (words[i][0] == 'p') {\n                ^\ncollected_code/problem-305-0.c:7:27: error: Cannot determine that 'words[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      printf(""%s\n"", words[i]);\n                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-305-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2652 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
306§True§collected_code/problem-306-0.c:10:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        prefixSum = arr[i];\n                       ^\ncollected_code/problem-306-0.c:11:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        tempSum = arr[i];\n                     ^\ncollected_code/problem-306-0.c:14:20: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j] > arr[j - 1]) {\n                   ^\ncollected_code/problem-306-0.c:14:29: error: Cannot determine that 'arr[j-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j] > arr[j - 1]) {\n                            ^\ncollected_code/problem-306-0.c:15:31: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                tempSum += arr[j];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-306-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.43 seconds (88 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 32.2581 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
307§True§Checking collected_code/problem-307-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-307-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (3533 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
308§True§collected_code/problem-308-0.c:9:36: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            products[count] = list1[i] * list2[j];\n                                   ^\ncollected_code/problem-308-0.c:9:47: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            products[count] = list1[i] * list2[j];\n                                              ^\ncollected_code/problem-308-0.c:16:34: error: Cannot determine that 'products[0]' is initialized [premium-bughuntingUninit]\n        int maxProduct = products[0];\n                                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-308-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.33 seconds (119 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 31.25 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
309§True§Checking collected_code/problem-309-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-309-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.58 seconds (26 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
310§True§"collected_code/problem-310-0.c:12:27: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    tuple.length = strlen(str);\n                          ^\ncollected_code/problem-310-0.c:20:17: error: Cannot determine that 'string[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", string);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-310-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-310-0.c:20:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-310-0.c:17:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-310-0.c:12:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 28 in approximately 0.37 seconds (76 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   4 [1]   1 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   7 [1+]   3 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 318.182 [1+] 136.364 [2+] 90.9091 [3+] 45.4545 [4+] 45.4545 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
311§True§Checking collected_code/problem-311-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-311-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (3377 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 133.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
312§True§"collected_code/problem-312-0.c:11:21: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f"", &radius, &height);\n                    ^\ncollected_code/problem-312-0.c:11:30: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f"", &radius, &height);\n                             ^\ncollected_code/problem-312-0.c:13:35: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    float volume = volume_of_cone(radius, height);\n                                  ^\ncollected_code/problem-312-0.c:13:43: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    float volume = volume_of_cone(radius, height);\n                                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-312-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2250 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 230.769 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
313§True§"collected_code/problem-313-0.c:5:20: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (numbers[i] > 0) {\n                   ^\ncollected_code/problem-313-0.c:6:35: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d\n"", numbers[i]);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-313-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.29 seconds (58 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
314§True§"collected_code/problem-314-0.c:7:25: error: Cannot determine that 'grid[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int inclusive = grid[0];\n                        ^\ncollected_code/problem-314-0.c:13:50: error: Cannot determine that 'grid[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        inclusive = (inclusive > exclusive + grid[i]) ? inclusive : exclusive + grid[i];\n                                                 ^\ncollected_code/problem-314-0.c:22:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-314-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.01 seconds (4447 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 178.571 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
315§True§"collected_code/problem-315-0.c:6:25: error: Cannot determine that 'sentence[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char *word = strtok(sentence, "" "");\n                        ^\ncollected_code/problem-315-0.c:24:11: error: Cannot determine that 'sentence[0]' is initialized [premium-bughuntingUninit]\n    fgets(sentence, sizeof(sentence), stdin);\n          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-315-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-315-0.c:22:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-315-0.c:9:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 31 in approximately 0.54 seconds (57 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 173.913 [1+] 86.9565 [2+] 43.4783 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
316§True§collected_code/problem-316-0.c:10:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] == x) {\n               ^\ncollected_code/problem-316-0.c:14:21: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[mid] < x)\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-316-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.01 seconds (5757 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
317§True§"collected_code/problem-317-0.c:7:32: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (i < n - 1 && arr[i] == arr[i + 1]) {\n                               ^\ncollected_code/problem-317-0.c:7:42: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (i < n - 1 && arr[i] == arr[i + 1]) {\n                                         ^\ncollected_code/problem-317-0.c:11:36: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d %d "", count, arr[i]);\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-317-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (3460 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
318§True§"collected_code/problem-318-0.c:13:19: error: Cannot determine that 'sumOfSides' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &sumOfSides);\n                  ^\ncollected_code/problem-318-0.c:15:31: error: Cannot determine that 'sumOfSides' is initialized [premium-bughuntingUninit]\n    double maxVol = maxVolume(sumOfSides);\n                              ^\ncollected_code/problem-318-0.c:16:81: error: Cannot determine that 'sumOfSides' is initialized [premium-bughuntingUninit]\n    printf(""The maximum volume of a cuboid with sum of sides %.2lf is %.2lf\n"", sumOfSides, maxVol);\n                                                                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-318-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (3237 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
319§False§Checking collected_code/problem-319-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-319-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.01 seconds (3082 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 153.846 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-319-0.c: In function 'findFiveCharacterWords':\ncollected_code/problem-319-0.c:19:30: error: invalid operands to binary - (have 'regoff_t' {aka 'long long int'} and 'char *')\n   19 |       match += matches.rm_eo - match + 1;\n      |                ~~~~~~~~~~~~~ ^\n      |                       |\n      |                       regoff_t {aka long long int}\n
320§True§Checking collected_code/problem-320-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-320-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (4073 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
321§True§"collected_code/problem-321-0.c:16:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-321-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.53 seconds (36 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
322§True§collected_code/problem-322-0.c:4:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min = arr[0];\n                 ^\ncollected_code/problem-322-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < min) {\n               ^\ncollected_code/problem-322-0.c:7:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min = arr[i];\n                     ^\ncollected_code/problem-322-0.c:11:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == min) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-322-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2682 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
323§True§collected_code/problem-323-0.c:8:40: error: Cannot determine that 'arr[positiveIndex]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (positiveIndex < n && arr[positiveIndex] >= 0) {\n                                       ^\ncollected_code/problem-323-0.c:12:40: error: Cannot determine that 'arr[negativeIndex]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (negativeIndex < n && arr[negativeIndex] <= 0) {\n                                       ^\ncollected_code/problem-323-0.c:17:27: error: Cannot determine that 'arr[positiveIndex]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int temp = arr[positiveIndex];\n                          ^\ncollected_code/problem-323-0.c:18:37: error: Cannot determine that 'arr[negativeIndex]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            arr[positiveIndex] = arr[negativeIndex];\n                                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-323-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.01 seconds (5681 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
324§True§collected_code/problem-324-0.c:6:17: error: Cannot determine that 'a[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += a[i] + a[i + 2];\n                ^\ncollected_code/problem-324-0.c:6:24: error: Cannot determine that 'a[i+2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += a[i] + a[i + 2];\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-324-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2193 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
325§True§"collected_code/problem-325-0.c:32:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-325-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (5851 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
326§True§collected_code/problem-326-0.c:15:31: error: Cannot determine that 'strings[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strcmp(strings[i], strings[j]) == 0)\n                              ^\ncollected_code/problem-326-0.c:15:43: error: Cannot determine that 'strings[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strcmp(strings[i], strings[j]) == 0)\n                                          ^\ncollected_code/problem-326-0.c:21:39: error: Cannot determine that 'strings[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            mostFrequentWord = strings[i];\n                                      ^\ncollected_code/problem-326-0.c:25:12: error: Cannot determine that 'mostFrequentWord' is initialized [premium-bughuntingUninit]\n    return mostFrequentWord;\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-326-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.37 seconds (105 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 64.5161 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
327§True§"collected_code/problem-327-0.c:13:22: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n  scanf(""%d %d %d"", &side1, &side2, &side3);\n                     ^\ncollected_code/problem-327-0.c:13:30: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n  scanf(""%d %d %d"", &side1, &side2, &side3);\n                             ^\ncollected_code/problem-327-0.c:13:38: error: Cannot determine that 'side3' is initialized [premium-bughuntingUninit]\n  scanf(""%d %d %d"", &side1, &side2, &side3);\n                                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-327-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (2824 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
328§True§collected_code/problem-328-0.c:5:23: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[0];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-328-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (4086 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 160 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
329§False§collected_code/problem-329-0.c:4:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-329-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 8 in approximately 0.54 seconds (15 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
330§True§collected_code/problem-330-0.c:11:36: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while ((reti = regexec(&regex, str, 1, matches, 0)) != REG_NOMATCH) {\n                                   ^\ncollected_code/problem-330-0.c:13:33: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n            for (int i = matches[0].rm_so; i < matches[0].rm_eo; i++) {\n                                ^\ncollected_code/problem-330-0.c:17:27: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n            str += matches[0].rm_eo;\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-330-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (4468 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
331§True§"collected_code/problem-331-0.c:19:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-331-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.39 seconds (62 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
332§True§collected_code/problem-332-0.c:7:19: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for(i = 0; str[i] != '\0'; i++)\n                  ^\ncollected_code/problem-332-0.c:8:18: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[str[i]]++;\n                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-332-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.57 seconds (35 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
333§True§collected_code/problem-333-0.c:4:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-333-0.c:5:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-333-0.c:12:23: error: Cannot determine that 'arr[j][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j][1] > arr[j + 1][1]) {\n                      ^\ncollected_code/problem-333-0.c:12:39: error: Cannot determine that 'arr[j+1][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[j][1] > arr[j + 1][1]) {\n                                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-333-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.51 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
334§True§"collected_code/problem-334-0.c:18:24: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                       ^\ncollected_code/problem-334-0.c:18:32: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                               ^\ncollected_code/problem-334-0.c:18:40: error: Cannot determine that 'side3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-334-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3888 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 190.476 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
335§False§Checking collected_code/problem-335-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-335-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 7 in approximately 0.01 seconds (1167 lines/second)\nPhysical Source Lines of Code (SLOC) = 8\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
336§True§"collected_code/problem-336-0.c:6:16: error: Cannot determine that 'monthName[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (strcmp(monthName, ""February"") == 0 || strcmp(monthName, ""february"") == 0) {\n               ^\ncollected_code/problem-336-0.c:15:17: error: Cannot determine that 'month[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", month);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-336-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-336-0.c:15:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-336-0.c:13:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 22 in approximately 0.01 seconds (3302 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 238.095 [1+] 95.2381 [2+] 95.2381 [3+] 47.619 [4+] 47.619 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
337§False§collected_code/problem-337-0.c:6:25: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int lenStr = strlen(str);\n                        ^\ncollected_code/problem-337-0.c:7:26: error: Cannot determine that 'word[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int lenWord = strlen(word);\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-337-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-337-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-337-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 24 in approximately 0.54 seconds (44 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   0 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+] 100 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
338§True§collected_code/problem-338-0.c:6:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-338-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-338-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 25 in approximately 0.01 seconds (3988 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]  50 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
339§True§"collected_code/problem-339-0.c:28:18: error: Cannot determine that 'start' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &start);\n                 ^\ncollected_code/problem-339-0.c:30:18: error: Cannot determine that 'end' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &end);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-339-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.01 seconds (4720 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 178.571 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
340§True§collected_code/problem-340-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > 0) {\n               ^\ncollected_code/problem-340-0.c:9:49: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            positiveNumbers[positiveCount] = arr[i];\n                                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-340-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 45 in approximately 0.01 seconds (6987 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 27.7778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-340-0.c: In function 'findSumOfThreeLowestPositiveNumbers':\ncollected_code/problem-340-0.c:24:32: warning: use of uninitialized value '*positiveNumbers[j]' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   24 |             if (positiveNumbers[j] < min) {\n      |                 ~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   38 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   42 |     int sum = findSumOfThreeLowestPositiveNumbers(numbers, size);\n    |      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |               |\n    |      |               (2) calling 'findSumOfThreeLowestPositiveNumbers' from 'main'\n    |\n    +--> 'findSumOfThreeLowestPositiveNumbers': events 3-17\n           |\n           |    3 | int findSumOfThreeLowestPositiveNumbers(int arr[], int size) {\n           |      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (3) entry to 'findSumOfThreeLowestPositiveNumbers'\n           |    4 |     int positiveNumbers[size];\n           |      |         ~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (4) region created on stack here\n           |......\n           |    7 |     for (int i = 0; i < size; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (5) following 'true' branch (when 'i < size')...\n           |      |                       (9) following 'false' branch (when 'i >= size')...\n           |    8 |         if (arr[i] > 0) {\n           |      |            ~   ~\n           |      |            |   |\n           |      |            |   (6) ...to here\n           |      |            (7) following 'true' branch...\n           |    9 |             positiveNumbers[positiveCount] = arr[i];\n           |      |                                                 ~\n           |      |                                                 |\n           |      |                                                 (8) ...to here\n           |......\n           |   14 |     if (positiveCount < 3) {\n           |      |        ~\n           |      |        |\n           |      |        (10) ...to here\n           |      |        (11) following 'false' branch (when 'positiveCount > 2')...\n           |......\n           |   18 |     int sum = 0;\n           |      |         ~~~\n           |      |         |\n           |      |         (12) ...to here\n           |   19 |     for (int i = 0; i < 3; i++) {\n           |      |                     ~~~~~\n           |      |                       |\n           |      |                       (13) following 'true' branch (when 'i <= 2')...\n           |   20 |         int min = positiveNumbers[i];\n           |      |             ~~~\n           |      |             |\n           |      |             (14) ...to here\n           |......\n           |   23 |         for (int j = i + 1; j < positiveCount; j++) {\n           |      |                             ~~~~~~~~~~~~~~~~~\n           |      |                               |\n           |      |                               (15) following 'true' branch (when 'j < positiveCount')...\n           |   24 |             if (positiveNumbers[j] < min) {\n           |      |                 ~~~~~~~~~~~~~~~~~~\n           |      |                                |\n           |      |                                (16) ...to here\n           |      |                                (17) use of uninitialized value '*positiveNumbers[j]' here\n           |\n
341§True§Checking collected_code/problem-341-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-341-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (5716 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
342§True§collected_code/problem-342-0.c:21:34: error: Cannot determine that 'numCols[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (ptr[i] >= numCols[i]) {\n                                 ^\ncollected_code/problem-342-0.c:25:23: error: Cannot determine that 'arr[i][ptr[i]]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i][ptr[i]] < min) {\n                      ^\ncollected_code/problem-342-0.c:27:29: error: Cannot determine that 'arr[i][ptr[i]]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                min = arr[i][ptr[i]];\n                            ^\ncollected_code/problem-342-0.c:30:23: error: Cannot determine that 'arr[i][ptr[i]]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i][ptr[i]] > max) {\n                      ^\ncollected_code/problem-342-0.c:31:29: error: Cannot determine that 'arr[i][ptr[i]]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                max = arr[i][ptr[i]];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-342-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 57 in approximately 0.01 seconds (7709 lines/second)\nPhysical Source Lines of Code (SLOC) = 42\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-342-0.c: In function 'findSmallestRange':\ncollected_code/problem-342-0.c:41:12: warning: stack-based buffer under-read [CWE-127] [-Wanalyzer-out-of-bounds]\n   41 |         ptr[minIndex]++;\n      |         ~~~^~~~~~~~~~\n  'findSmallestRange': events 1-5\n    |\n    |   20 |         for (i = 0; i < numRows; i++) {\n    |      |                     ~~^~~~~~~~~\n    |      |                       |\n    |      |                       (1) following 'false' branch (when 'i >= numRows')...\n    |......\n    |   35 |         range = max - min;\n    |      |         ~~~~~~~~~~~~~~~~~\n    |      |               |\n    |      |               (2) ...to here\n    |   36 | \n    |   37 |         if (range < minRange) {\n    |      |            ~           \n    |      |            |\n    |      |            (3) following 'true' branch (when 'range < minRange')...\n    |   38 |             minRange = range;\n    |      |             ~~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (4) ...to here\n    |......\n    |   41 |         ptr[minIndex]++;\n    |      |         ~~~~~~~~~~~~~  \n    |      |            |\n    |      |            (5) out-of-bounds read from byte -4 till byte -1 but region starts at byte 0\n    |\ncollected_code/problem-342-0.c:41:22: warning: stack-based buffer underwrite [CWE-124] [-Wanalyzer-out-of-bounds]\n   41 |         ptr[minIndex]++;\n      |         ~~~~~~~~~~~~~^~\n  'findSmallestRange': events 1-5\n    |\n    |   20 |         for (i = 0; i < numRows; i++) {\n    |      |                     ~~^~~~~~~~~\n    |      |                       |\n    |      |                       (1) following 'false' branch (when 'i >= numRows')...\n    |......\n    |   35 |         range = max - min;\n    |      |         ~~~~~~~~~~~~~~~~~\n    |      |               |\n    |      |               (2) ...to here\n    |   36 | \n    |   37 |         if (range < minRange) {\n    |      |            ~           \n    |      |            |\n    |      |            (3) following 'true' branch (when 'range < minRange')...\n    |   38 |             minRange = range;\n    |      |             ~~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (4) ...to here\n    |......\n    |   41 |         ptr[minIndex]++;\n    |      |         ~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (5) out-of-bounds write from byte -4 till byte -1 but region starts at byte 0\n    |\n
343§True§"collected_code/problem-343-0.c:21:37: error: Cannot determine that 'numOfDigits' is initialized [premium-bughuntingUninit]\n    calculateDigitsAndLetters(str, &numOfDigits, &numOfLetters);\n                                    ^\ncollected_code/problem-343-0.c:21:51: error: Cannot determine that 'numOfLetters' is initialized [premium-bughuntingUninit]\n    calculateDigitsAndLetters(str, &numOfDigits, &numOfLetters);\n                                                  ^\ncollected_code/problem-343-0.c:23:38: error: Cannot determine that 'numOfDigits' is initialized [premium-bughuntingUninit]\n    printf(""Number of digits: %d\n"", numOfDigits);\n                                     ^\ncollected_code/problem-343-0.c:24:39: error: Cannot determine that 'numOfLetters' is initialized [premium-bughuntingUninit]\n    printf(""Number of letters: %d\n"", numOfLetters);\n                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-343-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.01 seconds (4398 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
344§True§"collected_code/problem-344-0.c:31:20: error: Cannot determine that 'start' is initialized [premium-bughuntingUninit]\n   scanf(""%d %d"", &start, &end);\n                   ^\ncollected_code/problem-344-0.c:31:28: error: Cannot determine that 'end' is initialized [premium-bughuntingUninit]\n   scanf(""%d %d"", &start, &end);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-344-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.40 seconds (83 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 96.7742 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
345§True§"collected_code/problem-345-0.c:5:30: error: Cannot determine that 'list[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int difference = list[i + 1] - list[i];\n                             ^\ncollected_code/problem-345-0.c:5:44: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int difference = list[i + 1] - list[i];\n                                           ^\ncollected_code/problem-345-0.c:6:60: error: Cannot determine that 'list[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""Difference between %d and %d is %d\n"", list[i + 1], list[i], difference);\n                                                           ^\ncollected_code/problem-345-0.c:6:73: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""Difference between %d and %d is %d\n"", list[i + 1], list[i], difference);\n                                                                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-345-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.02 seconds (938 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
346§True§"collected_code/problem-346-0.c:26:21: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &n, &k);\n                    ^\ncollected_code/problem-346-0.c:26:25: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &n, &k);\n                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-346-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.52 seconds (55 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
347§True§"collected_code/problem-347-0.c:12:18: error: Cannot determine that 'rows' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &rows);\n                 ^\ncollected_code/problem-347-0.c:14:18: error: Cannot determine that 'columns' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &columns);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-347-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.29 seconds (58 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 312.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
348§True§collected_code/problem-348-0.c:11:32: error: Cannot determine that 'values[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            prefixSum += values[j];\n                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-348-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.39 seconds (95 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.037 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
349§True§Checking collected_code/problem-349-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-349-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (5083 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
350§True§collected_code/problem-350-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-350-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-350-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 39 in approximately 0.01 seconds (7263 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 60.6061 [1+] 30.303 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
351§True§collected_code/problem-351-0.c:7:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                   ^\ncollected_code/problem-351-0.c:7:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                             ^\ncollected_code/problem-351-0.c:11:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            return arr[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-351-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (3236 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
352§False§collected_code/problem-352-0.c:6:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-352-0.c:7:26: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (charCount[str[i]] > 0) {\n                         ^\ncollected_code/problem-352-0.c:10:22: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        charCount[str[i]]++;\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-352-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.01 seconds (2330 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
353§True§Checking collected_code/problem-353-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-353-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.67 seconds (54 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
354§True§Checking collected_code/problem-354-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-354-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.01 seconds (2251 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
355§True§"collected_code/problem-355-0.c:22:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &radius);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-355-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (3998 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
356§True§"collected_code/problem-356-0.c:12:18: error: Cannot determine that 'angle1' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &angle1);\n                 ^\ncollected_code/problem-356-0.c:15:18: error: Cannot determine that 'angle2' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &angle2);\n                 ^\ncollected_code/problem-356-0.c:17:29: error: Cannot determine that 'angle1' is initialized [premium-bughuntingUninit]\n    angle3 = findThirdAngle(angle1, angle2);\n                            ^\ncollected_code/problem-356-0.c:17:37: error: Cannot determine that 'angle2' is initialized [premium-bughuntingUninit]\n    angle3 = findThirdAngle(angle1, angle2);\n                                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-356-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (1520 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
357§True§collected_code/problem-357-0.c:4:27: error: Cannot determine that 'tupleRecords[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max = tupleRecords[0];\n                          ^\ncollected_code/problem-357-0.c:6:25: error: Cannot determine that 'tupleRecords[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tupleRecords[i] > max) {\n                        ^\ncollected_code/problem-357-0.c:7:31: error: Cannot determine that 'tupleRecords[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = tupleRecords[i];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-357-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.77 seconds (23 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
358§True§"collected_code/problem-358-0.c:5:28: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", list1[i] % list2[i]);\n                           ^\ncollected_code/problem-358-0.c:5:39: error: Cannot determine that 'list2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", list1[i] % list2[i]);\n                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-358-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.27 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
359§True§"collected_code/problem-359-0.c:23:16: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n  scanf(""%d"", &a);\n               ^\ncollected_code/problem-359-0.c:25:16: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n  scanf(""%d"", &b);\n               ^\ncollected_code/problem-359-0.c:27:16: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n  scanf(""%d"", &c);\n               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-359-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (4984 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   9 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   9 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 290.323 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-359-0.c: In function 'checkRoots':\ncollected_code/problem-359-0.c:8:26: warning: implicit declaration of function 'sqrt' [-Wimplicit-function-declaration]\n    8 |     double root1 = (-b + sqrt(discriminant)) / (2 * a);\n      |                          ^~~~\ncollected_code/problem-359-0.c:2:1: note: include '<math.h>' or provide a declaration of 'sqrt'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-359-0.c:8:26: warning: incompatible implicit declaration of built-in function 'sqrt' [-Wbuiltin-declaration-mismatch]\n    8 |     double root1 = (-b + sqrt(discriminant)) / (2 * a);\n      |                          ^~~~\ncollected_code/problem-359-0.c:8:26: note: include '<math.h>' or provide a declaration of 'sqrt'\n
360§True§"collected_code/problem-360-0.c:14:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-360-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2296 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
361§True§Checking collected_code/problem-361-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-361-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 48 in approximately 0.01 seconds (7769 lines/second)\nPhysical Source Lines of Code (SLOC) = 41\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 24.3902 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-361-0.c: In function 'main':\ncollected_code/problem-361-0.c:35:17: warning: dereference of possibly-NULL 'list1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   35 |     list1->data = -1;\n      |     ~~~~~~~~~~~~^~~~\n  'main': events 1-2\n    |\n    |   32 |     Node* list1 = (Node*)malloc(sizeof(Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |......\n    |   35 |     list1->data = -1;\n    |      |     ~~~~~~~~~~~~~~~~      \n    |      |                 |\n    |      |                 (2) 'list1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-361-0.c:37:17: warning: dereference of possibly-NULL 'list2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   37 |     list2->data = 2;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   33 |     Node* list2 = (Node*)malloc(sizeof(Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |......\n    |   37 |     list2->data = 2;\n    |      |     ~~~~~~~~~~~~~~~       \n    |      |                 |\n    |      |                 (2) 'list2' could be NULL: unchecked value from (1)\n    |\n
362§True§collected_code/problem-362-0.c:10:14: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if(list[j] == list[i])\n             ^\ncollected_code/problem-362-0.c:10:25: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if(list[j] == list[i])\n                        ^\ncollected_code/problem-362-0.c:16:22: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      maxValue = list[i];\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-362-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (5624 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
363§True§collected_code/problem-363-0.c:5:14: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        tuple[i] += k;\n             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-363-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.33 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
364§True§collected_code/problem-364-0.c:7:24: error: Cannot determine that 'binary_string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while(binary_string[i] != '\0') {\n                       ^\ncollected_code/problem-364-0.c:8:25: error: Cannot determine that 'binary_string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(binary_string[i] == binary_string[i+1]) {\n                        ^\ncollected_code/problem-364-0.c:8:45: error: Cannot determine that 'binary_string[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(binary_string[i] == binary_string[i+1]) {\n                                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-364-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (4478 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
365§True§Checking collected_code/problem-365-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-365-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.50 seconds (32 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
366§True§collected_code/problem-366-0.c:4:26: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int largestProd = arr[0] * arr[1];\n                         ^\ncollected_code/problem-366-0.c:4:35: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int largestProd = arr[0] * arr[1];\n                                  ^\ncollected_code/problem-366-0.c:7:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int product = arr[i] * arr[i + 1];\n                         ^\ncollected_code/problem-366-0.c:7:35: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int product = arr[i] * arr[i + 1];\n                                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-366-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (4358 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
367§True§Checking collected_code/problem-367-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-367-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 56 in approximately 0.01 seconds (9690 lines/second)\nPhysical Source Lines of Code (SLOC) = 47\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 42.5532 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-367-0.c: In function 'newNode':\ncollected_code/problem-367-0.c:14:16: warning: dereference of possibly-NULL 'node' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   14 |     node->data = data;\n      |     ~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   43 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   44 |     struct Node* root = newNode(1);\n    |      |                         ~~~~~~~~~~\n    |      |                         |\n    |      |                         (2) calling 'newNode' from 'main'\n    |\n    +--> 'newNode': events 3-5\n           |\n           |   12 | struct Node* newNode(int data) {\n           |      |              ^~~~~~~\n           |      |              |\n           |      |              (3) entry to 'newNode'\n           |   13 |     struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n           |      |                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                       |\n           |      |                                       (4) this call could return NULL\n           |   14 |     node->data = data;\n           |      |     ~~~~~~~~~~~~~~~~~\n           |      |                |\n           |      |                (5) 'node' could be NULL: unchecked value from (4)\n           |\n
368§False§Checking collected_code/problem-368-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-368-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.47 seconds (41 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-368-0.c: In function 'repeatTuple':\ncollected_code/problem-368-0.c:14:21: warning: dereference of possibly-NULL 'result' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   14 |         result[i].a = tup->a;\n      |         ~~~~~~~~~~~~^~~~~~~~\n  'repeatTuple': events 1-4\n    |\n    |   11 |     Tuple* result = (Tuple*)malloc(n * sizeof(Tuple));\n    |      |                             ^~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                             |\n    |      |                             (1) this call could return NULL\n    |   12 | \n    |   13 |     for (int i = 0; i < n; i++) {\n    |      |                     ~~~~~    \n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < n')...\n    |   14 |         result[i].a = tup->a;\n    |      |         ~~~~~~~~~~~~~~~~~~~~ \n    |      |               |     |\n    |      |               |     (4) 'result + (long unsigned int)i * 12' could be NULL: unchecked value from (1)\n    |      |               (3) ...to here\n    |\nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
369§True§"collected_code/problem-369-0.c:11:24: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &length, &breadth, &height);\n                       ^\ncollected_code/problem-369-0.c:11:33: error: Cannot determine that 'breadth' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &length, &breadth, &height);\n                                ^\ncollected_code/problem-369-0.c:11:43: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &length, &breadth, &height);\n                                          ^\ncollected_code/problem-369-0.c:12:39: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    float area = lateral_surface_area(length, breadth, height);\n                                      ^\ncollected_code/problem-369-0.c:12:47: error: Cannot determine that 'breadth' is initialized [premium-bughuntingUninit]\n    float area = lateral_surface_area(length, breadth, height);\n                                              ^\ncollected_code/problem-369-0.c:12:56: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    float area = lateral_surface_area(length, breadth, height);\n                                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-369-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (2785 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 230.769 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
370§False§Checking collected_code/problem-370-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-370-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 11 in approximately 0.01 seconds (2018 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
371§False§collected_code/problem-371-0.c:5:12: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[low] != 0) {\n           ^\ncollected_code/problem-371-0.c:12:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] - arr[low] > 1) {\n               ^\ncollected_code/problem-371-0.c:12:27: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] - arr[low] > 1) {\n                          ^\ncollected_code/problem-371-0.c:19:15: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    return arr[low] - 1;\n              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-371-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.50 seconds (38 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
372§True§"collected_code/problem-372-0.c:11:24: error: Cannot determine that 'arr[left]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] > arr[largest])\n                       ^\ncollected_code/problem-372-0.c:11:36: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] > arr[largest])\n                                   ^\ncollected_code/problem-372-0.c:15:25: error: Cannot determine that 'arr[right]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] > arr[largest])\n                        ^\ncollected_code/problem-372-0.c:15:38: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] > arr[largest])\n                                     ^\ncollected_code/problem-372-0.c:21:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[i];\n                      ^\ncollected_code/problem-372-0.c:22:21: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i] = arr[largest];\n                    ^\ncollected_code/problem-372-0.c:39:23: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[0];\n                      ^\ncollected_code/problem-372-0.c:40:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[0] = arr[i];\n                    ^\ncollected_code/problem-372-0.c:51:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr[i]);\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-372-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 68 in approximately 0.52 seconds (130 lines/second)\nPhysical Source Lines of Code (SLOC) = 42\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
373§True§"collected_code/problem-373-0.c:12:18: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &length);\n                 ^\ncollected_code/problem-373-0.c:15:18: error: Cannot determine that 'width' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &width);\n                 ^\ncollected_code/problem-373-0.c:18:18: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &height);\n                 ^\ncollected_code/problem-373-0.c:20:25: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    volume = findVolume(length, width, height);\n                        ^\ncollected_code/problem-373-0.c:20:33: error: Cannot determine that 'width' is initialized [premium-bughuntingUninit]\n    volume = findVolume(length, width, height);\n                                ^\ncollected_code/problem-373-0.c:20:40: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    volume = findVolume(length, width, height);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-373-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3128 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 411.765 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
374§True§"collected_code/problem-374-0.c:6:12: error: Cannot determine that '*x' is initialized [premium-bughuntingUninit]\n    temp = *x;\n           ^\ncollected_code/problem-374-0.c:7:10: error: Cannot determine that '*y' is initialized [premium-bughuntingUninit]\n    *x = *y;\n         ^\ncollected_code/problem-374-0.c:14:24: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%s\n"", str);\n                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-374-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-374-0.c:26:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 28 in approximately 0.01 seconds (3700 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+] 38.4615 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
375§True§Checking collected_code/problem-375-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-375-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.37 seconds (54 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
376§True§Checking collected_code/problem-376-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-376-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.01 seconds (3372 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
377§True§"collected_code/problem-377-0.c:7:20: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; str[i]; i++) {\n                   ^\ncollected_code/problem-377-0.c:8:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] != c) {\n               ^\ncollected_code/problem-377-0.c:9:31: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[count++] = str[i];\n                              ^\ncollected_code/problem-377-0.c:20:17: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str);\n                ^\ncollected_code/problem-377-0.c:23:19: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf("" %c"", &c);\n                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-377-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-377-0.c:20:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-377-0.c:16:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 29 in approximately 0.01 seconds (4998 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   4 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   6 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 272.727 [1+] 90.9091 [2+] 90.9091 [3+] 45.4545 [4+] 45.4545 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
378§True§collected_code/problem-378-0.c:4:20: error: Cannot determine that 'list[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int last = list[size-1];\n                   ^\ncollected_code/problem-378-0.c:7:23: error: Cannot determine that 'list[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        list[i] = list[i-1];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-378-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.56 seconds (43 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
379§True§"collected_code/problem-379-0.c:11:24: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &length, &width, &height);\n                       ^\ncollected_code/problem-379-0.c:11:33: error: Cannot determine that 'width' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &length, &width, &height);\n                                ^\ncollected_code/problem-379-0.c:11:41: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &length, &width, &height);\n                                        ^\ncollected_code/problem-379-0.c:13:34: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    float area = findSurfaceArea(length, width, height);\n                                 ^\ncollected_code/problem-379-0.c:13:42: error: Cannot determine that 'width' is initialized [premium-bughuntingUninit]\n    float area = findSurfaceArea(length, width, height);\n                                         ^\ncollected_code/problem-379-0.c:13:49: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    float area = findSurfaceArea(length, width, height);\n                                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-379-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2843 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 230.769 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
380§True§"collected_code/problem-380-0.c:21:35: error: Cannot determine that 'array[i][j]' is initialized [premium-bughuntingUninit]\n            printf(""%d "", array[i][j]);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-380-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.01 seconds (3429 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
381§True§Checking collected_code/problem-381-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-381-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.61 seconds (56 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 103.448 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
382§True§collected_code/problem-382-0.c:7:16: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[low] <= arr[high]) {\n               ^\ncollected_code/problem-382-0.c:7:28: error: Cannot determine that 'arr[high]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[low] <= arr[high]) {\n                           ^\ncollected_code/problem-382-0.c:15:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] <= arr[prev] && arr[mid] <= arr[next]) {\n               ^\ncollected_code/problem-382-0.c:15:28: error: Cannot determine that 'arr[prev]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] <= arr[prev] && arr[mid] <= arr[next]) {\n                           ^\ncollected_code/problem-382-0.c:15:53: error: Cannot determine that 'arr[next]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] <= arr[prev] && arr[mid] <= arr[next]) {\n                                                    ^\ncollected_code/problem-382-0.c:19:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] <= arr[high]) {\n               ^\ncollected_code/problem-382-0.c:19:28: error: Cannot determine that 'arr[high]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] <= arr[high]) {\n                           ^\ncollected_code/problem-382-0.c:21:23: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (arr[mid] >= arr[low]) {\n                      ^\ncollected_code/problem-382-0.c:21:35: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (arr[mid] >= arr[low]) {\n                                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-382-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.01 seconds (7052 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 35.7143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
383§True§"collected_code/problem-383-0.c:11:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%u"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-383-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (2433 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
384§True§collected_code/problem-384-0.c:4:28: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int smallestValue = arr[0];\n                           ^\ncollected_code/problem-384-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < smallestValue) {\n               ^\ncollected_code/problem-384-0.c:9:32: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            smallestValue = arr[i];\n                               ^\ncollected_code/problem-384-0.c:14:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == smallestValue) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-384-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.57 seconds (53 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
385§True§"collected_code/problem-385-0.c:21:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-385-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2985 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
386§True§collected_code/problem-386-0.c:9:18: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  char temp = str[i];\n                 ^\ncollected_code/problem-386-0.c:10:15: error: Cannot determine that 'str[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  str[i] = str[j];\n              ^\ncollected_code/problem-386-0.c:15:18: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  int n = strlen(str);\n                 ^\ncollected_code/problem-386-0.c:36:9: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n  fgets(str, MAX, stdin);\n        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-386-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-386-0.c:34:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-386-0.c:15:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 41 in approximately 0.42 seconds (99 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   2 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 117.647 [1+] 58.8235 [2+] 29.4118 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
387§True§"collected_code/problem-387-0.c:7:12: error: Cannot determine that 'hex[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))\n           ^\ncollected_code/problem-387-0.c:7:30: error: Cannot determine that 'hex[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))\n                             ^\ncollected_code/problem-387-0.c:11:15: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (hex[i] != '\0') {\n              ^\ncollected_code/problem-387-0.c:13:19: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (!((hex[i] >= '0' && hex[i] <= '9') || (hex[i] >= 'A' && hex[i] <= 'F') || (hex[i] >= 'a' && hex[i] <= 'f')))\n                  ^\ncollected_code/problem-387-0.c:22:15: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (hex[i] != '\0') {\n              ^\ncollected_code/problem-387-0.c:23:16: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (hex[i] >= '0' && hex[i] <= '9')\n               ^\ncollected_code/problem-387-0.c:24:42: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            decimal = decimal * 16 + (hex[i] - '0');\n                                         ^\ncollected_code/problem-387-0.c:25:21: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (hex[i] >= 'A' && hex[i] <= 'F')\n                    ^\ncollected_code/problem-387-0.c:26:42: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            decimal = decimal * 16 + (hex[i] - 'A' + 10);\n                                         ^\ncollected_code/problem-387-0.c:27:21: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (hex[i] >= 'a' && hex[i] <= 'f')\n                    ^\ncollected_code/problem-387-0.c:28:42: error: Cannot determine that 'hex[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            decimal = decimal * 16 + (hex[i] - 'a' + 10);\n                                         ^\ncollected_code/problem-387-0.c:43:17: error: Cannot determine that 'hex[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", hex);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-387-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-387-0.c:43:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-387-0.c:41:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 50 in approximately 0.02 seconds (2362 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 138.889 [1+] 55.5556 [2+] 55.5556 [3+] 27.7778 [4+] 27.7778 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
388§False§Checking collected_code/problem-388-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-388-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 7 in approximately 0.01 seconds (1168 lines/second)\nPhysical Source Lines of Code (SLOC) = 8\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
389§True§"collected_code/problem-389-0.c:17:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-389-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (4121 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
390§True§Checking collected_code/problem-390-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-390-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.01 seconds (5248 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 60.6061 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-390-0.c: In function 'createNode':\ncollected_code/problem-390-0.c:12:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   12 |     newNode->data = data;\n      |     ~~~~~~~~~~~~~~^~~~~~\n  'createNode': events 1-2\n    |\n    |   11 |     Node* newNode = (Node*)malloc(sizeof(Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |   12 |     newNode->data = data;\n    |      |     ~~~~~~~~~~~~~~~~~~~~    \n    |      |                   |\n    |      |                   (2) 'newNode' could be NULL: unchecked value from (1)\n    |\n
391§True§Checking collected_code/problem-391-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-391-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 78 in approximately 0.01 seconds (10468 lines/second)\nPhysical Source Lines of Code (SLOC) = 65\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 30.7692 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-391-0.c: In function 'createDict':\ncollected_code/problem-391-0.c:16:28: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   16 |     Dict* newDict = (Dict*)malloc(sizeof(Dict));\n      |                            ^~~~~~\ncollected_code/problem-391-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-391-0.c:16:28: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   16 |     Dict* newDict = (Dict*)malloc(sizeof(Dict));\n      |                            ^~~~~~\ncollected_code/problem-391-0.c:16:28: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-391-0.c: In function 'main':\ncollected_code/problem-391-0.c:56:26: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   56 |     Node* list1 = (Node*)malloc(sizeof(Node));\n      |                          ^~~~~~\ncollected_code/problem-391-0.c:56:26: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-391-0.c: In function 'createDict':\ncollected_code/problem-391-0.c:17:18: warning: dereference of possibly-NULL 'newDict' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   17 |     newDict->key = key;\n      |     ~~~~~~~~~~~~~^~~~~\n  'main': events 1-2\n    |\n    |   55 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   73 |     insertDict(&root, list1);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'insertDict' from 'main'\n    |\n    +--> 'insertDict': events 3-8\n           |\n           |   23 | void insertDict(Dict** root, Node* list) {\n           |      |      ^~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'insertDict'\n           |   24 |     if (!list) { // base case\n           |      |        ~\n           |      |        |\n           |      |        (4) following 'false' branch (when 'list' is non-NULL)...\n           |......\n           |   28 |     if (!(*root)) { // if root is empty, create a new dictionary\n           |      |        ~ ~~~~~~~\n           |      |        |  |\n           |      |        |  (5) ...to here\n           |      |        (6) following 'true' branch...\n           |   29 |         (*root) = createDict(list->key);\n           |      |                   ~~~~~~~~~~~~~~~~~~~~~\n           |      |                   |\n           |      |                   (7) ...to here\n           |      |                   (8) calling 'createDict' from 'insertDict'\n           |\n           +--> 'createDict': events 9-11\n                  |\n                  |   15 | Dict* createDict(int key) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (9) entry to 'createDict'\n                  |   16 |     Dict* newDict = (Dict*)malloc(sizeof(Dict));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (10) this call could return NULL\n                  |   17 |     newDict->key = key;\n                  |      |     ~~~~~~~~~~~~~~~~~~\n                  |      |                  |\n                  |      |                  (11) 'newDict' could be NULL: unchecked value from (10)\n                  |\ncollected_code/problem-391-0.c: In function 'main':\ncollected_code/problem-391-0.c:57:16: warning: dereference of possibly-NULL 'list1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   57 |     list1->key = 1;\n      |     ~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   56 |     Node* list1 = (Node*)malloc(sizeof(Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |   57 |     list1->key = 1;\n    |      |     ~~~~~~~~~~~~~~        \n    |      |                |\n    |      |                (2) 'list1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-391-0.c:60:22: warning: dereference of possibly-NULL '*list1.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   60 |     list1->next->key = 2;\n      |     ~~~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   59 |     list1->next = (Node*)malloc(sizeof(Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |   60 |     list1->next->key = 2;\n    |      |     ~~~~~~~~~~~~~~~~~~~~  \n    |      |                      |\n    |      |                      (2) '*list1.next' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-391-0.c:65:16: warning: dereference of possibly-NULL 'list2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   65 |     list2->key = 1;\n      |     ~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   64 |     Node* list2 = (Node*)malloc(sizeof(Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |   65 |     list2->key = 1;\n    |      |     ~~~~~~~~~~~~~~        \n    |      |                |\n    |      |                (2) 'list2' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-391-0.c:68:22: warning: dereference of possibly-NULL '*list2.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   68 |     list2->next->key = 3;\n      |     ~~~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   67 |     list2->next = (Node*)malloc(sizeof(Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |   68 |     list2->next->key = 3;\n    |      |     ~~~~~~~~~~~~~~~~~~~~  \n    |      |                      |\n    |      |                      (2) '*list2.next' could be NULL: unchecked value from (1)\n    |\n
392§True§"collected_code/problem-392-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-392-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (1708 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
393§True§collected_code/problem-393-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] != 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-393-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (4820 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
394§True§collected_code/problem-394-0.c:6:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                   ^\ncollected_code/problem-394-0.c:6:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-394-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.02 seconds (1164 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
395§True§collected_code/problem-395-0.c:7:20: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; str[i] != '\0'; i++) {\n                   ^\ncollected_code/problem-395-0.c:8:18: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[str[i]]++;\n                 ^\ncollected_code/problem-395-0.c:11:20: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; str[i] != '\0'; i++) {\n                   ^\ncollected_code/problem-395-0.c:12:22: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (count[str[i]] == 1) {\n                     ^\ncollected_code/problem-395-0.c:13:23: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            return str[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-395-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-395-0.c:4:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 26 in approximately 0.01 seconds (3797 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]  50 [2+]  50 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
396§False§Checking collected_code/problem-396-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-396-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.01 seconds (1692 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-396-0.c: In function 'startsAndEndsWithSameChar':\ncollected_code/problem-396-0.c:8:42: error: 'NULL' undeclared (first use in this function)\n    8 |     int result = regexec(&regex, str, 0, NULL, 0);\n      |                                          ^~~~\ncollected_code/problem-396-0.c:3:1: note: 'NULL' is defined in header '<stddef.h>'; did you forget to '#include <stddef.h>'?\n    2 | #include <stdbool.h>\n  +++ |+#include <stddef.h>\n    3 | \ncollected_code/problem-396-0.c:8:42: note: each undeclared identifier is reported only once for each function it appears in\n    8 |     int result = regexec(&regex, str, 0, NULL, 0);\n      |                                          ^~~~\n
397§True§"collected_code/problem-397-0.c:19:23: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n   scanf(""%f %f %f"", &num1, &num2, &num3);\n                      ^\ncollected_code/problem-397-0.c:19:30: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n   scanf(""%f %f %f"", &num1, &num2, &num3);\n                             ^\ncollected_code/problem-397-0.c:19:37: error: Cannot determine that 'num3' is initialized [premium-bughuntingUninit]\n   scanf(""%f %f %f"", &num1, &num2, &num3);\n                                    ^\ncollected_code/problem-397-0.c:21:24: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n   median = findMedian(num1, num2, num3);\n                       ^\ncollected_code/problem-397-0.c:21:30: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n   median = findMedian(num1, num2, num3);\n                             ^\ncollected_code/problem-397-0.c:21:36: error: Cannot determine that 'num3' is initialized [premium-bughuntingUninit]\n   median = findMedian(num1, num2, num3);\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-397-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (4425 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
398§True§"collected_code/problem-398-0.c:14:35: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int sum = sumOfDigits(list[i]);\n                                  ^\ncollected_code/problem-398-0.c:15:56: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""Sum of digits in number %d: %d\n"", list[i], sum);\n                                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-398-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.40 seconds (58 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
399§True§collected_code/problem-399-0.c:7:27: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] ^ tuple2[i];\n                          ^\ncollected_code/problem-399-0.c:7:39: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] ^ tuple2[i];\n                                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-399-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.58 seconds (40 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
400§True§Checking collected_code/problem-400-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-400-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (5341 lines/second)\nPhysical Source Lines of Code (SLOC) = 38\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 26.3158 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
401§True§collected_code/problem-401-0.c:6:38: error: Cannot determine that 'tuple2[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            tuple1[i][j] += tuple2[i][j];\n                                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-401-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3659 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
402§True§"collected_code/problem-402-0.c:19:24: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &n, &r, &p);\n                       ^\ncollected_code/problem-402-0.c:19:28: error: Cannot determine that 'r' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &n, &r, &p);\n                           ^\ncollected_code/problem-402-0.c:19:32: error: Cannot determine that 'p' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &n, &r, &p);\n                               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-402-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3161 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
403§True§"collected_code/problem-403-0.c:14:27: error: Cannot determine that 'url[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    ret = regexec(&regex, url, 0, NULL, 0);\n                          ^\ncollected_code/problem-403-0.c:23:31: error: Cannot determine that 'error_message[0]' is initialized [premium-bughuntingUninit]\n        regerror(ret, &regex, error_message, sizeof(error_message));\n                              ^\ncollected_code/problem-403-0.c:33:17: error: Cannot determine that 'url[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", url);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-403-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-403-0.c:33:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-403-0.c:22:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-403-0.c:31:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 41 in approximately 0.01 seconds (6130 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   5 [1]   0 [2]   2 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   8 [1+]   3 [2+]   3 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+] 83.3333 [2+] 83.3333 [3+] 27.7778 [4+] 27.7778 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
404§True§"collected_code/problem-404-0.c:13:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-404-0.c:15:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-404-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.47 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 294.118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
405§True§collected_code/problem-405-0.c:5:16: error: Cannot determine that 'tup[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tup[i] == element) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-405-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.43 seconds (48 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
406§True§"collected_code/problem-406-0.c:17:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-406-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2396 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
407§False§"collected_code/problem-407-0.c:7:17: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    char temp = *a;\n                ^\ncollected_code/problem-407-0.c:8:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-407-0.c:17:19: error: Cannot determine that 'digits[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (digits[i - 1] < digits[i])\n                  ^\ncollected_code/problem-407-0.c:17:35: error: Cannot determine that 'digits[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (digits[i - 1] < digits[i])\n                                  ^\ncollected_code/problem-407-0.c:28:19: error: Cannot determine that 'digits[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int x = digits[i - 1];\n                  ^\ncollected_code/problem-407-0.c:33:19: error: Cannot determine that 'digits[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (digits[j] > x && digits[j] < digits[smallest_index])\n                  ^\ncollected_code/problem-407-0.c:33:48: error: Cannot determine that 'digits[smallest_index]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (digits[j] > x && digits[j] < digits[smallest_index])\n                                               ^\ncollected_code/problem-407-0.c:44:28: error: Cannot determine that 'digits[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int next_bigger = atoi(digits);\n                           ^\ncollected_code/problem-407-0.c:50:13: error: Cannot determine that '*(char*)a' is initialized [premium-bughuntingUninit]\n    return (*(char *) a - *(char *) b);\n            ^\ncollected_code/problem-407-0.c:50:27: error: Cannot determine that '*(char*)b' is initialized [premium-bughuntingUninit]\n    return (*(char *) a - *(char *) b);\n                          ^\ncollected_code/problem-407-0.c:56:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\ncollected_code/problem-407-0.c:60:13: error: Cannot determine that 'digits[0]' is initialized [premium-bughuntingUninit]\n    sprintf(digits, ""%d"", number);\n            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-407-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-407-0.c:44:  [2] (integer) atoi:\n  Unless checked, the resulting number can exceed the expected range\n  (CWE-190). If source untrusted, check both minimum and maximum, even if the\n  input had no minus sign (large numbers can roll over into negative number;\n  consider saving to an unsigned value if that is intended).\ncollected_code/problem-407-0.c:59:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-407-0.c:60:  [2] (buffer) sprintf:\n  Does not check for buffer overflows (CWE-120). Use sprintf_s, snprintf, or\n  vsnprintf. Risk is low because the source has a constant maximum length.\ncollected_code/problem-407-0.c:62:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 73 in approximately 0.87 seconds (84 lines/second)\nPhysical Source Lines of Code (SLOC) = 47\nHits@level = [0]   4 [1]   1 [2]   3 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   8 [1+]   4 [2+]   3 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 170.213 [1+] 85.1064 [2+] 63.8298 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-407-0.c: In function 'findNextBigger':\ncollected_code/problem-407-0.c:41:49: error: 'compare' undeclared (first use in this function)\n   41 |     qsort(&digits[i], n - i, sizeof(digits[0]), compare);\n      |                                                 ^~~~~~~\ncollected_code/problem-407-0.c:41:49: note: each undeclared identifier is reported only once for each function it appears in\n
408§True§"collected_code/problem-408-0.c:8:38: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""(%d, %d)\n"", arr1[i], arr2[j]);\n                                     ^\ncollected_code/problem-408-0.c:8:47: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""(%d, %d)\n"", arr1[i], arr2[j]);\n                                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-408-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.42 seconds (58 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
409§True§collected_code/problem-409-0.c:4:25: error: Cannot determine that 'array[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min_prod = array[0] * array[1];\n                        ^\ncollected_code/problem-409-0.c:4:36: error: Cannot determine that 'array[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min_prod = array[0] * array[1];\n                                   ^\ncollected_code/problem-409-0.c:8:32: error: Cannot determine that 'array[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int product = array[i] * array[j];\n                               ^\ncollected_code/problem-409-0.c:8:43: error: Cannot determine that 'array[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int product = array[i] * array[j];\n                                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-409-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.33 seconds (70 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
410§True§collected_code/problem-410-0.c:8:21: error: Cannot determine that 'list[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    void* min = list[0];\n                    ^\ncollected_code/problem-410-0.c:11:13: error: Cannot determine that '*(int*)list[i]' is initialized [premium-bughuntingUninit]\n        if (*(int*)list[i] < *(int*)min) {\n            ^\ncollected_code/problem-410-0.c:11:24: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (*(int*)list[i] < *(int*)min) {\n                       ^\ncollected_code/problem-410-0.c:11:30: error: Cannot determine that '*(int*)min' is initialized [premium-bughuntingUninit]\n        if (*(int*)list[i] < *(int*)min) {\n                             ^\ncollected_code/problem-410-0.c:12:23: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min = list[i];\n                      ^\ncollected_code/problem-410-0.c:16:12: error: Cannot determine that 'min' is initialized [premium-bughuntingUninit]\n    return min;\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-410-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.67 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
411§True§collected_code/problem-411-0.c:14:70: error: Cannot determine that 'snakeCase[match.rm_so+1+currentIndex]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        camelCase[match.rm_so + currentIndex + 1] = toupper(snakeCase[match.rm_so + 1 + currentIndex]);\n                                                                     ^\ncollected_code/problem-411-0.c:26:12: error: Cannot determine that 'camelCase[0]' is initialized [premium-bughuntingUninit]\n    strcpy(camelCase, snakeCase);\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-411-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-411-0.c:26:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-411-0.c:24:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-411-0.c:15:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 31 in approximately 0.41 seconds (76 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   1 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   4 [1+]   3 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+] 125 [2+] 83.3333 [3+] 41.6667 [4+] 41.6667 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
412§True§"collected_code/problem-412-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % 2 == 0) {\n               ^\ncollected_code/problem-412-0.c:9:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            temp[j] = arr[i];\n                         ^\ncollected_code/problem-412-0.c:16:27: error: Cannot determine that 'temp[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", temp[i]);\n                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-412-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.51 seconds (53 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
413§True§Checking collected_code/problem-413-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-413-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.38 seconds (69 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
414§False§collected_code/problem-414-0.c:5:21: error: Cannot determine that 'sequence[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (sequence[i] == value) {\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-414-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 9 in approximately 0.01 seconds (1460 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
415§True§collected_code/problem-415-0.c:9:19: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max1 = arr[0], max2 = arr[1];\n                  ^\ncollected_code/problem-415-0.c:9:34: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max1 = arr[0], max2 = arr[1];\n                                 ^\ncollected_code/problem-415-0.c:10:19: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min1 = arr[0], min2 = arr[1];\n                  ^\ncollected_code/problem-415-0.c:10:34: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min1 = arr[0], min2 = arr[1];\n                                 ^\ncollected_code/problem-415-0.c:13:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > max1) {\n               ^\ncollected_code/problem-415-0.c:15:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max1 = arr[i];\n                      ^\ncollected_code/problem-415-0.c:17:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[i] > max2) {\n                    ^\ncollected_code/problem-415-0.c:18:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max2 = arr[i];\n                      ^\ncollected_code/problem-415-0.c:21:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < min1) {\n               ^\ncollected_code/problem-415-0.c:23:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min1 = arr[i];\n                      ^\ncollected_code/problem-415-0.c:25:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[i] < min2) {\n                    ^\ncollected_code/problem-415-0.c:26:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min2 = arr[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-415-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 45 in approximately 0.49 seconds (92 lines/second)\nPhysical Source Lines of Code (SLOC) = 39\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
416§True§"collected_code/problem-416-0.c:29:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-416-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.01 seconds (4842 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
417§True§collected_code/problem-417-0.c:4:24: error: Cannot determine that 'arr[0][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int common = arr[0][0];\n                       ^\ncollected_code/problem-417-0.c:11:23: error: Cannot determine that 'arr[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i][0] == arr[j][0]) {\n                      ^\ncollected_code/problem-417-0.c:11:36: error: Cannot determine that 'arr[j][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i][0] == arr[j][0]) {\n                                   ^\ncollected_code/problem-417-0.c:17:28: error: Cannot determine that 'arr[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            common = arr[i][0];\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-417-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.43 seconds (76 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
418§True§Checking collected_code/problem-418-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-418-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 89 in approximately 0.43 seconds (205 lines/second)\nPhysical Source Lines of Code (SLOC) = 70\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 28.5714 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-418-0.c: In function 'main':\ncollected_code/problem-418-0.c:59:26: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   59 |     head = (struct Node*)malloc(sizeof(struct Node));\n      |                          ^~~~~~\ncollected_code/problem-418-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-418-0.c:59:26: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   59 |     head = (struct Node*)malloc(sizeof(struct Node));\n      |                          ^~~~~~\ncollected_code/problem-418-0.c:59:26: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-418-0.c:64:16: warning: dereference of possibly-NULL 'head' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   64 |     head->data = 1;\n      |     ~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   59 |     head = (struct Node*)malloc(sizeof(struct Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |......\n    |   64 |     head->data = 1;\n    |      |     ~~~~~~~~~~~~~~        \n    |      |                |\n    |      |                (2) 'head' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-418-0.c:67:18: warning: dereference of possibly-NULL 'second' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   67 |     second->data = 2;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   60 |     second = (struct Node*)malloc(sizeof(struct Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |......\n    |   67 |     second->data = 2;\n    |      |     ~~~~~~~~~~~~~~~~        \n    |      |                  |\n    |      |                  (2) 'second' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-418-0.c:70:17: warning: dereference of possibly-NULL 'third' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   70 |     third->data = 2;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   61 |     third = (struct Node*)malloc(sizeof(struct Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |......\n    |   70 |     third->data = 2;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'third' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-418-0.c:73:18: warning: dereference of possibly-NULL 'fourth' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   73 |     fourth->data = 3;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   62 |     fourth = (struct Node*)malloc(sizeof(struct Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |......\n    |   73 |     fourth->data = 3;\n    |      |     ~~~~~~~~~~~~~~~~        \n    |      |                  |\n    |      |                  (2) 'fourth' could be NULL: unchecked value from (1)\n    |\n
419§True§collected_code/problem-419-0.c:8:26: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += round(list[i]);\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-419-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.32 seconds (65 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
420§True§"collected_code/problem-420-0.c:16:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-420-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3393 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
421§True§collected_code/problem-421-0.c:10:29: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        strcat(result, tuple[i]);\n                            ^\ncollected_code/problem-421-0.c:12:28: error: Cannot determine that 'delimiter[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            strcat(result, delimiter);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-421-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-421-0.c:10:  [4] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused).\ncollected_code/problem-421-0.c:12:  [4] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused).\ncollected_code/problem-421-0.c:7:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 26 in approximately 0.64 seconds (40 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   1 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   4 [1+]   3 [2+]   3 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+] 150 [2+] 150 [3+] 100 [4+] 100 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
422§True§"collected_code/problem-422-0.c:14:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-422-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2964 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
423§True§collected_code/problem-423-0.c:17:38: error: Cannot determine that 'mines[row][col]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            dp[row][col] = mines[row][col] + max(right, max(right_up, right_down));\n                                     ^\ncollected_code/problem-423-0.c:21:24: error: Cannot determine that 'dp[0][0]' is initialized [premium-bughuntingUninit]\n    int maxGold = dp[0][0];\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-423-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.43 seconds (98 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 28.5714 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
424§False§collected_code/problem-424-0.c:6:34: error: Cannot determine that 'array[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int length = strlen(array[i]);\n                                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-424-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-424-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 10 in approximately 0.33 seconds (30 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+] 100 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
425§True§collected_code/problem-425-0.c:9:19: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (arr[j] == element && j < size) {\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-425-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.37 seconds (86 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
426§True§"collected_code/problem-426-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % 2 != 0) {\n               ^\ncollected_code/problem-426-0.c:8:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", arr[i]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-426-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (1815 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 133.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
427§True§"collected_code/problem-427-0.c:19:60: error: Array 'match[3]' accessed at index 3, which is out of bounds. [arrayIndexOutOfBounds]\n        snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n                                                           ^\ncollected_code/problem-427-0.c:17:27: error: Cannot determine that 'date[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    ret = regexec(&regex, date, 3, match, 0);\n                          ^\ncollected_code/problem-427-0.c:19:18: error: Cannot determine that 'convertedDate[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n                 ^\ncollected_code/problem-427-0.c:19:60: error: Cannot determine that 'match[3]' is initialized [premium-bughuntingUninit]\n        snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n                                                           ^\ncollected_code/problem-427-0.c:20:58: error: Cannot determine that 'match[2]' is initialized [premium-bughuntingUninit]\n                                                    match[2].rm_eo - match[2].rm_so, date + match[2].rm_so,\n                                                         ^\ncollected_code/problem-427-0.c:21:58: error: Cannot determine that 'match[1]' is initialized [premium-bughuntingUninit]\n                                                    match[1].rm_eo - match[1].rm_so, date + match[1].rm_so);\n                                                         ^\ncollected_code/problem-427-0.c:28:31: error: Cannot determine that 'convertedDate[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        regerror(ret, &regex, convertedDate, sizeof(convertedDate));\n                              ^\ncollected_code/problem-427-0.c:42:40: error: Cannot determine that 'convertedDate[0]' is initialized [premium-bughuntingUninit]\n        printf(""Converted date: %s\n"", convertedDate);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-427-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-427-0.c:39:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 44 in approximately 0.53 seconds (83 lines/second)\nPhysical Source Lines of Code (SLOC) = 39\nHits@level = [0]   5 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 153.846 [1+] 25.641 [2+] 25.641 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"In file included from /usr/local/Cellar/gcc/13.1.0/lib/gcc/current/gcc/x86_64-apple-darwin22/13/include-fixed/stdio.h:440,\n                 from collected_code/problem-427-0.c:1:\ncollected_code/problem-427-0.c: In function 'convertDate':\ncollected_code/problem-427-0.c:19:63: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n      |                                                       ~~~~~~~~^~~~~~\n  'convertDate': events 1-4\n    |\n    |    7 |     regmatch_t match[3];\n    |      |                ^~~~~\n    |      |                |\n    |      |                (1) capacity: 48 bytes\n    |......\n    |   12 |     if (ret) {\n    |      |        ~        \n    |      |        |\n    |      |        (2) following 'false' branch (when 'ret == 0')...\n    |......\n    |   17 |     ret = regexec(&regex, date, 3, match, 0);\n    |      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |           |\n    |      |           (3) ...to here\n    |   18 |     if (!ret) {\n    |      |        ~        \n    |      |        |\n    |      |        (4) following 'true' branch (when 'ret == 0')...\n    |\n  'convertDate': event 5\n    |\n    |   21 |                                                     match[1].rm_eo - match[1].rm_so, date + match[1].rm_so);\n    |      |                                                                                             ~~~~~~~~^~~~~~\n    |      |                                                                                                     |\n    |      |                                                                                                     (5) ...to here\n    |\n  'convertDate': event 6\n    |\n    |   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n    |      |                                                       ~~~~~~~~^~~~~~\n    |      |                                                               |\n    |      |                                                               (6) out-of-bounds read from byte 56 till byte 63 but 'match' ends at byte 48\n    |\ncollected_code/problem-427-0.c:19:63: note: read of 8 bytes from after the end of 'match'\ncollected_code/problem-427-0.c:19:63: note: valid subscripts for 'match' are '[0]' to '[2]'\ncollected_code/problem-427-0.c:19:63: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n  'main': events 1-2\n    |\n    |   37 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   41 |     if (convertDate(date, convertedDate) == 0) {\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (2) calling 'convertDate' from 'main'\n    |\n    +--> 'convertDate': events 3-7\n           |\n           |    5 | int convertDate(char* date, char* convertedDate) {\n           |      |     ^~~~~~~~~~~\n           |      |     |\n           |      |     (3) entry to 'convertDate'\n           |    6 |     regex_t regex;\n           |    7 |     regmatch_t match[3];\n           |      |                ~~~~~\n           |      |                |\n           |      |                (4) capacity: 48 bytes\n           |......\n           |   12 |     if (ret) {\n           |      |        ~\n           |      |        |\n           |      |        (5) following 'false' branch (when 'ret == 0')...\n           |......\n           |   17 |     ret = regexec(&regex, date, 3, match, 0);\n           |      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |           |\n           |      |           (6) ...to here\n           |   18 |     if (!ret) {\n           |      |        ~\n           |      |        |\n           |      |        (7) following 'true' branch (when 'ret == 0')...\n           |\n         'convertDate': event 8\n           |\n           |   21 |                                                     match[1].rm_eo - match[1].rm_so, date + match[1].rm_so);\n           |      |                                                                                             ~~~~~~~~^~~~~~\n           |      |                                                                                                     |\n           |      |                                                                                                     (8) ...to here\n           |\n         'convertDate': event 9\n           |\n           |   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n           |      |                                                       ~~~~~~~~^~~~~~\n           |      |                                                               |\n           |      |                                                               (9) out-of-bounds read from byte 56 till byte 63 but 'match' ends at byte 48\n           |\ncollected_code/problem-427-0.c:19:63: note: read of 8 bytes from after the end of 'match'\ncollected_code/problem-427-0.c:19:63: note: valid subscripts for 'match' are '[0]' to '[2]'\ncollected_code/problem-427-0.c:19:80: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n      |                                                                        ~~~~~~~~^~~~~~\n  'convertDate': events 1-4\n    |\n    |    7 |     regmatch_t match[3];\n    |      |                ^~~~~\n    |      |                |\n    |      |                (1) capacity: 48 bytes\n    |......\n    |   12 |     if (ret) {\n    |      |        ~        \n    |      |        |\n    |      |        (2) following 'false' branch (when 'ret == 0')...\n    |......\n    |   17 |     ret = regexec(&regex, date, 3, match, 0);\n    |      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |           |\n    |      |           (3) ...to here\n    |   18 |     if (!ret) {\n    |      |        ~        \n    |      |        |\n    |      |        (4) following 'true' branch (when 'ret == 0')...\n    |\n  'convertDate': event 5\n    |\n    |   21 |                                                     match[1].rm_eo - match[1].rm_so, date + match[1].rm_so);\n    |      |                                                                                             ~~~~~~~~^~~~~~\n    |      |                                                                                                     |\n    |      |                                                                                                     (5) ...to here\n    |\n  'convertDate': event 6\n    |\n    |   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n    |      |                                                                        ~~~~~~~~^~~~~~\n    |      |                                                                                |\n    |      |                                                                                (6) out-of-bounds read from byte 48 till byte 55 but 'match' ends at byte 48\n    |\ncollected_code/problem-427-0.c:19:80: note: read of 8 bytes from after the end of 'match'\ncollected_code/problem-427-0.c:19:80: note: valid subscripts for 'match' are '[0]' to '[2]'\ncollected_code/problem-427-0.c:19:80: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n  'main': events 1-2\n    |\n    |   37 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   41 |     if (convertDate(date, convertedDate) == 0) {\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (2) calling 'convertDate' from 'main'\n    |\n    +--> 'convertDate': events 3-7\n           |\n           |    5 | int convertDate(char* date, char* convertedDate) {\n           |      |     ^~~~~~~~~~~\n           |      |     |\n           |      |     (3) entry to 'convertDate'\n           |    6 |     regex_t regex;\n           |    7 |     regmatch_t match[3];\n           |      |                ~~~~~\n           |      |                |\n           |      |                (4) capacity: 48 bytes\n           |......\n           |   12 |     if (ret) {\n           |      |        ~\n           |      |        |\n           |      |        (5) following 'false' branch (when 'ret == 0')...\n           |......\n           |   17 |     ret = regexec(&regex, date, 3, match, 0);\n           |      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |           |\n           |      |           (6) ...to here\n           |   18 |     if (!ret) {\n           |      |        ~\n           |      |        |\n           |      |        (7) following 'true' branch (when 'ret == 0')...\n           |\n         'convertDate': event 8\n           |\n           |   21 |                                                     match[1].rm_eo - match[1].rm_so, date + match[1].rm_so);\n           |      |                                                                                             ~~~~~~~~^~~~~~\n           |      |                                                                                                     |\n           |      |                                                                                                     (8) ...to here\n           |\n         'convertDate': event 9\n           |\n           |   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n           |      |                                                                        ~~~~~~~~^~~~~~\n           |      |                                                                                |\n           |      |                                                                                (9) out-of-bounds read from byte 48 till byte 55 but 'match' ends at byte 48\n           |\ncollected_code/problem-427-0.c:19:80: note: read of 8 bytes from after the end of 'match'\ncollected_code/problem-427-0.c:19:80: note: valid subscripts for 'match' are '[0]' to '[2]'\ncollected_code/problem-427-0.c:19:103: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n      |                                                                                               ~~~~~~~~^~~~~~\n  'convertDate': events 1-4\n    |\n    |    7 |     regmatch_t match[3];\n    |      |                ^~~~~\n    |      |                |\n    |      |                (1) capacity: 48 bytes\n    |......\n    |   12 |     if (ret) {\n    |      |        ~        \n    |      |        |\n    |      |        (2) following 'false' branch (when 'ret == 0')...\n    |......\n    |   17 |     ret = regexec(&regex, date, 3, match, 0);\n    |      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |           |\n    |      |           (3) ...to here\n    |   18 |     if (!ret) {\n    |      |        ~        \n    |      |        |\n    |      |        (4) following 'true' branch (when 'ret == 0')...\n    |\n  'convertDate': event 5\n    |\n    |   21 |                                                     match[1].rm_eo - match[1].rm_so, date + match[1].rm_so);\n    |      |                                                                                             ~~~~~~~~^~~~~~\n    |      |                                                                                                     |\n    |      |                                                                                                     (5) ...to here\n    |\n  'convertDate': event 6\n    |\n    |   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n    |      |                                                                                               ~~~~~~~~^~~~~~\n    |      |                                                                                                       |\n    |      |                                                                                                       (6) out-of-bounds read from byte 48 till byte 55 but 'match' ends at byte 48\n    |\ncollected_code/problem-427-0.c:19:103: note: read of 8 bytes from after the end of 'match'\ncollected_code/problem-427-0.c:19:103: note: valid subscripts for 'match' are '[0]' to '[2]'\ncollected_code/problem-427-0.c:19:103: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n  'main': events 1-2\n    |\n    |   37 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   41 |     if (convertDate(date, convertedDate) == 0) {\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (2) calling 'convertDate' from 'main'\n    |\n    +--> 'convertDate': events 3-7\n           |\n           |    5 | int convertDate(char* date, char* convertedDate) {\n           |      |     ^~~~~~~~~~~\n           |      |     |\n           |      |     (3) entry to 'convertDate'\n           |    6 |     regex_t regex;\n           |    7 |     regmatch_t match[3];\n           |      |                ~~~~~\n           |      |                |\n           |      |                (4) capacity: 48 bytes\n           |......\n           |   12 |     if (ret) {\n           |      |        ~\n           |      |        |\n           |      |        (5) following 'false' branch (when 'ret == 0')...\n           |......\n           |   17 |     ret = regexec(&regex, date, 3, match, 0);\n           |      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |           |\n           |      |           (6) ...to here\n           |   18 |     if (!ret) {\n           |      |        ~\n           |      |        |\n           |      |        (7) following 'true' branch (when 'ret == 0')...\n           |\n         'convertDate': event 8\n           |\n           |   21 |                                                     match[1].rm_eo - match[1].rm_so, date + match[1].rm_so);\n           |      |                                                                                             ~~~~~~~~^~~~~~\n           |      |                                                                                                     |\n           |      |                                                                                                     (8) ...to here\n           |\n         'convertDate': event 9\n           |\n           |   19 |         snprintf(convertedDate, 11, ""%.*s-%.*s-%.*s"", match[3].rm_eo - match[3].rm_so, date + match[3].rm_so,\n           |      |                                                                                               ~~~~~~~~^~~~~~\n           |      |                                                                                                       |\n           |      |                                                                                                       (9) out-of-bounds read from byte 48 till byte 55 but 'match' ends at byte 48\n           |\ncollected_code/problem-427-0.c:19:103: note: read of 8 bytes from after the end of 'match'\ncollected_code/problem-427-0.c:19:103: note: valid subscripts for 'match' are '[0]' to '[2]'\n"
428§True§Checking collected_code/problem-428-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-428-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.02 seconds (1515 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
429§True§"collected_code/problem-429-0.c:5:27: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] & tuple2[i];\n                          ^\ncollected_code/problem-429-0.c:5:39: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] & tuple2[i];\n                                      ^\ncollected_code/problem-429-0.c:20:29: error: Cannot determine that 'result[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", result[i]);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-429-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3373 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
430§True§"collected_code/problem-430-0.c:15:27: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%lf %lf %lf"", &a, &b, &c);\n                          ^\ncollected_code/problem-430-0.c:15:31: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%lf %lf %lf"", &a, &b, &c);\n                              ^\ncollected_code/problem-430-0.c:15:35: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf(""%lf %lf %lf"", &a, &b, &c);\n                                  ^\ncollected_code/problem-430-0.c:16:19: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    findDirectrix(a, b, c);\n                  ^\ncollected_code/problem-430-0.c:16:22: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    findDirectrix(a, b, c);\n                     ^\ncollected_code/problem-430-0.c:16:25: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    findDirectrix(a, b, c);\n                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-430-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.28 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
431§True§collected_code/problem-431-0.c:7:22: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list1[i] == list2[j]) {\n                     ^\ncollected_code/problem-431-0.c:7:34: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list1[i] == list2[j]) {\n                                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-431-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (4113 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
432§True§"collected_code/problem-432-0.c:13:20: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%f%f"", &a, &b);\n                   ^\ncollected_code/problem-432-0.c:13:24: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%f%f"", &a, &b);\n                       ^\ncollected_code/problem-432-0.c:15:18: error: Cannot determine that 'h' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &h);\n                 ^\ncollected_code/problem-432-0.c:17:37: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    float median = trapezium_median(a, b, h);\n                                    ^\ncollected_code/problem-432-0.c:17:40: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    float median = trapezium_median(a, b, h);\n                                       ^\ncollected_code/problem-432-0.c:17:43: error: Cannot determine that 'h' is initialized [premium-bughuntingUninit]\n    float median = trapezium_median(a, b, h);\n                                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-432-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (1790 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 312.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
433§True§"collected_code/problem-433-0.c:6:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if (number <= arr[i]) { // If number is less than or equal to any element in the array\n                       ^\ncollected_code/problem-433-0.c:16:17: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n   scanf(""%d"", &number);\n                ^\ncollected_code/problem-433-0.c:18:17: error: Cannot determine that 'arrSize' is initialized [premium-bughuntingUninit]\n   scanf(""%d"", &arrSize);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-433-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.32 seconds (89 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   8 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   8 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 285.714 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
434§False§Checking collected_code/problem-434-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-434-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3664 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-434-0.c: In function 'matchString':\ncollected_code/problem-434-0.c:4:19: error: 'NULL' undeclared (first use in this function)\n    4 |     if (string == NULL) {\n      |                   ^~~~\ncollected_code/problem-434-0.c:2:1: note: 'NULL' is defined in header '<stddef.h>'; did you forget to '#include <stddef.h>'?\n    1 | #include <stdbool.h>\n  +++ |+#include <stddef.h>\n    2 | \ncollected_code/problem-434-0.c:4:19: note: each undeclared identifier is reported only once for each function it appears in\n    4 |     if (string == NULL) {\n      |                   ^~~~\n
435§True§Checking collected_code/problem-435-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-435-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.01 seconds (1881 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
436§False§"collected_code/problem-436-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < 0)\n               ^\ncollected_code/problem-436-0.c:9:31: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d\n"", arr[i]);\n                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-436-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 11 in approximately 0.01 seconds (1578 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
437§True§collected_code/problem-437-0.c:16:9: warning: Uninitialized variable: j [uninitvar]\n    str[j] = '\0';\n        ^\ncollected_code/problem-437-0.c:7:24: note: Assuming condition is false\n    for (i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-437-0.c:16:9: note: Uninitialized variable: j\n    str[j] = '\0';\n        ^\ncollected_code/problem-437-0.c:11:17: error: Uninitialized variable: j [legacyUninitvar]\n            str[j++] = str[i];\n                ^\ncollected_code/problem-437-0.c:7:20: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; str[i] != '\0'; i++) {\n                   ^\ncollected_code/problem-437-0.c:11:18: error: Cannot determine that 'j++' is initialized [premium-bughuntingUninit]\n            str[j++] = str[i];\n                 ^\ncollected_code/problem-437-0.c:11:27: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[j++] = str[i];\n                          ^\ncollected_code/problem-437-0.c:24:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str), stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-437-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-437-0.c:20:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 32 in approximately 0.01 seconds (4613 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+] 55.5556 [2+] 55.5556 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-437-0.c: In function 'removeOddCharacters':\ncollected_code/problem-437-0.c:11:18: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   11 |             str[j++] = str[i];\n      |                 ~^~\n  'removeOddCharacters': events 1-7\n    |\n    |    4 |     int i, j;\n    |      |            ^\n    |      |            |\n    |      |            (1) region created on stack here\n    |      |            (2) capacity: 4 bytes\n    |......\n    |    7 |     for (i = 0; str[i] != '\0'; i++) {\n    |      |                 ~~~~~~~~~~~~~~\n    |      |                        |\n    |      |                        (3) following 'true' branch...\n    |    8 |         // Check if character at current index is odd\n    |    9 |         if (i % 2 == 0) {\n    |      |            ~~~~~~~~~~~\n    |      |            |      |\n    |      |            |      (4) ...to here\n    |      |            (5) following 'true' branch...\n    |   10 |             // If odd, copy it to the next even index\n    |   11 |             str[j++] = str[i];\n    |      |                 ~~~       ~\n    |      |                  |        |\n    |      |                  |        (6) ...to here\n    |      |                  (7) use of uninitialized value 'j' here\n    |\ncollected_code/problem-437-0.c:11:18: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   11 |             str[j++] = str[i];\n      |                 ~^~\n  'main': events 1-2\n    |\n    |   19 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   27 |     removeOddCharacters(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeOddCharacters' from 'main'\n    |\n    +--> 'removeOddCharacters': events 3-10\n           |\n           |    3 | void removeOddCharacters(char *str) {\n           |      |      ^~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeOddCharacters'\n           |    4 |     int i, j;\n           |      |            ~\n           |      |            |\n           |      |            (4) region created on stack here\n           |      |            (5) capacity: 4 bytes\n           |......\n           |    7 |     for (i = 0; str[i] != '\0'; i++) {\n           |      |                 ~~~~~~~~~~~~~~\n           |      |                        |\n           |      |                        (6) following 'true' branch...\n           |    8 |         // Check if character at current index is odd\n           |    9 |         if (i % 2 == 0) {\n           |      |            ~~~~~~~~~~~\n           |      |            |      |\n           |      |            |      (7) ...to here\n           |      |            (8) following 'true' branch...\n           |   10 |             // If odd, copy it to the next even index\n           |   11 |             str[j++] = str[i];\n           |      |                 ~~~       ~\n           |      |                  |        |\n           |      |                  |        (9) ...to here\n           |      |                  (10) use of uninitialized value 'j' here\n           |\ncollected_code/problem-437-0.c:16:8: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   16 |     str[j] = '\0';\n      |        ^\n  'removeOddCharacters': events 1-5\n    |\n    |    4 |     int i, j;\n    |      |            ^\n    |      |            |\n    |      |            (1) region created on stack here\n    |      |            (2) capacity: 4 bytes\n    |......\n    |    7 |     for (i = 0; str[i] != '\0'; i++) {\n    |      |                 ~~~~~~~~~~~~~~\n    |      |                        |\n    |      |                        (3) following 'false' branch...\n    |......\n    |   16 |     str[j] = '\0';\n    |      |        ~    \n    |      |        |\n    |      |        (4) ...to here\n    |      |        (5) use of uninitialized value 'j' here\n    |\ncollected_code/problem-437-0.c:16:8: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   16 |     str[j] = '\0';\n      |        ^\n  'main': events 1-2\n    |\n    |   19 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   27 |     removeOddCharacters(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeOddCharacters' from 'main'\n    |\n    +--> 'removeOddCharacters': events 3-8\n           |\n           |    3 | void removeOddCharacters(char *str) {\n           |      |      ^~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeOddCharacters'\n           |    4 |     int i, j;\n           |      |            ~\n           |      |            |\n           |      |            (4) region created on stack here\n           |      |            (5) capacity: 4 bytes\n           |......\n           |    7 |     for (i = 0; str[i] != '\0'; i++) {\n           |      |                 ~~~~~~~~~~~~~~\n           |      |                        |\n           |      |                        (6) following 'false' branch...\n           |......\n           |   16 |     str[j] = '\0';\n           |      |        ~\n           |      |        |\n           |      |        (7) ...to here\n           |      |        (8) use of uninitialized value 'j' here\n           |\n
438§True§collected_code/problem-438-0.c:7:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr[i] == arr[j] && arr[j + 1] == arr[i + 1]) {\n                  ^\ncollected_code/problem-438-0.c:7:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr[i] == arr[j] && arr[j + 1] == arr[i + 1]) {\n                            ^\ncollected_code/problem-438-0.c:7:39: error: Cannot determine that 'arr[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr[i] == arr[j] && arr[j + 1] == arr[i + 1]) {\n                                      ^\ncollected_code/problem-438-0.c:7:53: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr[i] == arr[j] && arr[j + 1] == arr[i + 1]) {\n                                                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-438-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (3143 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
439§True§collected_code/problem-439-0.c:6:36: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result = result * 10 + list[i];\n                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-439-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.46 seconds (41 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
440§True§collected_code/problem-440-0.c:6:26: error: Cannot determine that 'sentence[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char *token = strtok(sentence, delim);\n                         ^\ncollected_code/problem-440-0.c:22:11: error: Cannot determine that 'sentence[0]' is initialized [premium-bughuntingUninit]\n    fgets(sentence, sizeof(sentence), stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-440-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-440-0.c:19:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-440-0.c:25:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-440-0.c:26:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 31 in approximately 0.01 seconds (2732 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   2 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   3 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 208.333 [1+] 125 [2+] 41.6667 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
441§True§"collected_code/problem-441-0.c:10:19: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &side);\n                  ^\ncollected_code/problem-441-0.c:11:44: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    double surfaceArea = surfaceAreaOfCube(side);\n                                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-441-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (1878 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
442§True§collected_code/problem-442-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-442-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.44 seconds (50 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
443§True§collected_code/problem-443-0.c:7:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(arr[i] < 0 && arr[i] < largest) {\n              ^\ncollected_code/problem-443-0.c:8:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            largest = arr[i];\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-443-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2075 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
444§True§Checking collected_code/problem-444-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-444-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.38 seconds (74 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
445§True§collected_code/problem-445-0.c:8:27: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] * tuple2[i];\n                          ^\ncollected_code/problem-445-0.c:8:39: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] * tuple2[i];\n                                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-445-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.59 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
446§True§"collected_code/problem-446-0.c:14:21: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[j] == tuple[i]) {\n                    ^\ncollected_code/problem-446-0.c:14:33: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[j] == tuple[i]) {\n                                ^\ncollected_code/problem-446-0.c:21:55: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""Element %d occurs %d time(s)\n"", tuple[i], count);\n                                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-446-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.55 seconds (62 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
447§True§"collected_code/problem-447-0.c:5:23: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        list[i] = list[i] * list[i] * list[i];\n                      ^\ncollected_code/problem-447-0.c:12:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\ncollected_code/problem-447-0.c:24:28: error: Cannot determine that 'list[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d\n"", list[i]);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-447-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.38 seconds (71 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 272.727 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
448§True§"collected_code/problem-448-0.c:26:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-448-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.59 seconds (51 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
449§True§"collected_code/problem-449-0.c:20:21: error: Cannot determine that 'x1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &x1, &y1);\n                    ^\ncollected_code/problem-449-0.c:20:26: error: Cannot determine that 'y1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &x1, &y1);\n                         ^\ncollected_code/problem-449-0.c:23:21: error: Cannot determine that 'x2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &x2, &y2);\n                    ^\ncollected_code/problem-449-0.c:23:26: error: Cannot determine that 'y2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &x2, &y2);\n                         ^\ncollected_code/problem-449-0.c:26:21: error: Cannot determine that 'x3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &x3, &y3);\n                    ^\ncollected_code/problem-449-0.c:26:26: error: Cannot determine that 'y3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &x3, &y3);\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-449-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.54 seconds (65 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   8 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   8 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 285.714 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
450§True§"collected_code/problem-450-0.c:5:25: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        output[i] = list[i];\n                        ^\ncollected_code/problem-450-0.c:12:27: error: Cannot determine that 'extractedStrings[stringsToExtract]' is initialized [premium-bughuntingUninit]\n    char *extractedStrings[stringsToExtract];\n                          ^\ncollected_code/problem-450-0.c:17:40: error: Cannot determine that 'extractedStrings[i]' is initialized [premium-bughuntingUninit]\n        printf(""%s\n"", extractedStrings[i]);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-450-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-450-0.c:12:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 20 in approximately 0.01 seconds (2019 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+] 62.5 [2+] 62.5 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
451§False§"collected_code/problem-451-0.c:13:31: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char *output = regreplace(str, regex, """", REG_EXTENDED);\n                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-451-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3661 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-451-0.c: In function 'removeWhitespace':\ncollected_code/problem-451-0.c:13:20: warning: implicit declaration of function 'regreplace' [-Wimplicit-function-declaration]\n   13 |     char *output = regreplace(str, regex, """", REG_EXTENDED);\n      |                    ^~~~~~~~~~\ncollected_code/problem-451-0.c:13:20: warning: initialization of 'char *' from 'int' makes pointer from integer without a cast [-Wint-conversion]\ncollected_code/problem-451-0.c:16:5: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   16 |     free(output);\n      |     ^~~~\ncollected_code/problem-451-0.c:3:1: note: include '<stdlib.h>' or provide a declaration of 'free'\n    2 | #include <regex.h>\n  +++ |+#include <stdlib.h>\n    3 | \ncollected_code/problem-451-0.c:16:5: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\n   16 |     free(output);\n      |     ^~~~\ncollected_code/problem-451-0.c:16:5: note: include '<stdlib.h>' or provide a declaration of 'free'\nUndefined symbols for architecture x86_64:\n  ""_regreplace"", referenced from:\n      _removeWhitespace in ccCIt5mH.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
452§True§Checking collected_code/problem-452-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-452-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3975 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
453§True§"collected_code/problem-453-0.c:16:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-453-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.37 seconds (52 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
454§False§collected_code/problem-454-0.c:7:16: error: Cannot determine that 'word[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (word[i] != '\0') {\n               ^\ncollected_code/problem-454-0.c:8:17: error: Cannot determine that 'word[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (word[i] == 'z' || word[i] == 'Z') {\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-454-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.64 seconds (22 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
455§True§"collected_code/problem-455-0.c:14:18: error: Cannot determine that 'month' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &month);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-455-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.50 seconds (44 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 210.526 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
456§True§collected_code/problem-456-0.c:6:28: error: Cannot determine that 'strings[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        char* str = strings[i];\n                           ^\ncollected_code/problem-456-0.c:7:26: error: Cannot determine that 'str' is initialized [premium-bughuntingUninit]\n        int len = strlen(str);\n                         ^\ncollected_code/problem-456-0.c:10:13: error: Cannot determine that 'str' is initialized [premium-bughuntingUninit]\n            str[j] = str[len - j - 1];\n            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-456-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-456-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 25 in approximately 0.41 seconds (61 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+] 45.4545 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-456-0.c: In function 'reverseStrings':\ncollected_code/problem-456-0.c:10:20: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   10 |             str[j] = str[len - j - 1];\n      |             ~~~~~~~^~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   16 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   20 |     reverseStrings(strings, numStrings);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'reverseStrings' from 'main'\n    |\n    +--> 'reverseStrings': events 3-8\n           |\n           |    4 | void reverseStrings(char** strings, int numStrings) {\n           |      |      ^~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'reverseStrings'\n           |    5 |     for (int i = 0; i < numStrings; i++) {\n           |      |                     ~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < numStrings')...\n           |    6 |         char* str = strings[i];\n           |      |                            ~\n           |      |                            |\n           |      |                            (5) ...to here\n           |    7 |         int len = strlen(str);\n           |    8 |         for (int j = 0; j < len / 2; j++) {\n           |      |                         ~~~~~~~~~~~\n           |      |                           |\n           |      |                           (6) following 'true' branch...\n           |    9 |             char temp = str[j];\n           |      |                            ~\n           |      |                            |\n           |      |                            (7) ...to here\n           |   10 |             str[j] = str[len - j - 1];\n           |      |             ~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                    |\n           |      |                    (8) write to string literal here\n           |\ncollected_code/problem-456-0.c:10:20: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   10 |             str[j] = str[len - j - 1];\n      |             ~~~~~~~^~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   16 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   20 |     reverseStrings(strings, numStrings);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'reverseStrings' from 'main'\n    |\n    +--> 'reverseStrings': events 3-10\n           |\n           |    4 | void reverseStrings(char** strings, int numStrings) {\n           |      |      ^~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'reverseStrings'\n           |    5 |     for (int i = 0; i < numStrings; i++) {\n           |      |                     ~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < numStrings')...\n           |    6 |         char* str = strings[i];\n           |      |                            ~\n           |      |                            |\n           |      |                            (5) ...to here\n           |    7 |         int len = strlen(str);\n           |    8 |         for (int j = 0; j < len / 2; j++) {\n           |      |                         ~~~~~~~~~~~\n           |      |                           |\n           |      |                           (6) following 'true' branch...\n           |      |                           (8) following 'true' branch...\n           |    9 |             char temp = str[j];\n           |      |                            ~\n           |      |                            |\n           |      |                            (7) ...to here\n           |      |                            (9) ...to here\n           |   10 |             str[j] = str[len - j - 1];\n           |      |             ~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                    |\n           |      |                    (10) write to string literal here\n           |\ncollected_code/problem-456-0.c:11:30: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   11 |             str[len - j - 1] = temp;\n      |             ~~~~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   16 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   20 |     reverseStrings(strings, numStrings);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'reverseStrings' from 'main'\n    |\n    +--> 'reverseStrings': events 3-8\n           |\n           |    4 | void reverseStrings(char** strings, int numStrings) {\n           |      |      ^~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'reverseStrings'\n           |    5 |     for (int i = 0; i < numStrings; i++) {\n           |      |                     ~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < numStrings')...\n           |    6 |         char* str = strings[i];\n           |      |                            ~\n           |      |                            |\n           |      |                            (5) ...to here\n           |    7 |         int len = strlen(str);\n           |    8 |         for (int j = 0; j < len / 2; j++) {\n           |      |                         ~~~~~~~~~~~\n           |      |                           |\n           |      |                           (6) following 'true' branch...\n           |    9 |             char temp = str[j];\n           |      |                            ~\n           |      |                            |\n           |      |                            (7) ...to here\n           |   10 |             str[j] = str[len - j - 1];\n           |   11 |             str[len - j - 1] = temp;\n           |      |             ~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                              |\n           |      |                              (8) write to string literal here\n           |\ncollected_code/problem-456-0.c:11:30: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   11 |             str[len - j - 1] = temp;\n      |             ~~~~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   16 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   20 |     reverseStrings(strings, numStrings);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'reverseStrings' from 'main'\n    |\n    +--> 'reverseStrings': events 3-10\n           |\n           |    4 | void reverseStrings(char** strings, int numStrings) {\n           |      |      ^~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'reverseStrings'\n           |    5 |     for (int i = 0; i < numStrings; i++) {\n           |      |                     ~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < numStrings')...\n           |    6 |         char* str = strings[i];\n           |      |                            ~\n           |      |                            |\n           |      |                            (5) ...to here\n           |    7 |         int len = strlen(str);\n           |    8 |         for (int j = 0; j < len / 2; j++) {\n           |      |                         ~~~~~~~~~~~\n           |      |                           |\n           |      |                           (6) following 'true' branch...\n           |      |                           (8) following 'true' branch...\n           |    9 |             char temp = str[j];\n           |      |                            ~\n           |      |                            |\n           |      |                            (7) ...to here\n           |      |                            (9) ...to here\n           |   10 |             str[j] = str[len - j - 1];\n           |   11 |             str[len - j - 1] = temp;\n           |      |             ~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                              |\n           |      |                              (10) write to string literal here\n           |\n
457§True§"collected_code/problem-457-0.c:28:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr[i]);\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-457-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.01 seconds (5232 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
458§False§Checking collected_code/problem-458-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-458-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 5 in approximately 0.31 seconds (16 lines/second)\nPhysical Source Lines of Code (SLOC) = 5\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
459§True§collected_code/problem-459-0.c:9:28: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (regexec(&regex, str, 1, &match, 0) != REG_NOMATCH) {\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-459-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.01 seconds (3218 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
460§True§"collected_code/problem-460-0.c:5:66: error: Cannot determine that 'arr[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""First element of sublist %d: %d\n"", i + 1, arr[i][0]);\n                                                                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-460-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.40 seconds (40 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
461§True§collected_code/problem-461-0.c:5:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-461-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n               ^\ncollected_code/problem-461-0.c:16:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str), stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-461-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-461-0.c:14:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 21 in approximately 0.38 seconds (56 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+] 55.5556 [2+] 55.5556 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
462§True§"collected_code/problem-462-0.c:6:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-462-0.c:7:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-462-0.c:15:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr[i]);\n                         ^\ncollected_code/problem-462-0.c:30:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        data[index] = arr[i];\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-462-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 49 in approximately 0.01 seconds (7317 lines/second)\nPhysical Source Lines of Code (SLOC) = 39\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 51.2821 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
463§False§collected_code/problem-463-0.c:9:14: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if (arr[i] > 0) {\n             ^\ncollected_code/problem-463-0.c:10:49: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n         max_ending_here = max_ending_here * arr[i];\n                                                ^\ncollected_code/problem-463-0.c:11:53: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n         min_ending_here = min(min_ending_here * arr[i], 1);\n                                                    ^\ncollected_code/problem-463-0.c:12:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      } else if (arr[i] == 0) {\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-463-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (4686 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 34.4828 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-463-0.c: In function 'maxProductSubarray':\ncollected_code/problem-463-0.c:11:28: warning: implicit declaration of function 'min' [-Wimplicit-function-declaration]\n   11 |          min_ending_here = min(min_ending_here * arr[i], 1);\n      |                            ^~~\ncollected_code/problem-463-0.c:17:28: warning: implicit declaration of function 'max' [-Wimplicit-function-declaration]\n   17 |          max_ending_here = max(min_ending_here * arr[i], 1);\n      |                            ^~~\nUndefined symbols for architecture x86_64:\n  ""_max"", referenced from:\n      _maxProductSubarray in ccm5Q4jT.o\n     (maybe you meant: _maxProductSubarray)\n  ""_min"", referenced from:\n      _maxProductSubarray in ccm5Q4jT.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
464§True§collected_code/problem-464-0.c:9:32: error: Cannot determine that 'dictionary[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int firstValue = dictionary[0];\n                               ^\ncollected_code/problem-464-0.c:12:23: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (dictionary[i] != firstValue) {\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-464-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (4161 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
465§True§collected_code/problem-465-0.c:6:20: error: Cannot determine that 'dict[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for(i = 0; dict[i] != NULL; i++) {\n                   ^\ncollected_code/problem-465-0.c:7:23: error: Cannot determine that 'dict[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(strlen(dict[i]) == 0) {\n                      ^\ncollected_code/problem-465-0.c:8:28: error: Cannot determine that 'dict[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            for(j = i; dict[j] != NULL; j++) {\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-465-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-465-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 32 in approximately 0.43 seconds (74 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 185.185 [1+] 37.037 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
466§True§collected_code/problem-466-0.c:7:29: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if ((mid == 0 || arr[mid] >= arr[mid - 1]) && (mid == n - 1 || arr[mid] >= arr[mid + 1])) {\n                            ^\ncollected_code/problem-466-0.c:7:41: error: Cannot determine that 'arr[mid-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if ((mid == 0 || arr[mid] >= arr[mid - 1]) && (mid == n - 1 || arr[mid] >= arr[mid + 1])) {\n                                        ^\ncollected_code/problem-466-0.c:7:87: error: Cannot determine that 'arr[mid+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if ((mid == 0 || arr[mid] >= arr[mid - 1]) && (mid == n - 1 || arr[mid] >= arr[mid + 1])) {\n                                                                                      ^\ncollected_code/problem-466-0.c:8:23: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            return arr[mid];\n                      ^\ncollected_code/problem-466-0.c:9:34: error: Cannot determine that 'arr[mid-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (mid > 0 && arr[mid - 1] > arr[mid]) {\n                                 ^\ncollected_code/problem-466-0.c:9:49: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (mid > 0 && arr[mid - 1] > arr[mid]) {\n                                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-466-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.26 seconds (89 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 45.4545 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
467§False§"collected_code/problem-467-0.c:12:27: error: Cannot determine that 'octal[j]' is initialized [premium-bughuntingUninit]\n        printf(""%d"", octal[j]);\n                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-467-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.61 seconds (21 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-467-0.c: In function 'decimalToOctal':\ncollected_code/problem-467-0.c:12:9: warning: implicit declaration of function 'printf' [-Wimplicit-function-declaration]\n   12 |         printf(""%d"", octal[j]);\n      |         ^~~~~~\ncollected_code/problem-467-0.c:1:1: note: include '<stdio.h>' or provide a declaration of 'printf'\n  +++ |+#include <stdio.h>\n    1 | void decimalToOctal(int decimal){\ncollected_code/problem-467-0.c:12:9: warning: incompatible implicit declaration of built-in function 'printf' [-Wbuiltin-declaration-mismatch]\n   12 |         printf(""%d"", octal[j]);\n      |         ^~~~~~\ncollected_code/problem-467-0.c:12:9: note: include '<stdio.h>' or provide a declaration of 'printf'\nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
468§True§collected_code/problem-468-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < arr[i+1]) {\n               ^\ncollected_code/problem-468-0.c:8:25: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < arr[i+1]) {\n                        ^\ncollected_code/problem-468-0.c:9:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            product *= arr[i];\n                          ^\ncollected_code/problem-468-0.c:12:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            product *= arr[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-468-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.49 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
469§True§collected_code/problem-469-0.c:19:34: error: Cannot determine that 'prices[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                int temp = prices[j] - prices[m] + profit[i - 1][m];\n                                 ^\ncollected_code/problem-469-0.c:19:46: error: Cannot determine that 'prices[m]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                int temp = prices[j] - prices[m] + profit[i - 1][m];\n                                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-469-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.69 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 32.2581 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
470§True§"collected_code/problem-470-0.c:12:21: warning: Uninitialized variable: result [uninitvar]\n    printf(""%d)\n"", result[length - 1]);\n                    ^\ncollected_code/problem-470-0.c:5:23: note: Assuming condition is false\n    for (int i = 0; i < length; i++) {\n                      ^\ncollected_code/problem-470-0.c:12:21: note: Uninitialized variable: result\n    printf(""%d)\n"", result[length - 1]);\n                    ^\ncollected_code/problem-470-0.c:6:27: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] + tuple2[i];\n                          ^\ncollected_code/problem-470-0.c:6:39: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = tuple1[i] + tuple2[i];\n                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-470-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (2546 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
471§True§collected_code/problem-471-0.c:7:33: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    remainder = (remainder * arr[i] % n);\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-471-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3163 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
472§True§collected_code/problem-472-0.c:5:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] != list[i-1] + 1) {\n                ^\ncollected_code/problem-472-0.c:5:28: error: Cannot determine that 'list[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] != list[i-1] + 1) {\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-472-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.48 seconds (63 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 153.846 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
473§True§"collected_code/problem-473-0.c:11:21: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr1[i] == arr2[j]) {\n                    ^\ncollected_code/problem-473-0.c:11:32: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr1[i] == arr2[j]) {\n                               ^\ncollected_code/problem-473-0.c:18:32: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d\n"", arr1[i]);\n                               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-473-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.35 seconds (91 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
474§True§Checking collected_code/problem-474-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-474-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.63 seconds (38 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
475§True§"collected_code/problem-475-0.c:30:13: error: Cannot determine that 'counters[0] members' is initialized [premium-bughuntingUninit]\n    counters[0].key = 1;\n            ^\ncollected_code/problem-475-0.c:31:13: error: Cannot determine that 'counters[0] members' is initialized [premium-bughuntingUninit]\n    counters[0].value = 5;\n            ^\ncollected_code/problem-475-0.c:32:13: error: Cannot determine that 'counters[1] members' is initialized [premium-bughuntingUninit]\n    counters[1].key = 2;\n            ^\ncollected_code/problem-475-0.c:33:13: error: Cannot determine that 'counters[1] members' is initialized [premium-bughuntingUninit]\n    counters[1].value = 2;\n            ^\ncollected_code/problem-475-0.c:34:13: error: Cannot determine that 'counters[2] members' is initialized [premium-bughuntingUninit]\n    counters[2].key = 3;\n            ^\ncollected_code/problem-475-0.c:35:13: error: Cannot determine that 'counters[2] members' is initialized [premium-bughuntingUninit]\n    counters[2].value = 7;\n            ^\ncollected_code/problem-475-0.c:36:13: error: Cannot determine that 'counters[3] members' is initialized [premium-bughuntingUninit]\n    counters[3].key = 4;\n            ^\ncollected_code/problem-475-0.c:37:13: error: Cannot determine that 'counters[3] members' is initialized [premium-bughuntingUninit]\n    counters[3].value = 1;\n            ^\ncollected_code/problem-475-0.c:38:13: error: Cannot determine that 'counters[4] members' is initialized [premium-bughuntingUninit]\n    counters[4].key = 5;\n            ^\ncollected_code/problem-475-0.c:39:13: error: Cannot determine that 'counters[4] members' is initialized [premium-bughuntingUninit]\n    counters[4].value = 4;\n            ^\ncollected_code/problem-475-0.c:46:63: error: Cannot determine that 'counters[i] members' is initialized [premium-bughuntingUninit]\n        printf(""Counter %d: key=%d, value=%d\n"", i+1, counters[i].key, counters[i].value);\n                                                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-475-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 49 in approximately 0.01 seconds (3567 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 29.4118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
476§True§collected_code/problem-476-0.c:4:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min = arr[0];\n                 ^\ncollected_code/problem-476-0.c:5:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max = arr[0];\n                 ^\ncollected_code/problem-476-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < min) {\n               ^\ncollected_code/problem-476-0.c:9:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min = arr[i];\n                     ^\ncollected_code/problem-476-0.c:11:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > max) {\n               ^\ncollected_code/problem-476-0.c:12:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = arr[i];\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-476-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.48 seconds (56 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
477§True§collected_code/problem-477-0.c:6:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i] != '\0') {\n              ^\ncollected_code/problem-477-0.c:7:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n               ^\ncollected_code/problem-477-0.c:8:25: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[i] = str[i] + 32;\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-477-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.55 seconds (36 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 117.647 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
478§True§collected_code/problem-478-0.c:12:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-478-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-478-0.c:12:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 36 in approximately 0.19 seconds (194 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+] 35.7143 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
479§True§"collected_code/problem-479-0.c:14:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-479-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2316 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
480§True§collected_code/problem-480-0.c:20:12: warning: Uninitialized variable: result [uninitvar]\n    return result;\n           ^\ncollected_code/problem-480-0.c:10:24: note: Assuming condition is false\n    for (int i = 0; str[i]; i++)\n                       ^\ncollected_code/problem-480-0.c:20:12: note: Uninitialized variable: result\n    return result;\n           ^\ncollected_code/problem-480-0.c:10:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i]; i++)\n                       ^\ncollected_code/problem-480-0.c:12:18: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[str[i]]++;\n                 ^\ncollected_code/problem-480-0.c:13:22: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (count[str[i]] > max)\n                     ^\ncollected_code/problem-480-0.c:15:28: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = count[str[i]];\n                           ^\ncollected_code/problem-480-0.c:16:25: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            result = str[i];\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-480-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (4715 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-480-0.c: In function 'getMaxOccuringChar':\ncollected_code/problem-480-0.c:20:12: warning: use of uninitialized value 'result' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   20 |     return result;\n      |            ^~~~~~\n  'getMaxOccuringChar': events 1-5\n    |\n    |    8 |     char result;\n    |      |          ^~~~~~\n    |      |          |\n    |      |          (1) region created on stack here\n    |      |          (2) capacity: 1 byte\n    |    9 | \n    |   10 |     for (int i = 0; str[i]; i++)\n    |      |                     ~~~\n    |      |                     |\n    |      |                     (3) following 'false' branch...\n    |......\n    |   20 |     return result;\n    |      |            ~~~~~~\n    |      |            |\n    |      |            (4) ...to here\n    |      |            (5) use of uninitialized value 'result' here\n    |\n
481§True§collected_code/problem-481-0.c:9:12: error: Cannot determine that 'set[n-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (set[n-1] > sum)\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-481-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.71 seconds (34 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
482§True§Checking collected_code/problem-482-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-482-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.63 seconds (49 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 115.385 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
483§True§"collected_code/problem-483-0.c:24:20: error: Cannot determine that 'x' is initialized [premium-bughuntingUninit]\n    scanf(""%llu"", &x);\n                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-483-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (4145 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 120 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
484§True§"collected_code/problem-484-0.c:12:23: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (tuple1[i] == tuple2[j]) {\n                      ^\ncollected_code/problem-484-0.c:12:36: error: Cannot determine that 'tuple2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (tuple1[i] == tuple2[j]) {\n                                   ^\ncollected_code/problem-484-0.c:19:34: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            result[k][0] = tuple1[i];\n                                 ^\ncollected_code/problem-484-0.c:20:34: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            result[k][1] = tuple2[i];\n                                 ^\ncollected_code/problem-484-0.c:27:38: error: Cannot determine that 'result[i][0]' is initialized [premium-bughuntingUninit]\n        printf(""(%d, %d) "", result[i][0], result[i][1]);\n                                     ^\ncollected_code/problem-484-0.c:27:52: error: Cannot determine that 'result[i][1]' is initialized [premium-bughuntingUninit]\n        printf(""(%d, %d) "", result[i][0], result[i][1]);\n                                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-484-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.45 seconds (84 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 34.4828 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
485§True§collected_code/problem-485-0.c:16:29: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (isPalindrome(arr[i]) && arr[i] > largest) {\n                            ^\ncollected_code/problem-485-0.c:17:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            largest = arr[i];\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-485-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.67 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
486§True§"collected_code/problem-486-0.c:24:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-486-0.c:27:18: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &k);\n                 ^\ncollected_code/problem-486-0.c:30:19: error: Cannot determine that 'p' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &p);\n                  ^\ncollected_code/problem-486-0.c:32:47: error: Cannot determine that 'p' is initialized [premium-bughuntingUninit]\n    double result = binomialProbability(n, k, p);\n                                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-486-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.55 seconds (65 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 269.231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
487§True§Checking collected_code/problem-487-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-487-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.47 seconds (87 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 206.897 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
488§True§"collected_code/problem-488-0.c:12:18: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &side);\n                 ^\ncollected_code/problem-488-0.c:14:57: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    printf(""Area of the pentagon: %f\n"", areaOfPentagon(side));\n                                                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-488-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2459 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
489§True§collected_code/problem-489-0.c:4:22: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int largest = arr[0];\n                     ^\ncollected_code/problem-489-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > largest) {\n               ^\ncollected_code/problem-489-0.c:9:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            largest = arr[i];\n                         ^\ncollected_code/problem-489-0.c:11:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (arr[i] == largest) {\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-489-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (2984 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
490§True§Checking collected_code/problem-490-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-490-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3587 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
491§True§"collected_code/problem-491-0.c:15:19: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &a);\n                  ^\ncollected_code/problem-491-0.c:17:19: error: Cannot determine that 'r' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &r);\n                  ^\ncollected_code/problem-491-0.c:19:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-491-0.c:20:31: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    double sum = geometricSum(a, r, n);\n                              ^\ncollected_code/problem-491-0.c:20:34: error: Cannot determine that 'r' is initialized [premium-bughuntingUninit]\n    double sum = geometricSum(a, r, n);\n                                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-491-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2639 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-491-0.c: In function 'geometricSum':\ncollected_code/problem-491-0.c:6:20: warning: implicit declaration of function 'pow' [-Wimplicit-function-declaration]\n    6 |         sum += a * pow(r, i);\n      |                    ^~~\ncollected_code/problem-491-0.c:2:1: note: include '<math.h>' or provide a declaration of 'pow'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-491-0.c:6:20: warning: incompatible implicit declaration of built-in function 'pow' [-Wbuiltin-declaration-mismatch]\n    6 |         sum += a * pow(r, i);\n      |                    ^~~\ncollected_code/problem-491-0.c:6:20: note: include '<math.h>' or provide a declaration of 'pow'\n
492§True§collected_code/problem-492-0.c:10:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] == target) {\n               ^\ncollected_code/problem-492-0.c:14:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] < target) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-492-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.02 seconds (1534 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 68.9655 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
493§True§Checking collected_code/problem-493-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-493-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 55 in approximately 0.01 seconds (6636 lines/second)\nPhysical Source Lines of Code (SLOC) = 45\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 44.4444 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
494§True§collected_code/problem-494-0.c:7:39: error: Cannot determine that 'binary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        decimal = decimal * 2 + binary[i];\n                                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-494-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.54 seconds (39 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
495§True§Checking collected_code/problem-495-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-495-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (2371 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
496§True§collected_code/problem-496-0.c:9:24: error: Cannot determine that 'arr[left]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] < arr[smallest])\n                       ^\ncollected_code/problem-496-0.c:9:36: error: Cannot determine that 'arr[smallest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] < arr[smallest])\n                                   ^\ncollected_code/problem-496-0.c:12:25: error: Cannot determine that 'arr[right]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] < arr[smallest])\n                        ^\ncollected_code/problem-496-0.c:12:38: error: Cannot determine that 'arr[smallest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] < arr[smallest])\n                                     ^\ncollected_code/problem-496-0.c:16:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[i];\n                      ^\ncollected_code/problem-496-0.c:17:21: error: Cannot determine that 'arr[smallest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i] = arr[smallest];\n                    ^\ncollected_code/problem-496-0.c:32:27: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int smallest = arr[0];\n                          ^\ncollected_code/problem-496-0.c:33:21: error: Cannot determine that 'arr[n-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[0] = arr[n - 1];\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-496-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 51 in approximately 0.01 seconds (6474 lines/second)\nPhysical Source Lines of Code (SLOC) = 41\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 48.7805 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
497§True§"collected_code/problem-497-0.c:13:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-497-0.c:15:18: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &height);\n                 ^\ncollected_code/problem-497-0.c:17:36: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    float area = find_surface_area(radius, height);\n                                   ^\ncollected_code/problem-497-0.c:17:44: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    float area = find_surface_area(radius, height);\n                                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-497-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.56 seconds (36 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 277.778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-497-0.c: In function 'find_surface_area':\ncollected_code/problem-497-0.c:3:26: warning: implicit declaration of function 'sqrt' [-Wimplicit-function-declaration]\n    3 |     float slant_height = sqrt((radius * radius) + (height * height));\n      |                          ^~~~\ncollected_code/problem-497-0.c:1:1: note: include '<math.h>' or provide a declaration of 'sqrt'\n  +++ |+#include <math.h>\n    1 | float find_surface_area(float radius, float height) {\ncollected_code/problem-497-0.c:3:26: warning: incompatible implicit declaration of built-in function 'sqrt' [-Wbuiltin-declaration-mismatch]\n    3 |     float slant_height = sqrt((radius * radius) + (height * height));\n      |                          ^~~~\ncollected_code/problem-497-0.c:3:26: note: include '<math.h>' or provide a declaration of 'sqrt'\ncollected_code/problem-497-0.c: In function 'main':\ncollected_code/problem-497-0.c:12:5: warning: implicit declaration of function 'printf' [-Wimplicit-function-declaration]\n   12 |     printf(""Enter the radius of the cone: "");\n      |     ^~~~~~\ncollected_code/problem-497-0.c:1:1: note: include '<stdio.h>' or provide a declaration of 'printf'\n  +++ |+#include <stdio.h>\n    1 | float find_surface_area(float radius, float height) {\ncollected_code/problem-497-0.c:12:5: warning: incompatible implicit declaration of built-in function 'printf' [-Wbuiltin-declaration-mismatch]\n   12 |     printf(""Enter the radius of the cone: "");\n      |     ^~~~~~\ncollected_code/problem-497-0.c:12:5: note: include '<stdio.h>' or provide a declaration of 'printf'\ncollected_code/problem-497-0.c:13:5: warning: implicit declaration of function 'scanf' [-Wimplicit-function-declaration]\n   13 |     scanf(""%f"", &radius);\n      |     ^~~~~\ncollected_code/problem-497-0.c:13:5: note: include '<stdio.h>' or provide a declaration of 'scanf'\ncollected_code/problem-497-0.c:13:5: warning: incompatible implicit declaration of built-in function 'scanf' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-497-0.c:13:5: note: include '<stdio.h>' or provide a declaration of 'scanf'\n"
498§True§"collected_code/problem-498-0.c:15:21: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                    ^\ncollected_code/problem-498-0.c:15:28: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-498-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.56 seconds (30 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
499§True§"collected_code/problem-499-0.c:12:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-499-0.c:14:34: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    diameter = calculateDiameter(radius);\n                                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-499-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (2875 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 230.769 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
500§True§Checking collected_code/problem-500-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-500-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-500-0.c:38:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-500-0.c:46:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 71 in approximately 0.27 seconds (259 lines/second)\nPhysical Source Lines of Code (SLOC) = 46\nHits@level = [0]   3 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 108.696 [1+] 43.4783 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-500-0.c: In function 'concatenateList':\ncollected_code/problem-500-0.c:38:38: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n   38 |         char* temp = realloc(result, strlen(result) + size + 1); // Resize result string\n      |                                      ^~~~~~\ncollected_code/problem-500-0.c:3:1: note: include '<string.h>' or provide a declaration of 'strlen'\n    2 | #include <stdlib.h>\n  +++ |+#include <string.h>\n    3 | \ncollected_code/problem-500-0.c:38:38: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n   38 |         char* temp = realloc(result, strlen(result) + size + 1); // Resize result string\n      |                                      ^~~~~~\ncollected_code/problem-500-0.c:38:38: note: include '<string.h>' or provide a declaration of 'strlen'\ncollected_code/problem-500-0.c: In function 'append':\ncollected_code/problem-500-0.c:15:20: warning: dereference of possibly-NULL 'new_node' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   15 |     new_node->data = new_data;\n      |     ~~~~~~~~~~~~~~~^~~~~~~~~~\n  'append': events 1-2\n    |\n    |   12 |     struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                           |\n    |      |                                           (1) this call could return NULL\n    |......\n    |   15 |     new_node->data = new_data;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~              \n    |      |                    |\n    |      |                    (2) 'new_node' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-500-0.c: In function 'concatenateList':\ncollected_code/problem-500-0.c:32:15: warning: dereference of possibly-NULL 'result' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   32 |     result[0] = '\0'; // Initialize empty string\n      |     ~~~~~~~~~~^~~~~~\n  'concatenateList': events 1-2\n    |\n    |   31 |     char* result = malloc(1); // Allocate memory for empty string\n    |      |                    ^~~~~~~~~\n    |      |                    |\n    |      |                    (1) this call could return NULL\n    |   32 |     result[0] = '\0'; // Initialize empty string\n    |      |     ~~~~~~~~~~~~~~~~\n    |      |               |\n    |      |               (2) 'result' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-500-0.c: In function 'main':\ncollected_code/problem-500-0.c:66:5: warning: use of NULL 'concatenatedString' where non-null expected [CWE-476] [-Wanalyzer-null-argument]\n   66 |     printf(""%s\n"", concatenatedString);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   54 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   58 |     append(&head, 1);\n    |      |     ~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'append' from 'main'\n    |\n    +--> 'append': events 3-5\n           |\n           |   11 | void append(struct Node** head_ref, int new_data) {\n           |      |      ^~~~~~\n           |      |      |\n           |      |      (3) entry to 'append'\n           |......\n           |   18 |     if (*head_ref == NULL) {\n           |      |        ~\n           |      |        |\n           |      |        (4) following 'true' branch...\n           |   19 |         *head_ref = new_node;\n           |      |         ~~~~~~~~~~~~~~~~~~~~\n           |      |                   |\n           |      |                   (5) ...to here\n           |\n    <------+\n    |\n  'main': events 6-7\n    |\n    |   58 |     append(&head, 1);\n    |      |     ^~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (6) returning to 'main' from 'append'\n    |   59 |     append(&head, 2);\n    |      |     ~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (7) calling 'append' from 'main'\n    |\n    +--> 'append': events 8-9\n           |\n           |   11 | void append(struct Node** head_ref, int new_data) {\n           |      |      ^~~~~~\n           |      |      |\n           |      |      (8) entry to 'append'\n           |......\n           |   18 |     if (*head_ref == NULL) {\n           |      |        ~\n           |      |        |\n           |      |        (9) following 'false' branch...\n           |\n         'append': event 10\n           |\n           |cc1:\n           | (10): ...to here\n           |\n         'append': events 11-12\n           |\n           |   23 |     while (last->next != NULL)\n           |      |                       ^\n           |      |                       |\n           |      |                       (11) following 'false' branch...\n           |......\n           |   26 |     last->next = new_node;\n           |      |     ~~~~~~~~~~~~~~~~~~~~~\n           |      |                |\n           |      |                (12) ...to here\n           |\n    <------+\n    |\n  'main': events 13-14\n    |\n    |   59 |     append(&head, 2);\n    |      |     ^~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (13) returning to 'main' from 'append'\n    |   60 |     append(&head, 3);\n    |      |     ~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (14) calling 'append' from 'main'\n    |\n    +--> 'append': events 15-16\n           |\n           |   11 | void append(struct Node** head_ref, int new_data) {\n           |      |      ^~~~~~\n           |      |      |\n           |      |      (15) entry to 'append'\n           |......\n           |   18 |     if (*head_ref == NULL) {\n           |      |        ~\n           |      |        |\n           |      |        (16) following 'false' branch...\n           |\n         'append': event 17\n           |\n           |cc1:\n           | (17): ...to here\n           |\n         'append': events 18-19\n           |\n           |   23 |     while (last->next != NULL)\n           |      |                       ^\n           |      |                       |\n           |      |                       (18) following 'true' branch...\n           |   24 |         last = last->next;\n           |      |         ~~~~~~~~~~~~~~~~~\n           |      |              |\n           |      |              (19) ...to here\n           |\n         'append': events 20-21\n           |\n           |   23 |     while (last->next != NULL)\n           |      |                       ^\n           |      |                       |\n           |      |                       (20) following 'false' branch...\n           |......\n           |   26 |     last->next = new_node;\n           |      |     ~~~~~~~~~~~~~~~~~~~~~\n           |      |                |\n           |      |                (21) ...to here\n           |\n    <------+\n    |\n  'main': events 22-23\n    |\n    |   60 |     append(&head, 3);\n    |      |     ^~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (22) returning to 'main' from 'append'\n    |......\n    |   63 |     char* concatenatedString = concatenateList(head);\n    |      |                                ~~~~~~~~~~~~~~~~~~~~~\n    |      |                                |\n    |      |                                (23) calling 'concatenateList' from 'main'\n    |\n    +--> 'concatenateList': event 24\n           |\n           |   30 | char* concatenateList(struct Node* head) {\n           |      |       ^~~~~~~~~~~~~~~\n           |      |       |\n           |      |       (24) entry to 'concatenateList'\n           |\n         'concatenateList': event 25\n           |\n           |   36 |     while (current != NULL) {\n           |      |                    ^\n           |      |                    |\n           |      |                    (25) following 'true' branch (when 'current' is non-NULL)...\n           |\n         'concatenateList': event 26\n           |\n           |   37 |         int size = snprintf(NULL, 0, ""%d"", current->data); // Get size of current element\n           |      |                    ^~~~~~~~\n           |      |                    |\n           |      |                    (26) ...to here\n           |\n         'concatenateList': events 27-29\n           |\n           |   38 |         char* temp = realloc(result, strlen(result) + size + 1); // Resize result string\n           |      |                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                      |\n           |      |                      (27) when 'realloc' fails\n           |   39 | \n           |   40 |         if (temp == NULL) {\n           |      |            ~          \n           |      |            |\n           |      |            (28) following 'true' branch (when 'temp' is NULL)...\n           |   41 |             free(result);\n           |      |             ~~~~~~~~~~~~\n           |      |             |\n           |      |             (29) ...to here\n           |\n         'concatenateList': event 30\n           |\n           |   42 |             return NULL; // Memory allocation failed\n           |      |                    ^~~~\n           |      |                    |\n           |      |                    (30) '0' is NULL\n           |\n         'concatenateList': event 31\n           |\n           |   42 |             return NULL; // Memory allocation failed\n           |      |                    ^~~~\n           |      |                    |\n           |      |                    (31) '0' is NULL\n           |\n    <------+\n    |\n  'main': events 32-33\n    |\n    |   63 |     char* concatenatedString = concatenateList(head);\n    |      |                                ^~~~~~~~~~~~~~~~~~~~~\n    |      |                                |\n    |      |                                (32) returning to 'main' from 'concatenateList'\n    |......\n    |   66 |     printf(""%s\n"", concatenatedString);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (33) argument 1 ('concatenatedString') NULL where non-null expected\n    |\n<built-in>: note: argument 1 of '__builtin_puts' must be non-null\n"
501§True§"collected_code/problem-501-0.c:20:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-501-0.c:23:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-501-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (4155 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 238.095 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
502§True§"collected_code/problem-502-0.c:12:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-502-0.c:15:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-502-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (2688 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
503§True§collected_code/problem-503-0.c:6:20: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += list[i];\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-503-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2498 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
504§True§"collected_code/problem-504-0.c:14:17: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n   scanf(""%d"", &n);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-504-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (1242 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
505§True§collected_code/problem-505-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] != 0) {\n               ^\ncollected_code/problem-505-0.c:8:31: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            arr[count++] = arr[i];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-505-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.55 seconds (51 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
506§True§"collected_code/problem-506-0.c:16:21: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &n, &k);\n                    ^\ncollected_code/problem-506-0.c:16:25: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &n, &k);\n                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-506-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.02 seconds (1137 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
507§True§"collected_code/problem-507-0.c:8:24: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strcmp(list[i], word) == 0) {\n                       ^\ncollected_code/problem-507-0.c:8:29: error: Cannot determine that 'word[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strcmp(list[i], word) == 0) {\n                            ^\ncollected_code/problem-507-0.c:10:28: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                strcpy(list[j], list[j + 1]);\n                           ^\ncollected_code/problem-507-0.c:10:37: error: Cannot determine that 'list[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                strcpy(list[j], list[j + 1]);\n                                    ^\ncollected_code/problem-507-0.c:12:24: error: Cannot determine that 'list[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            strcpy(list[size - 1], """");\n                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-507-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-507-0.c:10:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-507-0.c:12:  [1] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused). Risk is low because the source is a constant character.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 29 in approximately 0.49 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   1 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+] 83.3333 [2+] 41.6667 [3+] 41.6667 [4+] 41.6667 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
508§False§collected_code/problem-508-0.c:7:14: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (list1[i] == list2[j]) {\n             ^\ncollected_code/problem-508-0.c:7:26: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (list1[i] == list2[j]) {\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-508-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.45 seconds (38 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
509§True§"collected_code/problem-509-0.c:20:18: error: Cannot determine that 'givenNumber' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &givenNumber);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-509-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.33 seconds (76 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
510§True§collected_code/problem-510-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] <= k) {\n               ^\ncollected_code/problem-510-0.c:10:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            product *= arr[i];\n                          ^\ncollected_code/problem-510-0.c:13:34: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (product * arr[j] <= k) {\n                                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-510-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (5448 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.037 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
511§True§Checking collected_code/problem-511-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-511-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.37 seconds (81 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
512§True§collected_code/problem-512-0.c:6:13: error: Cannot determine that '*(int*)tuple' is initialized [premium-bughuntingUninit]\n        if (*(int*)tuple == *(int*)element) {\n            ^\ncollected_code/problem-512-0.c:6:29: error: Cannot determine that '*(int*)element' is initialized [premium-bughuntingUninit]\n        if (*(int*)tuple == *(int*)element) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-512-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (3534 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
513§True§"collected_code/problem-513-0.c:8:10: error: Cannot determine that 'list[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  strcpy(list, """");\n         ^\ncollected_code/problem-513-0.c:10:25: error: Cannot determine that 'tuple[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  for(i = 0; i < strlen(tuple); i++) {\n                        ^\ncollected_code/problem-513-0.c:12:18: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strcat(list, string);\n                 ^\ncollected_code/problem-513-0.c:23:18: error: Cannot determine that 'list[0]' is initialized [premium-bughuntingUninit]\n  printf(""%s\n"", list);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-513-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-513-0.c:12:  [4] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused).\ncollected_code/problem-513-0.c:19:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-513-0.c:8:  [1] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused). Risk is low because the source is a constant character.\ncollected_code/problem-513-0.c:10:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-513-0.c:11:  [1] (buffer) strncat:\n  Easily used incorrectly (e.g., incorrectly computing the correct maximum\n  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,\n  or automatically resizing strings.\n\nANALYSIS SUMMARY:\n\nHits = 5\nLines analyzed = 25 in approximately 0.48 seconds (52 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   3 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   6 [1+]   5 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 315.789 [1+] 263.158 [2+] 105.263 [3+] 52.6316 [4+] 52.6316 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
514§True§collected_code/problem-514-0.c:18:14: error: Cannot determine that 'tupleList[0] members' is initialized [premium-bughuntingUninit]\n    tupleList[0].x = 1;\n             ^\ncollected_code/problem-514-0.c:19:14: error: Cannot determine that 'tupleList[0] members' is initialized [premium-bughuntingUninit]\n    tupleList[0].y = 2;\n             ^\ncollected_code/problem-514-0.c:21:14: error: Cannot determine that 'tupleList[1] members' is initialized [premium-bughuntingUninit]\n    tupleList[1].x = 3;\n             ^\ncollected_code/problem-514-0.c:22:14: error: Cannot determine that 'tupleList[1] members' is initialized [premium-bughuntingUninit]\n    tupleList[1].y = 4;\n             ^\ncollected_code/problem-514-0.c:24:14: error: Cannot determine that 'tupleList[2] members' is initialized [premium-bughuntingUninit]\n    tupleList[2].x = 5;\n             ^\ncollected_code/problem-514-0.c:25:14: error: Cannot determine that 'tupleList[2] members' is initialized [premium-bughuntingUninit]\n    tupleList[2].y = 6;\n             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-514-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.43 seconds (71 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
515§True§collected_code/problem-515-0.c:14:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int mod = arr[i] % m;\n                     ^\ncollected_code/problem-515-0.c:18:11: error: Cannot determine that 'dp[0]' is initialized [premium-bughuntingUninit]\n    if (dp[0] > 0)\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-515-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 44 in approximately 0.41 seconds (106 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 57.1429 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
516§True§collected_code/problem-516-0.c:39:18: warning: Uninitialized variable: output [uninitvar]\n        arr[i] = output[i];\n                 ^\ncollected_code/problem-516-0.c:31:27: note: Assuming condition is false\n    for (int i = n - 1; i >= 0; i--) {\n                          ^\ncollected_code/problem-516-0.c:39:18: note: Uninitialized variable: output\n        arr[i] = output[i];\n                 ^\ncollected_code/problem-516-0.c:5:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max = arr[0];\n                 ^\ncollected_code/problem-516-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > max) {\n               ^\ncollected_code/problem-516-0.c:8:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = arr[i];\n                     ^\ncollected_code/problem-516-0.c:21:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[(arr[i] / exp) % 10]++;\n                  ^\ncollected_code/problem-516-0.c:32:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n                         ^\ncollected_code/problem-516-0.c:33:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[(arr[i] / exp) % 10]--;\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-516-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 64 in approximately 0.44 seconds (145 lines/second)\nPhysical Source Lines of Code (SLOC) = 43\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 46.5116 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
517§True§collected_code/problem-517-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > max) {\n               ^\ncollected_code/problem-517-0.c:7:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = arr[i];\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-517-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (3007 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
518§True§"collected_code/problem-518-0.c:17:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-518-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (4308 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 181.818 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
519§True§"collected_code/problem-519-0.c:15:18: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &sideLength);\n                 ^\ncollected_code/problem-519-0.c:16:47: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    float volume = calculateTetrahedronVolume(sideLength);\n                                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-519-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.56 seconds (32 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
520§True§collected_code/problem-520-0.c:11:21: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int result = arr[0];\n                    ^\ncollected_code/problem-520-0.c:13:31: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result = (result * arr[i]) / gcd(result, arr[i]);\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-520-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.36 seconds (61 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
521§True§"collected_code/problem-521-0.c:14:24: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                       ^\ncollected_code/problem-521-0.c:14:32: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                               ^\ncollected_code/problem-521-0.c:14:40: error: Cannot determine that 'side3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-521-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.52 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
522§True§collected_code/problem-522-0.c:15:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j] && lis[i] < lis[j] + 1) {\n                   ^\ncollected_code/problem-522-0.c:15:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j] && lis[i] < lis[j] + 1) {\n                            ^\ncollected_code/problem-522-0.c:23:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j] && lds[i] < lds[j] + 1) {\n                   ^\ncollected_code/problem-522-0.c:23:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j] && lds[i] < lds[j] + 1) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-522-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 44 in approximately 0.54 seconds (82 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 27.7778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
523§False§collected_code/problem-523-0.c:8:28: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int strLength = strlen(str);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-523-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-523-0.c:8:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 28 in approximately 0.41 seconds (68 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   0 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+] 41.6667 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
524§True§collected_code/problem-524-0.c:8:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (i > 0 && arr[i] > arr[i-1]) {\n                        ^\ncollected_code/problem-524-0.c:8:34: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (i > 0 && arr[i] > arr[i-1]) {\n                                 ^\ncollected_code/problem-524-0.c:10:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            currentSum += arr[i];\n                             ^\ncollected_code/problem-524-0.c:18:29: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            currentSum = arr[i];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-524-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.34 seconds (112 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
525§True§Checking collected_code/problem-525-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-525-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.31 seconds (136 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
526§True§collected_code/problem-526-0.c:6:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\ncollected_code/problem-526-0.c:26:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str), stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-526-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-526-0.c:24:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-526-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 32 in approximately 0.01 seconds (4844 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+] 83.3333 [2+] 41.6667 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-526-0.c: In function 'capitalizeFirstAndLastLetters':\ncollected_code/problem-526-0.c:6:15: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n    6 |     int len = strlen(str);\n      |               ^~~~~~\ncollected_code/problem-526-0.c:3:1: note: include '<string.h>' or provide a declaration of 'strlen'\n    2 | #include <ctype.h>\n  +++ |+#include <string.h>\n    3 | \ncollected_code/problem-526-0.c:6:15: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n    6 |     int len = strlen(str);\n      |               ^~~~~~\ncollected_code/problem-526-0.c:6:15: note: include '<string.h>' or provide a declaration of 'strlen'\n
527§False§"collected_code/problem-527-0.c:6:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] + arr[j] == target) {\n                   ^\ncollected_code/problem-527-0.c:6:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] + arr[j] == target) {\n                            ^\ncollected_code/problem-527-0.c:7:41: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                printf(""(%d, %d)\n"", arr[i], arr[j]);\n                                        ^\ncollected_code/problem-527-0.c:7:49: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                printf(""(%d, %d)\n"", arr[i], arr[j]);\n                                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-527-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 10 in approximately 0.01 seconds (1453 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
528§True§Checking collected_code/problem-528-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-528-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 55 in approximately 0.42 seconds (131 lines/second)\nPhysical Source Lines of Code (SLOC) = 44\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-528-0.c: In function 'findMinLengthLists':\ncollected_code/problem-528-0.c:32:12: warning: returning 'List **' from a function with incompatible return type 'List *' [-Wincompatible-pointer-types]\n   32 |     return minLists;\n      |            ^~~~~~~~\ncollected_code/problem-528-0.c:32:12: warning: function returns address of local variable [-Wreturn-local-addr]\ncollected_code/problem-528-0.c: In function 'main':\ncollected_code/problem-528-0.c:42:23: warning: initialization of 'List **' from incompatible pointer type 'List *' [-Wincompatible-pointer-types]\n   42 |     List** minLists = findMinLengthLists(lists, sizeof(lists) / sizeof(lists[0]));\n      |                       ^~~~~~~~~~~~~~~~~~\ncollected_code/problem-528-0.c:49:37: warning: dereference of NULL '0' [CWE-476] [-Wanalyzer-null-dereference]\n   49 |         for (int j = 0; j < minLists[i]->length; j++) {\n      |                             ~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   35 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   42 |     List** minLists = findMinLengthLists(lists, sizeof(lists) / sizeof(lists[0]));\n    |      |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (2) calling 'findMinLengthLists' from 'main'\n    |\n    +--> 'findMinLengthLists': events 3-11\n           |\n           |    8 | List* findMinLengthLists(List** lists, int numLists) {\n           |      |       ^~~~~~~~~~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'findMinLengthLists'\n           |    9 |     if (numLists <= 0 || lists == NULL) {\n           |      |        ~\n           |      |        |\n           |      |        (4) following 'false' branch...\n           |......\n           |   13 |     List* minLists[numLists];\n           |      |     ~~~~\n           |      |     |\n           |      |     (5) ...to here\n           |......\n           |   17 |     for (int i = 0; i < numLists; i++) {\n           |      |                     ~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (6) following 'true' branch (when 'i < numLists')...\n           |   18 |         if (lists[i]->length < minLen) {\n           |      |            ~     ~\n           |      |            |     |\n           |      |            |     (7) ...to here\n           |      |            (8) following 'false' branch...\n           |......\n           |   23 |         if (lists[i]->length == minLen) {\n           |      |            ~     ~\n           |      |            |     |\n           |      |            |     (9) ...to here\n           |      |            (10) following 'true' branch...\n           |   24 |             minLists[numMinLists++] = lists[i];\n           |      |                                            ~\n           |      |                                            |\n           |      |                                            (11) ...to here\n           |\n    <------+\n    |\n  'main': events 12-16\n    |\n    |   42 |     List** minLists = findMinLengthLists(lists, sizeof(lists) / sizeof(lists[0]));\n    |      |                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (12) returning to 'main' from 'findMinLengthLists'\n    |......\n    |   47 |     for (int i = 0; i < numMinLists; i++) {\n    |      |                     ~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (13) following 'true' branch (when 'i < numMinLists')...\n    |   48 |         printf(""List %d: "", i + 1);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (14) ...to here\n    |   49 |         for (int j = 0; j < minLists[i]->length; j++) {\n    |      |                             ~~~~~~~~~~~\n    |      |                                     |\n    |      |                                     (15) '0' is NULL\n    |      |                                     (16) dereference of NULL 'minLists + (long unsigned int)i * 8'\n    |\n"
529§True§"collected_code/problem-529-0.c:15:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-529-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2629 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
530§False§collected_code/problem-530-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-530-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 10 in approximately 0.01 seconds (1306 lines/second)\nPhysical Source Lines of Code (SLOC) = 10\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
531§False§collected_code/problem-531-0.c:13:22: error: Cannot determine that 'coins[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (coins[j] <= i) {\n                     ^\ncollected_code/problem-531-0.c:14:43: error: Cannot determine that 'coins[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                int sub_res = dp[i - coins[j]];\n                                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-531-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.01 seconds (2494 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.037 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-531-0.c: In function 'minCoins':\ncollected_code/problem-531-0.c:8:17: error: 'INT_MAX' undeclared (first use in this function)\n    8 |         dp[i] = INT_MAX;\n      |                 ^~~~~~~\ncollected_code/problem-531-0.c:2:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n    1 | #include <stdio.h>\n  +++ |+#include <limits.h>\n    2 | \ncollected_code/problem-531-0.c:8:17: note: each undeclared identifier is reported only once for each function it appears in\n    8 |         dp[i] = INT_MAX;\n      |                 ^~~~~~~\n
532§True§collected_code/problem-532-0.c:6:23: error: Cannot determine that 'str1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len1 = strlen(str1);\n                      ^\ncollected_code/problem-532-0.c:7:23: error: Cannot determine that 'str2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len2 = strlen(str2);\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-532-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-532-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-532-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 48 in approximately 0.44 seconds (109 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   2 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+] 62.5 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-532-0.c: In function 'arePermutations':\ncollected_code/problem-532-0.c:24:19: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n   24 |         count[str2[i]]--;\n      |               ~~~~^~~\n  'main': events 1-3\n    |\n    |   38 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   39 |     char str1[] = ""abcd"";\n    |   40 |     char str2[] = ""dcba"";\n    |      |          ~~~~\n    |      |          |\n    |      |          (2) capacity: 5 bytes\n    |   41 | \n    |   42 |     if (arePermutations(str1, str2)) {\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (3) calling 'arePermutations' from 'main'\n    |\n    +--> 'arePermutations': events 4-19\n           |\n           |    5 | int arePermutations(char* str1, char* str2) {\n           |      |     ^~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (4) entry to 'arePermutations'\n           |......\n           |   10 |     if (len1 != len2) {\n           |      |        ~\n           |      |        |\n           |      |        (5) following 'false' branch (when 'len1 == len2')...\n           |......\n           |   15 |     int count[256] = {0};\n           |      |         ~~~~~\n           |      |         |\n           |      |         (6) ...to here\n           |......\n           |   23 |     for (int i = 0; i < len2; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (7) following 'true' branch (when 'i < len2')...\n           |      |                       (9) following 'true' branch (when 'i < len2')...\n           |      |                       (11) following 'true' branch (when 'i < len2')...\n           |      |                       (13) following 'true' branch (when 'i < len2')...\n           |      |                       (15) following 'true' branch (when 'i < len2')...\n           |      |                       (17) following 'true' branch (when 'i < len2')...\n           |   24 |         count[str2[i]]--;\n           |      |               ~~~~~~~\n           |      |                   |\n           |      |                   (8) ...to here\n           |      |                   (10) ...to here\n           |      |                   (12) ...to here\n           |      |                   (14) ...to here\n           |      |                   (16) ...to here\n           |      |                   (18) ...to here\n           |      |                   (19) out-of-bounds read at byte 5 but 'str2' ends at byte 5\n           |\ncollected_code/problem-532-0.c:24:19: note: read of 1 byte from after the end of 'str2'\n   24 |         count[str2[i]]--;\n      |               ~~~~^~~\ncollected_code/problem-532-0.c:24:19: note: valid subscripts for 'str2' are '[0]' to '[4]'\n"
533§True§collected_code/problem-533-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] != dataType) {\n               ^\ncollected_code/problem-533-0.c:9:31: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            arr[index++] = arr[i];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-533-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.34 seconds (102 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
534§True§Checking collected_code/problem-534-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-534-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-534-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-534-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 28 in approximately 0.39 seconds (73 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 130.435 [1+] 86.9565 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
535§True§"collected_code/problem-535-0.c:13:23: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%lf %lf"", &radius, &height);\n                      ^\ncollected_code/problem-535-0.c:13:32: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%lf %lf"", &radius, &height);\n                               ^\ncollected_code/problem-535-0.c:15:42: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    double topArea = cylinderSurfaceArea(radius, height);\n                                         ^\ncollected_code/problem-535-0.c:15:50: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    double topArea = cylinderSurfaceArea(radius, height);\n                                                 ^\ncollected_code/problem-535-0.c:16:45: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    double bottomArea = cylinderSurfaceArea(radius, height);\n                                            ^\ncollected_code/problem-535-0.c:16:53: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    double bottomArea = cylinderSurfaceArea(radius, height);\n                                                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-535-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.40 seconds (50 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
536§True§collected_code/problem-536-0.c:5:16: error: Cannot determine that 'list[n]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    return list[n];\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-536-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (1950 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
537§True§"collected_code/problem-537-0.c:6:16: error: Cannot determine that 'words[100]' is initialized [premium-bughuntingUninit]\n    char* words[100];\n               ^\ncollected_code/problem-537-0.c:9:19: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    word = strtok(str, "" "");\n                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-537-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.61 seconds (57 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
538§True§Checking collected_code/problem-538-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-538-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-538-0.c:17:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-538-0.c:16:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-538-0.c:16:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 38 in approximately 0.36 seconds (105 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   1 [1]   1 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   4 [1+]   3 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 133.333 [1+] 100 [2+] 66.6667 [3+] 33.3333 [4+] 33.3333 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-538-0.c: In function 'convertStringListToTuple':\ncollected_code/problem-538-0.c:16:23: warning: dereference of possibly-NULL 'tuple.data' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   16 |         tuple.data[i] = (char *)malloc((strlen(stringList[i]) + 1) * sizeof(char));\n      |         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'convertStringListToTuple': events 1-4\n    |\n    |   12 |     tuple.data = (char **)malloc(size * sizeof(char *));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |......\n    |   15 |     for (int i = 0; i < size; i++) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < size')...\n    |   16 |         tuple.data[i] = (char *)malloc((strlen(stringList[i]) + 1) * sizeof(char));\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |                                  |\n    |      |                       |                                  (3) ...to here\n    |      |                       (4) 'tuple.data + (long unsigned int)i * 8' could be NULL: unchecked value from (1)\n    |\n
539§True§"collected_code/problem-539-0.c:18:16: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n  scanf(""%d"", &size);\n               ^\ncollected_code/problem-539-0.c:26:29: error: Cannot determine that 'powerList[i]' is initialized [premium-bughuntingUninit]\n    printf(""%d\n"", powerList[i]);\n                            ^\ncollected_code/problem-539-0.c:29:8: error: Cannot determine that 'powerList[0]' is initialized [premium-bughuntingUninit]\n  free(powerList);\n       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-539-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.34 seconds (91 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-539-0.c: In function 'createPowerList':\ncollected_code/problem-539-0.c:11:12: warning: dereference of possibly-NULL 'arr' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   11 |     arr[i] = power(i, i);\n      |     ~~~~~~~^~~~~~~~~~~~~\n  'main': events 1-3\n    |\n    |   15 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   20 |   int* powerList = (int*) malloc(size * sizeof(int));\n    |      |                           ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (2) this call could return NULL\n    |   21 | \n    |   22 |   createPowerList(powerList, size);\n    |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |   |\n    |      |   (3) calling 'createPowerList' from 'main'\n    |\n    +--> 'createPowerList': events 4-7\n           |\n           |    9 | void createPowerList(int* arr, int size) {\n           |      |      ^~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'createPowerList'\n           |   10 |   for (int i = 0; i < size; i++) {\n           |      |                   ~~~~~~~~\n           |      |                     |\n           |      |                     (5) following 'true' branch (when 'i < size')...\n           |   11 |     arr[i] = power(i, i);\n           |      |     ~~~~~~~~~~~~~~~~~~~~\n           |      |        |   |\n           |      |        |   (7) 'arr + (long unsigned int)i * 4' could be NULL: unchecked value from (2)\n           |      |        (6) ...to here\n           |\n
540§True§collected_code/problem-540-0.c:4:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max = arr[0];\n                 ^\ncollected_code/problem-540-0.c:6:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(arr[i] > max) {\n              ^\ncollected_code/problem-540-0.c:7:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = arr[i];\n                     ^\ncollected_code/problem-540-0.c:14:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min = arr[0];\n                 ^\ncollected_code/problem-540-0.c:16:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(arr[i] < min) {\n              ^\ncollected_code/problem-540-0.c:17:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min = arr[i];\n                     ^\ncollected_code/problem-540-0.c:30:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(arr[i] == maxVal) {\n              ^\ncollected_code/problem-540-0.c:33:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(arr[i] == minVal) {\n              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-540-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 48 in approximately 0.38 seconds (125 lines/second)\nPhysical Source Lines of Code (SLOC) = 41\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 24.3902 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
541§True§"collected_code/problem-541-0.c:23:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-541-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.01 seconds (3470 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
542§False§"collected_code/problem-542-0.c:8:24: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    regreplace(&regex, str, "":"", str, 0);\n                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-542-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (1877 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-542-0.c: In function 'replace_chars':\ncollected_code/problem-542-0.c:8:5: warning: implicit declaration of function 'regreplace' [-Wimplicit-function-declaration]\n    8 |     regreplace(&regex, str, "":"", str, 0);\n      |     ^~~~~~~~~~\nUndefined symbols for architecture x86_64:\n  ""_regreplace"", referenced from:\n      _replace_chars in ccsMHrZa.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
543§True§"collected_code/problem-543-0.c:24:21: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                    ^\ncollected_code/problem-543-0.c:24:28: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-543-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (3971 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
544§True§"collected_code/problem-544-0.c:10:17: error: Cannot determine that 'num[0]' is initialized [premium-bughuntingUninit]\n        sprintf(num, ""%d"", tuple[i]);\n                ^\ncollected_code/problem-544-0.c:10:33: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sprintf(num, ""%d"", tuple[i]);\n                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-544-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-544-0.c:11:  [4] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused).\ncollected_code/problem-544-0.c:9:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-544-0.c:10:  [2] (buffer) sprintf:\n  Does not check for buffer overflows (CWE-120). Use sprintf_s, snprintf, or\n  vsnprintf. Risk is low because the source has a constant maximum length.\ncollected_code/problem-544-0.c:13:  [1] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused). Risk is low because the\n  source is a constant character.\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 25 in approximately 0.01 seconds (3379 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   1 [2]   2 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   4 [2+]   3 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 208.333 [1+] 166.667 [2+] 125 [3+] 41.6667 [4+] 41.6667 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-544-0.c: In function 'flattenTuple':\ncollected_code/problem-544-0.c:7:10: warning: dereference of possibly-NULL 'str' [CWE-690] [-Wanalyzer-possible-null-dereference]\n    7 |     *str = '\0';\n      |     ~~~~~^~~~~~\n  'flattenTuple': events 1-2\n    |\n    |    6 |     char* str = malloc(size * sizeof(char));\n    |      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                 |\n    |      |                 (1) this call could return NULL\n    |    7 |     *str = '\0';\n    |      |     ~~~~~~~~~~~  \n    |      |          |\n    |      |          (2) 'str' could be NULL: unchecked value from (1)\n    |\n
545§True§collected_code/problem-545-0.c:7:28: error: Signed integer overflow for expression '1<<(num_bits-1)'. [integerOverflow]\n    unsigned int mask = (1 << (num_bits - 1)) | 1;\n                           ^\ncollected_code/problem-545-0.c:5:41: note: Assignment 'num_bits=sizeof(unsigned int)*8', assigned value is 32\n    int num_bits = sizeof(unsigned int) * 8;\n                                        ^\ncollected_code/problem-545-0.c:7:28: note: Integer overflow\n    unsigned int mask = (1 << (num_bits - 1)) | 1;\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-545-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2203 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
546§True§collected_code/problem-546-0.c:6:12: error: Cannot determine that '*str' is initialized [premium-bughuntingUninit]\n    while (*str != '\0') {\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-546-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3619 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
547§True§"collected_code/problem-547-0.c:30:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-547-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.02 seconds (2166 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
548§True§collected_code/problem-548-0.c:14:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j] && lis[i] < lis[j] + 1)\n                   ^\ncollected_code/problem-548-0.c:14:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j] && lis[i] < lis[j] + 1)\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-548-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.26 seconds (110 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
549§True§Checking collected_code/problem-549-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-549-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (2819 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
550§True§collected_code/problem-550-0.c:6:19: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return arr[low];\n                  ^\ncollected_code/problem-550-0.c:10:12: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[low] == arr[high]) {\n           ^\ncollected_code/problem-550-0.c:10:24: error: Cannot determine that 'arr[high]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[low] == arr[high]) {\n                       ^\ncollected_code/problem-550-0.c:11:19: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return arr[low];\n                  ^\ncollected_code/problem-550-0.c:18:12: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[mid] > arr[mid + 1]) {\n           ^\ncollected_code/problem-550-0.c:18:23: error: Cannot determine that 'arr[mid+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[mid] > arr[mid + 1]) {\n                      ^\ncollected_code/problem-550-0.c:19:19: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return arr[mid];\n                  ^\ncollected_code/problem-550-0.c:23:12: error: Cannot determine that 'arr[low]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[low] <= arr[mid]) {\n           ^\ncollected_code/problem-550-0.c:23:24: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[low] <= arr[mid]) {\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-550-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.37 seconds (100 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
551§True§"collected_code/problem-551-0.c:5:30: error: Cannot determine that 'list[i][column]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", list[i][column]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-551-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2418 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
552§True§collected_code/problem-552-0.c:9:25: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int difference = arr[1] - arr[0];\n                        ^\ncollected_code/problem-552-0.c:9:34: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int difference = arr[1] - arr[0];\n                                 ^\ncollected_code/problem-552-0.c:12:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] - arr[i-1] != difference) {\n               ^\ncollected_code/problem-552-0.c:12:25: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] - arr[i-1] != difference) {\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-552-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.43 seconds (70 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
553§True§collected_code/problem-553-0.c:4:28: error: Cannot determine that 'tuple[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int integerPart = tuple[0];\n                           ^\ncollected_code/problem-553-0.c:5:28: error: Cannot determine that 'tuple[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int decimalPart = tuple[1];\n                           ^\ncollected_code/problem-553-0.c:6:27: error: Cannot determine that 'tuple[2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int powerOfTen = tuple[2];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-553-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.31 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
554§True§"collected_code/problem-554-0.c:7:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(arr[i] % 2 != 0) {\n              ^\ncollected_code/problem-554-0.c:8:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", arr[i]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-554-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.53 seconds (36 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 133.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
555§True§"collected_code/problem-555-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-555-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3168 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
556§True§"collected_code/problem-556-0.c:8:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if ((arr[i] ^ arr[j]) % 2 == 1)\n                    ^\ncollected_code/problem-556-0.c:8:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if ((arr[i] ^ arr[j]) % 2 == 1)\n                             ^\ncollected_code/problem-556-0.c:19:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-556-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.01 seconds (2110 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 208.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
557§True§collected_code/problem-557-0.c:6:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i] != '\0') {\n              ^\ncollected_code/problem-557-0.c:7:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] >= 'a' && str[i] <= 'z') {\n               ^\ncollected_code/problem-557-0.c:8:25: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[i] = str[i] - 32; // Convert lowercase to uppercase\n                        ^\ncollected_code/problem-557-0.c:10:21: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (str[i] >= 'A' && str[i] <= 'Z') {\n                    ^\ncollected_code/problem-557-0.c:11:25: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[i] = str[i] + 32; // Convert uppercase to lowercase\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-557-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.45 seconds (57 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
558§True§"collected_code/problem-558-0.c:23:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-558-0.c:26:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-558-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.01 seconds (4311 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 227.273 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-558-0.c: In function 'digit_distance':\ncollected_code/problem-558-0.c:10:21: warning: implicit declaration of function 'abs' [-Wimplicit-function-declaration]\n   10 |         distance += abs(digit1 - digit2);\n      |                     ^~~\ncollected_code/problem-558-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'abs'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \n
559§True§collected_code/problem-559-0.c:5:26: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max_current = arr[0];\n                         ^\ncollected_code/problem-559-0.c:6:25: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max_global = arr[0];\n                        ^\ncollected_code/problem-559-0.c:10:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        max_current = (arr[i] > max_current + arr[i]) ? arr[i] : max_current + arr[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-559-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.24 seconds (100 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
560§True§collected_code/problem-560-0.c:11:28: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        union_arr[i] = arr1[i];\n                           ^\ncollected_code/problem-560-0.c:20:20: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(arr2[j] == union_arr[k])\n                   ^\ncollected_code/problem-560-0.c:29:32: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            union_arr[i] = arr2[j];\n                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-560-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 52 in approximately 0.47 seconds (110 lines/second)\nPhysical Source Lines of Code (SLOC) = 41\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 48.7805 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
561§False§collected_code/problem-561-0.c:3:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i + 1] = arr[i];\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-561-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 4 in approximately 0.44 seconds (9 lines/second)\nPhysical Source Lines of Code (SLOC) = 5\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
562§True§collected_code/problem-562-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > arr[i-1]){\n               ^\ncollected_code/problem-562-0.c:8:25: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > arr[i-1]){\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-562-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (3808 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
563§True§Checking collected_code/problem-563-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-563-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (1933 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
564§True§collected_code/problem-564-0.c:8:17: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n         if (arr[i] != arr[j]) {\n                ^\ncollected_code/problem-564-0.c:8:27: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n         if (arr[i] != arr[j]) {\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-564-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.71 seconds (35 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
565§True§collected_code/problem-565-0.c:5:24: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n   int length = strlen(str);\n                       ^\ncollected_code/problem-565-0.c:18:10: error: Cannot determine that 'input[0]' is initialized [premium-bughuntingUninit]\n   fgets(input, sizeof(input), stdin);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-565-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-565-0.c:15:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-565-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-565-0.c:21:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-565-0.c:22:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 26 in approximately 0.75 seconds (35 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   3 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   4 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 388.889 [1+] 222.222 [2+] 55.5556 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
566§True§"collected_code/problem-566-0.c:18:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-566-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.66 seconds (37 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
567§True§collected_code/problem-567-0.c:5:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < arr[i-1]) {\n               ^\ncollected_code/problem-567-0.c:5:25: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < arr[i-1]) {\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-567-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3227 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
568§True§Checking collected_code/problem-568-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-568-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.37 seconds (102 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-568-0.c: In function 'createList':\ncollected_code/problem-568-0.c:13:23: warning: dereference of possibly-NULL 'current' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   13 |         current->next = (Dictionary*)malloc(sizeof(Dictionary));\n      |         ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'createList': events 1-4\n    |\n    |    9 |     Dictionary* head = (Dictionary*)malloc(sizeof(Dictionary));\n    |      |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                     |\n    |      |                                     (1) this call could return NULL\n    |......\n    |   12 |     for (int i = 0; i < num - 1; i++) {\n    |      |                     ~~~~~~~~~~~      \n    |      |                       |\n    |      |                       (2) following 'true' branch...\n    |   13 |         current->next = (Dictionary*)malloc(sizeof(Dictionary));\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |              |\n    |      |                       |              (3) ...to here\n    |      |                       (4) 'current' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-568-0.c:17:19: warning: dereference of possibly-NULL 'current' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   17 |     current->next = NULL;\n      |                   ^\n  'createList': events 1-2\n    |\n    |    9 |     Dictionary* head = (Dictionary*)malloc(sizeof(Dictionary));\n    |      |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                     |\n    |      |                                     (1) this call could return NULL\n    |......\n    |   12 |     for (int i = 0; i < num - 1; i++) {\n    |      |                     ~~~~~~~~~~~      \n    |      |                       |\n    |      |                       (2) following 'false' branch...\n    |\n  'createList': event 3\n    |\n    |   17 |     current->next = NULL;\n    |      |                   ^\n    |      |                   |\n    |      |                   (3) ...to here\n    |\n  'createList': event 4\n    |\n    |   17 |     current->next = NULL;\n    |      |                   ^\n    |      |                   |\n    |      |                   (4) 'current' could be NULL: unchecked value from (1)\n    |\n
569§False§collected_code/problem-569-0.c:13:19: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        qsort(list[i], listLengths[i], sizeof(char *), compare);\n                  ^\ncollected_code/problem-569-0.c:13:35: error: Cannot determine that 'listLengths[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        qsort(list[i], listLengths[i], sizeof(char *), compare);\n                                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-569-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (1661 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
570§True§collected_code/problem-570-0.c:8:33: error: Cannot determine that 'strings[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      for (j = k = 0; strings[i][j] != '\0'; j++) {\n                                ^\ncollected_code/problem-570-0.c:10:29: error: Cannot determine that 'characterOrString[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n         int limit = strlen(characterOrString);\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-570-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-570-0.c:10:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 39 in approximately 0.01 seconds (4521 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 64.5161 [1+] 32.2581 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-570-0.c: In function 'removeWords':\ncollected_code/problem-570-0.c:23:24: warning: write to string literal [-Wanalyzer-write-to-string-literal]\n   23 |          strings[i][k] = '\0';\n      |          ~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   28 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   33 |    removeWords(strings, size, characterOrString);\n    |      |    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |    |\n    |      |    (2) calling 'removeWords' from 'main'\n    |\n    +--> 'removeWords': events 3-12\n           |\n           |    4 | void removeWords(char** strings, int size, char* characterOrString) {\n           |      |      ^~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeWords'\n           |......\n           |    7 |    for (i = 0; i < size; i++) {\n           |      |                ~~~~~~~~\n           |      |                  |\n           |      |                  (4) following 'true' branch (when 'i < size')...\n           |    8 |       for (j = k = 0; strings[i][j] != '\0'; j++) {\n           |      |                ~~~~~  ~~~~~~~~~~~~~~~~~~~~~\n           |      |                  |                  |\n           |      |                  (5) ...to here     (6) following 'true' branch...\n           |    9 |          int match = 0;\n           |      |              ~~~~~\n           |      |              |\n           |      |              (7) ...to here\n           |......\n           |   12 |          while (strings[i][j] == characterOrString[match] && match < limit && strings[i][j] != '\0') {\n           |      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                                                            |\n           |      |                                                                            (8) following 'false' branch...\n           |......\n           |   17 |          if (match == limit) {\n           |      |             ~\n           |      |             |\n           |      |             (9) ...to here\n           |      |             (10) following 'false' branch (when 'match != limit')...\n           |......\n           |   23 |          strings[i][k] = '\0';\n           |      |          ~~~~~~~~~~~~~~~~~~~~\n           |      |                 |      |\n           |      |                 |      (12) write to string literal here\n           |      |                 (11) ...to here\n           |\n
571§True§Checking collected_code/problem-571-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-571-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.01 seconds (4855 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 32.2581 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
572§True§Checking collected_code/problem-572-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-572-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.51 seconds (67 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 68.9655 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
573§False§collected_code/problem-573-0.c:8:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (!visited[arr[i]]) {\n                        ^\ncollected_code/problem-573-0.c:9:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            visited[arr[i]] = true;\n                       ^\ncollected_code/problem-573-0.c:10:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            product *= arr[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-573-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (1857 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
574§True§"collected_code/problem-574-0.c:13:19: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &radius);\n                  ^\ncollected_code/problem-574-0.c:15:19: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &height);\n                  ^\ncollected_code/problem-574-0.c:17:35: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    double area = findSurfaceArea(radius, height);\n                                  ^\ncollected_code/problem-574-0.c:17:43: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    double area = findSurfaceArea(radius, height);\n                                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-574-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (2112 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 294.118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
575§True§"collected_code/problem-575-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-575-0.c:20:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-575-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3992 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 227.273 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
576§True§collected_code/problem-576-0.c:11:17: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr1[i] == arr2[j]) {\n                ^\ncollected_code/problem-576-0.c:11:28: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr1[i] == arr2[j]) {\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-576-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.44 seconds (93 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
577§True§"collected_code/problem-577-0.c:23:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-577-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (3367 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
578§True§"collected_code/problem-578-0.c:5:27: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr1[i]);\n                          ^\ncollected_code/problem-578-0.c:6:27: error: Cannot determine that 'arr2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr2[i]);\n                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-578-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2373 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
579§True§"collected_code/problem-579-0.c:13:22: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(tuple1[i] == tuple2[j])\n                     ^\ncollected_code/problem-579-0.c:13:35: error: Cannot determine that 'tuple2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(tuple1[i] == tuple2[j])\n                                  ^\ncollected_code/problem-579-0.c:21:33: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", tuple1[i]);\n                                ^\ncollected_code/problem-579-0.c:30:22: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(tuple2[i] == tuple1[j])\n                     ^\ncollected_code/problem-579-0.c:30:35: error: Cannot determine that 'tuple1[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if(tuple2[i] == tuple1[j])\n                                  ^\ncollected_code/problem-579-0.c:38:33: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", tuple2[i]);\n                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-579-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 52 in approximately 0.40 seconds (129 lines/second)\nPhysical Source Lines of Code (SLOC) = 47\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 42.5532 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
580§True§Checking collected_code/problem-580-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-580-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.23 seconds (158 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 35.7143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-580-0.c: In function 'extractEvenElements':\ncollected_code/problem-580-0.c:12:5: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n   12 |     extractEvenElements(*((void **)innerTuple));\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-3\n    |\n    |   22 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   23 |   int num1 = 1;\n    |      |       ~~~~\n    |      |       |\n    |      |       (2) capacity: 4 bytes\n    |......\n    |   34 |   extractEvenElements(tuple);\n    |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |   |\n    |      |   (3) calling 'extractEvenElements' from 'main'\n    |\n    +--> 'extractEvenElements': events 4-6\n           |\n           |    3 | void extractEvenElements(void *tuple) {\n           |      |      ^~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'extractEvenElements'\n           |    4 |   if (tuple == NULL)\n           |      |      ~\n           |      |      |\n           |      |      (5) following 'false' branch (when 'tuple' is non-NULL)...\n           |......\n           |    9 |   innerTuple = *(void **)tuple;\n           |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |              |\n           |      |              (6) ...to here\n           |\n         'extractEvenElements': events 7-9\n           |\n           |   11 |   while (innerTuple != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (7) following 'true' branch (when 'innerTuple' is non-NULL)...\n           |   12 |     extractEvenElements(*((void **)innerTuple));\n           |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (8) ...to here\n           |      |     (9) out-of-bounds read from byte 4 till byte 7 but 'num1' ends at byte 4\n           |\ncollected_code/problem-580-0.c:12:5: note: read of 4 bytes from after the end of 'num1'\n   12 |     extractEvenElements(*((void **)innerTuple));\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncollected_code/problem-580-0.c:14:12: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n   14 |     number = *(int **)(innerTuple + sizeof(void *));\n      |     ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-3\n    |\n    |   22 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   23 |   int num1 = 1;\n    |      |       ~~~~\n    |      |       |\n    |      |       (2) capacity: 4 bytes\n    |......\n    |   34 |   extractEvenElements(tuple);\n    |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |   |\n    |      |   (3) calling 'extractEvenElements' from 'main'\n    |\n    +--> 'extractEvenElements': events 4-6\n           |\n           |    3 | void extractEvenElements(void *tuple) {\n           |      |      ^~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'extractEvenElements'\n           |    4 |   if (tuple == NULL)\n           |      |      ~\n           |      |      |\n           |      |      (5) following 'false' branch (when 'tuple' is non-NULL)...\n           |......\n           |    9 |   innerTuple = *(void **)tuple;\n           |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |              |\n           |      |              (6) ...to here\n           |\n         'extractEvenElements': events 7-9\n           |\n           |   11 |   while (innerTuple != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (7) following 'true' branch (when 'innerTuple' is non-NULL)...\n           |   12 |     extractEvenElements(*((void **)innerTuple));\n           |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (8) ...to here\n           |   13 | \n           |   14 |     number = *(int **)(innerTuple + sizeof(void *));\n           |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |            |\n           |      |            (9) out-of-bounds read from byte 8 till byte 15 but 'num1' ends at byte 4\n           |\ncollected_code/problem-580-0.c:14:12: note: read of 8 bytes from after the end of 'num1'\n   14 |     number = *(int **)(innerTuple + sizeof(void *));\n      |     ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncollected_code/problem-580-0.c:18:16: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]\n   18 |     innerTuple = *(void **)(innerTuple + sizeof(void *) + sizeof(int *));\n      |     ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-3\n    |\n    |   22 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   23 |   int num1 = 1;\n    |      |       ~~~~\n    |      |       |\n    |      |       (2) capacity: 4 bytes\n    |......\n    |   34 |   extractEvenElements(tuple);\n    |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |   |\n    |      |   (3) calling 'extractEvenElements' from 'main'\n    |\n    +--> 'extractEvenElements': events 4-6\n           |\n           |    3 | void extractEvenElements(void *tuple) {\n           |      |      ^~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'extractEvenElements'\n           |    4 |   if (tuple == NULL)\n           |      |      ~\n           |      |      |\n           |      |      (5) following 'false' branch (when 'tuple' is non-NULL)...\n           |......\n           |    9 |   innerTuple = *(void **)tuple;\n           |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |              |\n           |      |              (6) ...to here\n           |\n         'extractEvenElements': events 7-9\n           |\n           |   11 |   while (innerTuple != NULL) {\n           |      |                     ^\n           |      |                     |\n           |      |                     (7) following 'true' branch (when 'innerTuple' is non-NULL)...\n           |   12 |     extractEvenElements(*((void **)innerTuple));\n           |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (8) ...to here\n           |......\n           |   18 |     innerTuple = *(void **)(innerTuple + sizeof(void *) + sizeof(int *));\n           |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                |\n           |      |                (9) out-of-bounds read from byte 16 till byte 23 but 'num1' ends at byte 4\n           |\ncollected_code/problem-580-0.c:18:16: note: read of 8 bytes from after the end of 'num1'\n   18 |     innerTuple = *(void **)(innerTuple + sizeof(void *) + sizeof(int *));\n      |     ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n
581§True§"collected_code/problem-581-0.c:16:19: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &sideLength);\n                  ^\ncollected_code/problem-581-0.c:18:19: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &height);\n                  ^\ncollected_code/problem-581-0.c:20:46: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    double area = surfaceAreaOfSquarePyramid(sideLength, height);\n                                             ^\ncollected_code/problem-581-0.c:20:58: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    double area = surfaceAreaOfSquarePyramid(sideLength, height);\n                                                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-581-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2160 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 277.778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
582§True§Checking collected_code/problem-582-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-582-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.04 seconds (629 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
583§True§"collected_code/problem-583-0.c:25:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%u"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-583-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.13 seconds (230 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
584§True§collected_code/problem-584-0.c:23:17: error: Cannot determine that 'adverb[0]' is initialized [premium-bughuntingUninit]\n        strncpy(adverb, sentence + position, match.rm_eo - match.rm_so);\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-584-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-584-0.c:22:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-584-0.c:23:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 40 in approximately 0.02 seconds (1999 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   2 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 153.846 [1+] 76.9231 [2+] 38.4615 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-584-0.c: In function 'findAdverbs':\ncollected_code/problem-584-0.c:23:9: warning: implicit declaration of function 'strncpy' [-Wimplicit-function-declaration]\n   23 |         strncpy(adverb, sentence + position, match.rm_eo - match.rm_so);\n      |         ^~~~~~~\ncollected_code/problem-584-0.c:3:1: note: include '<string.h>' or provide a declaration of 'strncpy'\n    2 | #include <regex.h>\n  +++ |+#include <string.h>\n    3 | \ncollected_code/problem-584-0.c:23:9: warning: incompatible implicit declaration of built-in function 'strncpy' [-Wbuiltin-declaration-mismatch]\n   23 |         strncpy(adverb, sentence + position, match.rm_eo - match.rm_so);\n      |         ^~~~~~~\ncollected_code/problem-584-0.c:23:9: note: include '<string.h>' or provide a declaration of 'strncpy'\n
585§True§"collected_code/problem-585-0.c:50:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\ncollected_code/problem-585-0.c:53:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-585-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 67 in approximately 0.01 seconds (6132 lines/second)\nPhysical Source Lines of Code (SLOC) = 47\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.936 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-585-0.c: In function 'heapify':\ncollected_code/problem-585-0.c:23:33: warning: use of uninitialized value '*arr_33(D) + _4.price' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   23 |     if (left < size && arr[left].price > arr[largest].price)\n      |                        ~~~~~~~~~^~~~~~\n  'main': events 1-5\n    |\n    |   46 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   55 |     Item* arr = (Item*)malloc(size * sizeof(Item));\n    |      |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                        |\n    |      |                        (2) region created on heap here\n    |   56 | \n    |   57 |     for (int i = 0; i < size; i++) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (3) following 'false' branch...\n    |......\n    |   63 |     findExpensiveItems(arr, n, size);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (4) ...to here\n    |      |     (5) calling 'findExpensiveItems' from 'main'\n    |\n    +--> 'findExpensiveItems': events 6-9\n           |\n           |   36 | void findExpensiveItems(Item arr[], int n, int size) {\n           |      |      ^~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (6) entry to 'findExpensiveItems'\n           |   37 |     for (int i = n / 2 - 1; i >= 0; i--)\n           |      |                             ~~~~~~\n           |      |                               |\n           |      |                               (7) following 'true' branch (when 'i >= 0')...\n           |   38 |         heapify(arr, size, i);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (8) ...to here\n           |      |         (9) calling 'heapify' from 'findExpensiveItems'\n           |\n           +--> 'heapify': events 10-13\n                  |\n                  |   18 | void heapify(Item arr[], int size, int i) {\n                  |      |      ^~~~~~~\n                  |      |      |\n                  |      |      (10) entry to 'heapify'\n                  |......\n                  |   23 |     if (left < size && arr[left].price > arr[largest].price)\n                  |      |        ~               ~~~~~~~~~~~~~~~\n                  |      |        |                  |     |\n                  |      |        |                  |     (13) use of uninitialized value '*arr_33(D) + _4.price' here\n                  |      |        |                  (12) ...to here\n                  |      |        (11) following 'true' branch (when 'left < size')...\n                  |\ncollected_code/problem-585-0.c:26:35: warning: use of uninitialized value '*arr_33(D) + _12.price' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   26 |     if (right < size && arr[right].price > arr[largest].price)\n      |                         ~~~~~~~~~~^~~~~~\n  'main': events 1-5\n    |\n    |   46 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   55 |     Item* arr = (Item*)malloc(size * sizeof(Item));\n    |      |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                        |\n    |      |                        (2) region created on heap here\n    |   56 | \n    |   57 |     for (int i = 0; i < size; i++) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (3) following 'false' branch...\n    |......\n    |   63 |     findExpensiveItems(arr, n, size);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (4) ...to here\n    |      |     (5) calling 'findExpensiveItems' from 'main'\n    |\n    +--> 'findExpensiveItems': events 6-9\n           |\n           |   36 | void findExpensiveItems(Item arr[], int n, int size) {\n           |      |      ^~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (6) entry to 'findExpensiveItems'\n           |   37 |     for (int i = n / 2 - 1; i >= 0; i--)\n           |      |                             ~~~~~~\n           |      |                               |\n           |      |                               (7) following 'true' branch (when 'i >= 0')...\n           |   38 |         heapify(arr, size, i);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~\n           |      |         |\n           |      |         (8) ...to here\n           |      |         (9) calling 'heapify' from 'findExpensiveItems'\n           |\n           +--> 'heapify': events 10-15\n                  |\n                  |   18 | void heapify(Item arr[], int size, int i) {\n                  |      |      ^~~~~~~\n                  |      |      |\n                  |      |      (10) entry to 'heapify'\n                  |......\n                  |   23 |     if (left < size && arr[left].price > arr[largest].price)\n                  |      |        ~\n                  |      |        |\n                  |      |        (11) following 'false' branch (when 'left >= size')...\n                  |......\n                  |   26 |     if (right < size && arr[right].price > arr[largest].price)\n                  |      |        ~                ~~~~~~~~~~~~~~~~\n                  |      |        |                   |      |\n                  |      |        |                   |      (15) use of uninitialized value '*arr_33(D) + _12.price' here\n                  |      |        (12) ...to here     (14) ...to here\n                  |      |        (13) following 'true' branch (when 'right < size')...\n                  |\ncollected_code/problem-585-0.c: In function 'findExpensiveItems':\ncollected_code/problem-585-0.c:41:9: warning: use of uninitialized value '*arr_20(D) + _3.price' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   41 |         printf(""Item index: %d, Price: %d\n"", arr[i].index, arr[i].price);\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-5\n    |\n    |   46 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   55 |     Item* arr = (Item*)malloc(size * sizeof(Item));\n    |      |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                        |\n    |      |                        (2) region created on heap here\n    |   56 | \n    |   57 |     for (int i = 0; i < size; i++) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (3) following 'false' branch...\n    |......\n    |   63 |     findExpensiveItems(arr, n, size);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (4) ...to here\n    |      |     (5) calling 'findExpensiveItems' from 'main'\n    |\n    +--> 'findExpensiveItems': events 6-9\n           |\n           |   36 | void findExpensiveItems(Item arr[], int n, int size) {\n           |      |      ^~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (6) entry to 'findExpensiveItems'\n           |......\n           |   40 |     for (int i = size - 1; i >= size - n; i--) {\n           |      |                            ~~~~~~~~~~~~~\n           |      |                              |\n           |      |                              (7) following 'true' branch...\n           |   41 |         printf(""Item index: %d, Price: %d\n"", arr[i].index, arr[i].price);\n           |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |         |                                                      |\n           |      |         |                                                      (8) ...to here\n           |      |         (9) use of uninitialized value '*arr_20(D) + _3.price' here\n           |\ncollected_code/problem-585-0.c: In function 'main':\ncollected_code/problem-585-0.c:60:22: warning: dereference of possibly-NULL 'arr' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   60 |         arr[i].index = i + 1;\n      |         ~~~~~~~~~~~~~^~~~~~~\n  'main': events 1-4\n    |\n    |   55 |     Item* arr = (Item*)malloc(size * sizeof(Item));\n    |      |                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                        |\n    |      |                        (1) this call could return NULL\n    |   56 | \n    |   57 |     for (int i = 0; i < size; i++) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch...\n    |   58 |         printf(""Enter price for item %d: "", i + 1);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (3) ...to here\n    |   59 |         scanf(""%d"", &arr[i].price);\n    |   60 |         arr[i].index = i + 1;\n    |      |         ~~~~~~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (4) 'arr + (long unsigned int)i * 8' could be NULL: unchecked value from (1)\n    |\n"
586§True§collected_code/problem-586-0.c:15:18: warning: Uninitialized variable: temp [uninitvar]\n        arr[i] = temp[j];\n                 ^\ncollected_code/problem-586-0.c:6:23: note: Assuming condition is false\n    for (int i = 0; i < k; i++) {\n                      ^\ncollected_code/problem-586-0.c:15:18: note: Uninitialized variable: temp\n        arr[i] = temp[j];\n                 ^\ncollected_code/problem-586-0.c:7:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        temp[i] = arr[i];\n                     ^\ncollected_code/problem-586-0.c:11:21: error: Cannot determine that 'arr[i+k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i] = arr[i + k];\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-586-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.50 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
587§True§"collected_code/problem-587-0.c:40:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        insertNode(&head, arr[i]);\n                             ^\ncollected_code/problem-587-0.c:68:27: error: Cannot determine that 'tuple' is initialized [premium-bughuntingUninit]\n    convertToTuple(head, &tuple, &tupleSize);\n                          ^\ncollected_code/problem-587-0.c:68:35: error: Cannot determine that 'tupleSize' is initialized [premium-bughuntingUninit]\n    convertToTuple(head, &tuple, &tupleSize);\n                                  ^\ncollected_code/problem-587-0.c:71:25: error: Cannot determine that 'tupleSize' is initialized [premium-bughuntingUninit]\n    for (int i = 0; i < tupleSize; i++) {\n                        ^\ncollected_code/problem-587-0.c:72:23: error: Cannot determine that 'tuple' is initialized [premium-bughuntingUninit]\n        printf(""%d "", tuple[i]);\n                      ^\ncollected_code/problem-587-0.c:76:10: error: Cannot determine that 'tuple' is initialized [premium-bughuntingUninit]\n    free(tuple);\n         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-587-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 77 in approximately 0.01 seconds (8747 lines/second)\nPhysical Source Lines of Code (SLOC) = 67\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 74.6269 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-587-0.c: In function 'createNode':\ncollected_code/problem-587-0.c:11:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   11 |     newNode->data = value;\n      |     ~~~~~~~~~~~~~~^~~~~~~\n  'createNode': events 1-2\n    |\n    |   10 |     Node* newNode = (Node*)malloc(sizeof(Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |   11 |     newNode->data = value;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~   \n    |      |                   |\n    |      |                   (2) 'newNode' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-587-0.c: In function 'convertToTuple':\ncollected_code/problem-587-0.c:55:21: warning: dereference of possibly-NULL '*tuple' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   55 |         (*tuple)[i] = curr->data;\n      |         ~~~~~~~~~~~~^~~~~~~~~~~~\n  'convertToTuple': events 1-4\n    |\n    |   52 |     *tuple = (int*)malloc(*size * sizeof(int));\n    |      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                    |\n    |      |                    (1) this call could return NULL\n    |   53 |     curr = head;\n    |   54 |     for (int i = 0; i < *size; i++) {\n    |      |                     ~~~~~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch...\n    |   55 |         (*tuple)[i] = curr->data;\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |          |          |\n    |      |          |          (4) '*tuple + (long unsigned int)i * 4' could be NULL: unchecked value from (1)\n    |      |          (3) ...to here\n    |\n
588§True§collected_code/problem-588-0.c:5:20: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    min = max = arr[0];\n                   ^\ncollected_code/problem-588-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < min) {\n               ^\ncollected_code/problem-588-0.c:8:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min = arr[i];\n                     ^\ncollected_code/problem-588-0.c:10:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > max) {\n               ^\ncollected_code/problem-588-0.c:11:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = arr[i];\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-588-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.38 seconds (57 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
589§True§"collected_code/problem-589-0.c:19:18: error: Cannot determine that 'start' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &start);\n                 ^\ncollected_code/problem-589-0.c:21:18: error: Cannot determine that 'end' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &end);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-589-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.01 seconds (3250 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 300 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-589-0.c: In function 'findPerfectSquares':\ncollected_code/problem-589-0.c:7:26: warning: implicit declaration of function 'sqrt' [-Wimplicit-function-declaration]\n    7 |         int squareRoot = sqrt(i);\n      |                          ^~~~\ncollected_code/problem-589-0.c:2:1: note: include '<math.h>' or provide a declaration of 'sqrt'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-589-0.c:7:26: warning: incompatible implicit declaration of built-in function 'sqrt' [-Wbuiltin-declaration-mismatch]\n    7 |         int squareRoot = sqrt(i);\n      |                          ^~~~\ncollected_code/problem-589-0.c:7:26: note: include '<math.h>' or provide a declaration of 'sqrt'\n
590§True§"collected_code/problem-590-0.c:13:19: error: Cannot determine that 'r' is initialized [premium-bughuntingUninit]\n  scanf(""%f %f"", &r, &theta);\n                  ^\ncollected_code/problem-590-0.c:13:23: error: Cannot determine that 'theta' is initialized [premium-bughuntingUninit]\n  scanf(""%f %f"", &r, &theta);\n                      ^\ncollected_code/problem-590-0.c:15:22: error: Cannot determine that 'r' is initialized [premium-bughuntingUninit]\n  polarToRectangular(r, theta, &x, &y);\n                     ^\ncollected_code/problem-590-0.c:15:25: error: Cannot determine that 'theta' is initialized [premium-bughuntingUninit]\n  polarToRectangular(r, theta, &x, &y);\n                        ^\ncollected_code/problem-590-0.c:15:33: error: Cannot determine that 'x' is initialized [premium-bughuntingUninit]\n  polarToRectangular(r, theta, &x, &y);\n                                ^\ncollected_code/problem-590-0.c:15:37: error: Cannot determine that 'y' is initialized [premium-bughuntingUninit]\n  polarToRectangular(r, theta, &x, &y);\n                                    ^\ncollected_code/problem-590-0.c:17:49: error: Cannot determine that 'x' is initialized [premium-bughuntingUninit]\n  printf(""Rectangular coordinates: (%f, %f)\n"", x, y);\n                                                ^\ncollected_code/problem-590-0.c:17:52: error: Cannot determine that 'y' is initialized [premium-bughuntingUninit]\n  printf(""Rectangular coordinates: (%f, %f)\n"", x, y);\n                                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-590-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.36 seconds (53 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
591§True§collected_code/problem-591-0.c:4:19: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int temp = arr[0];\n                  ^\ncollected_code/problem-591-0.c:5:17: error: Cannot determine that 'arr[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    arr[0] = arr[size - 1];\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-591-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (3128 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 272.727 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
592§True§"collected_code/problem-592-0.c:30:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-592-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (3447 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
593§True§collected_code/problem-593-0.c:9:27: error: Cannot determine that 'ip_address[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; ip_address[i] != '\0'; i++) {\n                          ^\ncollected_code/problem-593-0.c:10:23: error: Cannot determine that 'ip_address[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (ip_address[i] != '0') {\n                      ^\ncollected_code/problem-593-0.c:15:27: error: Cannot determine that 'ip_address[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (j = 0; ip_address[i] != '\0'; i++, j++) {\n                          ^\ncollected_code/problem-593-0.c:16:35: error: Cannot determine that 'ip_address[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        ip_address[j] = ip_address[i];\n                                  ^\ncollected_code/problem-593-0.c:26:11: error: Cannot determine that 'ip_address[0]' is initialized [premium-bughuntingUninit]\n    fgets(ip_address, sizeof(ip_address), stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-593-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-593-0.c:23:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 35 in approximately 0.58 seconds (60 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 120 [1+]  40 [2+]  40 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
594§False§collected_code/problem-594-0.c:7:13: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (list[i] % 2 == 0 && even == -1) {\n            ^\ncollected_code/problem-594-0.c:8:18: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      even = list[i];\n                 ^\ncollected_code/problem-594-0.c:11:13: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (list[i] % 2 != 0 && odd == -1) {\n            ^\ncollected_code/problem-594-0.c:12:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      odd = list[i];\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-594-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.27 seconds (88 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
595§True§collected_code/problem-595-0.c:5:21: error: Cannot determine that 'str1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  int len1 = strlen(str1);\n                    ^\ncollected_code/problem-595-0.c:6:21: error: Cannot determine that 'str2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  int len2 = strlen(str2);\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-595-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-595-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-595-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 27 in approximately 0.01 seconds (3908 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 130.435 [1+] 86.9565 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
596§True§collected_code/problem-596-0.c:5:17: error: Cannot determine that 'tuple[size]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (tuple[size] != '\0') {\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-596-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.01 seconds (2301 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
597§True§collected_code/problem-597-0.c:8:17: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr1[i] < arr2[j]) {\n                ^\ncollected_code/problem-597-0.c:8:27: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr1[i] < arr2[j]) {\n                          ^\ncollected_code/problem-597-0.c:9:35: error: Cannot determine that 'arr1[i++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            merged[count++] = arr1[i++];\n                                  ^\ncollected_code/problem-597-0.c:12:35: error: Cannot determine that 'arr2[j++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            merged[count++] = arr2[j++];\n                                  ^\ncollected_code/problem-597-0.c:17:31: error: Cannot determine that 'arr1[i++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        merged[count++] = arr1[i++];\n                              ^\ncollected_code/problem-597-0.c:21:31: error: Cannot determine that 'arr2[j++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        merged[count++] = arr2[j++];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-597-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.01 seconds (5047 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 33.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
598§True§"collected_code/problem-598-0.c:35:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-598-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 43 in approximately 0.47 seconds (91 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 129.032 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-598-0.c: In function 'isArmstrong':\ncollected_code/problem-598-0.c:19:19: warning: implicit declaration of function 'pow' [-Wimplicit-function-declaration]\n   19 |         result += pow(remainder, digits);\n      |                   ^~~\ncollected_code/problem-598-0.c:2:1: note: include '<math.h>' or provide a declaration of 'pow'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-598-0.c:19:19: warning: incompatible implicit declaration of built-in function 'pow' [-Wbuiltin-declaration-mismatch]\n   19 |         result += pow(remainder, digits);\n      |                   ^~~\ncollected_code/problem-598-0.c:19:19: note: include '<math.h>' or provide a declaration of 'pow'\n
599§True§"collected_code/problem-599-0.c:20:16: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n  scanf(""%d"", &n);\n               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-599-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.25 seconds (97 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
600§True§"collected_code/problem-600-0.c:14:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-600-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (2477 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 235.294 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
601§True§collected_code/problem-601-0.c:12:25: error: Cannot determine that 'pairs[j][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (pairs[j][1] < pairs[i][0] && dp[i] < dp[j] + 1) {\n                        ^\ncollected_code/problem-601-0.c:12:39: error: Cannot determine that 'pairs[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (pairs[j][1] < pairs[i][0] && dp[i] < dp[j] + 1) {\n                                      ^\ncollected_code/problem-601-0.c:25:10: error: Cannot determine that 'dp[0]' is initialized [premium-bughuntingUninit]\n    free(dp);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-601-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.01 seconds (4721 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 33.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-601-0.c: In function 'maxChainLength':\ncollected_code/problem-601-0.c:7:15: warning: dereference of possibly-NULL 'dp' [CWE-690] [-Wanalyzer-possible-null-dereference]\n    7 |         dp[i] = 1;\n      |         ~~~~~~^~~\n  'maxChainLength': events 1-4\n    |\n    |    5 |     int* dp = (int*)malloc(n * sizeof(int));\n    |      |                     ^~~~~~~~~~~~~~~~~~~~~~~\n    |      |                     |\n    |      |                     (1) this call could return NULL\n    |    6 |     for (int i = 0; i < n; i++) {\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < n')...\n    |    7 |         dp[i] = 1;\n    |      |         ~~~~~~~~~    \n    |      |           |   |\n    |      |           |   (4) 'dp + (long unsigned int)i * 4' could be NULL: unchecked value from (1)\n    |      |           (3) ...to here\n    |\n
602§True§collected_code/problem-602-0.c:6:27: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; string[i] != '\0'; i++) {\n                          ^\ncollected_code/problem-602-0.c:7:25: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (count[string[i]] == 1)\n                        ^\ncollected_code/problem-602-0.c:8:26: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            return string[i];\n                         ^\ncollected_code/problem-602-0.c:10:21: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[string[i]]++;\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-602-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.30 seconds (74 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
603§True§"collected_code/problem-603-0.c:38:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-603-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 45 in approximately 0.33 seconds (137 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
604§True§collected_code/problem-604-0.c:9:10: error: Cannot determine that '*temp' is initialized [premium-bughuntingUninit]\n  while (*temp) {\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-604-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.32 seconds (126 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
605§False§Checking collected_code/problem-605-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-605-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.28 seconds (54 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
606§False§"collected_code/problem-606-0.c:11:19: error: Cannot determine that 'degrees' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &degrees);\n                  ^\ncollected_code/problem-606-0.c:12:39: error: Cannot determine that 'degrees' is initialized [premium-bughuntingUninit]\n    double radians = degreesToRadians(degrees);\n                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-606-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (2303 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 230.769 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-606-0.c: In function 'degreesToRadians':\ncollected_code/problem-606-0.c:4:33: error: 'M_PI' undeclared (first use in this function)\n    4 |     double radians = degrees * (M_PI/180);\n      |                                 ^~~~\ncollected_code/problem-606-0.c:4:33: note: each undeclared identifier is reported only once for each function it appears in\n
607§True§collected_code/problem-607-0.c:7:34: error: Cannot determine that 'pattern[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int result = regcomp(&regex, pattern, REG_EXTENDED);\n                                 ^\ncollected_code/problem-607-0.c:14:30: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    result = regexec(&regex, string, 1, &match, 0);\n                             ^\ncollected_code/problem-607-0.c:23:34: error: Cannot determine that 'error_message[0]' is initialized [premium-bughuntingUninit]\n        regerror(result, &regex, error_message, sizeof(error_message));\n                                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-607-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-607-0.c:22:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 36 in approximately 0.36 seconds (101 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 156.25 [1+] 31.25 [2+] 31.25 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
608§False§collected_code/problem-608-0.c:22:69: error: syntax error: number .  [syntaxError]\nNote: Replace `n` with the desired value to find the nth Bell number.\n                                                                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-608-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.02 seconds (1381 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-608-0.c:22:5: error: expected '=', ',', ';', 'asm' or '__attribute__' before ':' token\n   22 | Note: Replace `n` with the desired value to find the nth Bell number.\n      |     ^\ncollected_code/problem-608-0.c:22:15: error: stray '`' in program\n   22 | Note: Replace `n` with the desired value to find the nth Bell number.\n      |               ^\ncollected_code/problem-608-0.c:22:17: error: stray '`' in program\n   22 | Note: Replace `n` with the desired value to find the nth Bell number.\n      |                 ^\n
609§True§collected_code/problem-609-0.c:4:36: error: Cannot determine that 'periodicFunction[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int minValue = periodicFunction[0];\n                                   ^\ncollected_code/problem-609-0.c:6:29: error: Cannot determine that 'periodicFunction[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (periodicFunction[i] < minValue) {\n                            ^\ncollected_code/problem-609-0.c:7:40: error: Cannot determine that 'periodicFunction[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            minValue = periodicFunction[i];\n                                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-609-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.38 seconds (50 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
610§True§Checking collected_code/problem-610-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-610-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 88 in approximately 0.55 seconds (161 lines/second)\nPhysical Source Lines of Code (SLOC) = 61\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 98.3607 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-610-0.c: In function 'removeKthElement':\ncollected_code/problem-610-0.c:20:9: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   20 |         free(temp);\n      |         ^~~~\ncollected_code/problem-610-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'free'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-610-0.c:20:9: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\n   20 |         free(temp);\n      |         ^~~~\ncollected_code/problem-610-0.c:20:9: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-610-0.c:44:5: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\n   44 |     free(current);\n      |     ^~~~\ncollected_code/problem-610-0.c:44:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-610-0.c: In function 'main':\ncollected_code/problem-610-0.c:53:26: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   53 |     head = (struct Node*)malloc(sizeof(struct Node));\n      |                          ^~~~~~\ncollected_code/problem-610-0.c:53:26: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-610-0.c:53:26: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-610-0.c:53:26: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-610-0.c: In function 'removeKthElement':\ncollected_code/problem-610-0.c:43:20: warning: dereference of NULL 'previous' [CWE-476] [-Wanalyzer-null-dereference]\n   43 |     previous->next = current->next;\n      |     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n  'removeKthElement': events 1-10\n    |\n    |   12 |     if (*head == NULL || k <= 0) {\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch...\n    |......\n    |   17 |     if (k == 1) {\n    |      |        ~\n    |      |        |\n    |      |        (2) ...to here\n    |      |        (3) following 'false' branch (when 'k != 1')...\n    |......\n    |   25 |     struct Node* current = *head;\n    |      |                  ~~~~~~~\n    |      |                  |\n    |      |                  (4) ...to here\n    |   26 |     struct Node* previous = NULL;\n    |      |                  ~~~~~~~~\n    |      |                  |\n    |      |                  (5) 'previous' is NULL\n    |   27 | \n    |   28 |     for (int i = 1; i < k; i++) {\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (6) following 'false' branch (when 'i >= k')...\n    |......\n    |   38 |     if (current == NULL) {\n    |      |        ~\n    |      |        |\n    |      |        (7) ...to here\n    |      |        (8) following 'false' branch (when 'current' is non-NULL)...\n    |......\n    |   43 |     previous->next = current->next;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                    |        |\n    |      |                    |        (9) ...to here\n    |      |                    (10) dereference of NULL 'previous'\n    |\ncollected_code/problem-610-0.c: In function 'main':\ncollected_code/problem-610-0.c:57:16: warning: dereference of possibly-NULL 'head' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   57 |     head->data = 1;\n      |     ~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   53 |     head = (struct Node*)malloc(sizeof(struct Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |......\n    |   57 |     head->data = 1;\n    |      |     ~~~~~~~~~~~~~~        \n    |      |                |\n    |      |                (2) 'head' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-610-0.c:60:18: warning: dereference of possibly-NULL 'second' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   60 |     second->data = 2;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   54 |     second = (struct Node*)malloc(sizeof(struct Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |......\n    |   60 |     second->data = 2;\n    |      |     ~~~~~~~~~~~~~~~~        \n    |      |                  |\n    |      |                  (2) 'second' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-610-0.c:63:17: warning: dereference of possibly-NULL 'third' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   63 |     third->data = 3;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   55 |     third = (struct Node*)malloc(sizeof(struct Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |......\n    |   63 |     third->data = 3;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'third' could be NULL: unchecked value from (1)\n    |\n
611§True§Checking collected_code/problem-611-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-611-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 47 in approximately 0.65 seconds (73 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 28.5714 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
612§True§Checking collected_code/problem-612-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-612-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 59 in approximately 0.01 seconds (5546 lines/second)\nPhysical Source Lines of Code (SLOC) = 46\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 21.7391 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-612-0.c: In function 'main':\ncollected_code/problem-612-0.c:41:17: warning: dereference of possibly-NULL 'node1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   41 |     node1->data = 1;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   37 |     struct Node* node1 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                        |\n    |      |                                        (1) this call could return NULL\n    |......\n    |   41 |     node1->data = 1;\n    |      |     ~~~~~~~~~~~~~~~                     \n    |      |                 |\n    |      |                 (2) 'node1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-612-0.c:43:17: warning: dereference of possibly-NULL 'node2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   43 |     node2->data = 2;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   38 |     struct Node* node2 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                        |\n    |      |                                        (1) this call could return NULL\n    |......\n    |   43 |     node2->data = 2;\n    |      |     ~~~~~~~~~~~~~~~                     \n    |      |                 |\n    |      |                 (2) 'node2' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-612-0.c:45:17: warning: dereference of possibly-NULL 'node3' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   45 |     node3->data = 3;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   39 |     struct Node* node3 = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                        |\n    |      |                                        (1) this call could return NULL\n    |......\n    |   45 |     node3->data = 3;\n    |      |     ~~~~~~~~~~~~~~~                     \n    |      |                 |\n    |      |                 (2) 'node3' could be NULL: unchecked value from (1)\n    |\n
613§True§collected_code/problem-613-0.c:4:27: error: Cannot determine that 'tuples[0][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int maxVal = tuples[0][1];\n                          ^\ncollected_code/problem-613-0.c:6:22: error: Cannot determine that 'tuples[i][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuples[i][1] > maxVal) {\n                     ^\ncollected_code/problem-613-0.c:7:31: error: Cannot determine that 'tuples[i][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            maxVal = tuples[i][1];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-613-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.02 seconds (1127 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
614§True§collected_code/problem-614-0.c:6:25: error: Cannot determine that 'tupleList[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += tupleList[i];\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-614-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.46 seconds (35 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
615§True§collected_code/problem-615-0.c:9:29: error: Cannot determine that 'tuples[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += tuples[i][j];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-615-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.32 seconds (79 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
616§True§collected_code/problem-616-0.c:6:27: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        tuple1[i] = tuple1[i] % tuple2[i];\n                          ^\ncollected_code/problem-616-0.c:6:39: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        tuple1[i] = tuple1[i] % tuple2[i];\n                                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-616-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (1742 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
617§True§"collected_code/problem-617-0.c:22:18: error: Cannot determine that 'd' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &d);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-617-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3675 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
618§True§Checking collected_code/problem-618-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-618-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 58 in approximately 0.01 seconds (7066 lines/second)\nPhysical Source Lines of Code (SLOC) = 47\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 21.2766 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-618-0.c: In function 'divideLists':\ncollected_code/problem-618-0.c:13:33: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   13 |         Node* newNode = (Node*) malloc(sizeof(Node));\n      |                                 ^~~~~~\ncollected_code/problem-618-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-618-0.c:13:33: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   13 |         Node* newNode = (Node*) malloc(sizeof(Node));\n      |                                 ^~~~~~\ncollected_code/problem-618-0.c:13:33: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-618-0.c: In function 'main':\ncollected_code/problem-618-0.c:39:27: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   39 |     Node* list1 = (Node*) malloc(sizeof(Node));\n      |                           ^~~~~~\ncollected_code/problem-618-0.c:39:27: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-618-0.c: In function 'divideLists':\ncollected_code/problem-618-0.c:14:23: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   14 |         newNode->next = NULL;\n      |                       ^\n  'divideLists': events 1-3\n    |\n    |   12 |     while (list1 != NULL && list2 != NULL) {\n    |      |                          ^\n    |      |                          |\n    |      |                          (1) following 'true' branch...\n    |   13 |         Node* newNode = (Node*) malloc(sizeof(Node));\n    |      |                                 ~~~~~~~~~~~~~~~~~~~~\n    |      |                                 |\n    |      |                                 (2) ...to here\n    |      |                                 (3) this call could return NULL\n    |\n  'divideLists': event 4\n    |\n    |   14 |         newNode->next = NULL;\n    |      |                       ^\n    |      |                       |\n    |      |                       (4) 'newNode' could be NULL: unchecked value from (3)\n    |\ncollected_code/problem-618-0.c: In function 'main':\ncollected_code/problem-618-0.c:42:17: warning: dereference of possibly-NULL 'list1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   42 |     list1->data = 10;\n      |     ~~~~~~~~~~~~^~~~\n  'main': events 1-2\n    |\n    |   39 |     Node* list1 = (Node*) malloc(sizeof(Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |......\n    |   42 |     list1->data = 10;\n    |      |     ~~~~~~~~~~~~~~~~       \n    |      |                 |\n    |      |                 (2) 'list1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-618-0.c:43:17: warning: dereference of possibly-NULL 'list2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   43 |     list2->data = 5;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   40 |     Node* list2 = (Node*) malloc(sizeof(Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |......\n    |   43 |     list2->data = 5;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'list2' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-618-0.c:46:23: warning: dereference of possibly-NULL '*list1.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   46 |     list1->next->data = 20;\n      |     ~~~~~~~~~~~~~~~~~~^~~~\n  'main': events 1-2\n    |\n    |   44 |     list1->next = (Node*) malloc(sizeof(Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |   45 |     list2->next = (Node*) malloc(sizeof(Node));\n    |   46 |     list1->next->data = 20;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~ \n    |      |                       |\n    |      |                       (2) '*list1.next' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-618-0.c:47:23: warning: dereference of possibly-NULL '*list2.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   47 |     list2->next->data = 10;\n      |     ~~~~~~~~~~~~~~~~~~^~~~\n  'main': events 1-2\n    |\n    |   45 |     list2->next = (Node*) malloc(sizeof(Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |   46 |     list1->next->data = 20;\n    |   47 |     list2->next->data = 10;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~ \n    |      |                       |\n    |      |                       (2) '*list2.next' could be NULL: unchecked value from (1)\n    |\n
619§False§collected_code/problem-619-0.c:6:18: error: Cannot determine that 'string[index]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (string[index] != '\0') {\n                 ^\ncollected_code/problem-619-0.c:7:27: error: Cannot determine that 'string[index]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (isdigit(string[index])) {\n                          ^\ncollected_code/problem-619-0.c:8:38: error: Cannot determine that 'string[index]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            string[numIndex] = string[index];\n                                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-619-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-619-0.c:4:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 14 in approximately 0.02 seconds (748 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   0 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+] 76.9231 [2+] 76.9231 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-619-0.c: In function 'moveNumbersToString':\ncollected_code/problem-619-0.c:7:13: warning: implicit declaration of function 'isdigit' [-Wimplicit-function-declaration]\n    7 |         if (isdigit(string[index])) {\n      |             ^~~~~~~\ncollected_code/problem-619-0.c:1:1: note: include '<ctype.h>' or provide a declaration of 'isdigit'\n  +++ |+#include <ctype.h>\n    1 | void moveNumbersToString(char *string) {\nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
620§True§collected_code/problem-620-0.c:23:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] % arr[j] == 0 && subsetSize[i] < subsetSize[j] + 1)\n                   ^\ncollected_code/problem-620-0.c:23:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] % arr[j] == 0 && subsetSize[i] < subsetSize[j] + 1)\n                            ^\ncollected_code/problem-620-0.c:42:24: error: Cannot determine that 'arr[currentIndex]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        subset[i] = arr[currentIndex];\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-620-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 64 in approximately 0.46 seconds (139 lines/second)\nPhysical Source Lines of Code (SLOC) = 53\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.7358 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-620-0.c: In function 'largestDivisibleSubset':\ncollected_code/problem-620-0.c:10:23: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   10 |     int *subsetSize = malloc(sizeof(int)*n);\n      |                       ^~~~~~\ncollected_code/problem-620-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include<stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-620-0.c:10:23: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   10 |     int *subsetSize = malloc(sizeof(int)*n);\n      |                       ^~~~~~\ncollected_code/problem-620-0.c:10:23: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-620-0.c:52:5: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   52 |     free(subsetSize);\n      |     ^~~~\ncollected_code/problem-620-0.c:52:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-620-0.c:52:5: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-620-0.c:52:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-620-0.c:15:23: warning: dereference of possibly-NULL 'subsetSize' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   15 |         subsetSize[i] = 1;\n      |         ~~~~~~~~~~~~~~^~~\n  'largestDivisibleSubset': events 1-6\n    |\n    |    5 |     if (n == 0)\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch (when 'n != 0')...\n    |......\n    |    8 |     int count = 1, maxSubsetSize = 1;\n    |      |         ~~~~~\n    |      |         |\n    |      |         (2) ...to here\n    |    9 |     int lastElementIndex = 0;\n    |   10 |     int *subsetSize = malloc(sizeof(int)*n);\n    |      |                       ~~~~~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (3) this call could return NULL\n    |......\n    |   13 |     for (int i = 0; i < n; i++)\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (4) following 'true' branch (when 'i < n')...\n    |   14 |     {\n    |   15 |         subsetSize[i] = 1;\n    |      |         ~~~~~~~~~~~~~~~~~\n    |      |                   |   |\n    |      |                   |   (6) 'subsetSize + (long unsigned int)i * 4' could be NULL: unchecked value from (3)\n    |      |                   (5) ...to here\n    |\ncollected_code/problem-620-0.c:16:26: warning: dereference of possibly-NULL 'previousIndex' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   16 |         previousIndex[i] = -1;\n      |         ~~~~~~~~~~~~~~~~~^~~~\n  'largestDivisibleSubset': events 1-6\n    |\n    |    5 |     if (n == 0)\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch (when 'n != 0')...\n    |......\n    |    8 |     int count = 1, maxSubsetSize = 1;\n    |      |         ~~~~~\n    |      |         |\n    |      |         (2) ...to here\n    |......\n    |   11 |     int *previousIndex = malloc(sizeof(int)*n);\n    |      |                          ~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (3) this call could return NULL\n    |   12 | \n    |   13 |     for (int i = 0; i < n; i++)\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (4) following 'true' branch (when 'i < n')...\n    |   14 |     {\n    |   15 |         subsetSize[i] = 1;\n    |      |                   ~\n    |      |                   |\n    |      |                   (5) ...to here\n    |   16 |         previousIndex[i] = -1;\n    |      |         ~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (6) 'previousIndex + (long unsigned int)i * 4' could be NULL: unchecked value from (3)\n    |\ncollected_code/problem-620-0.c:42:19: warning: dereference of possibly-NULL 'subset' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   42 |         subset[i] = arr[currentIndex];\n      |         ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n  'largestDivisibleSubset': events 1-10\n    |\n    |    5 |     if (n == 0)\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch (when 'n != 0')...\n    |......\n    |    8 |     int count = 1, maxSubsetSize = 1;\n    |      |         ~~~~~\n    |      |         |\n    |      |         (2) ...to here\n    |......\n    |   13 |     for (int i = 0; i < n; i++)\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (3) following 'false' branch (when 'i >= n')...\n    |......\n    |   19 |     for (int i = 1; i < n; i++)\n    |      |              ~      ~~~~~\n    |      |              |        |\n    |      |              |        (5) following 'false' branch (when 'i >= n')...\n    |      |              (4) ...to here\n    |......\n    |   37 |     int *subset = malloc(sizeof(int)*maxSubsetSize);\n    |      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (6) ...to here\n    |      |                   (7) this call could return NULL\n    |......\n    |   40 |     for (int i = maxSubsetSize - 1; i >= 0; i--)\n    |      |                                     ~~~~~~\n    |      |                                       |\n    |      |                                       (8) following 'true' branch (when 'i >= 0')...\n    |   41 |     {\n    |   42 |         subset[i] = arr[currentIndex];\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |    |\n    |      |                   |    (9) ...to here\n    |      |                   (10) 'subset + (long unsigned int)i * 4' could be NULL: unchecked value from (7)\n    |\ncollected_code/problem-620-0.c:43:22: warning: use of uninitialized value '*previousIndex_89 + _56' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   43 |         currentIndex = previousIndex[currentIndex];\n      |         ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'largestDivisibleSubset': events 1-10\n    |\n    |    5 |     if (n == 0)\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch (when 'n != 0')...\n    |......\n    |    8 |     int count = 1, maxSubsetSize = 1;\n    |      |         ~~~~~\n    |      |         |\n    |      |         (2) ...to here\n    |......\n    |   11 |     int *previousIndex = malloc(sizeof(int)*n);\n    |      |                          ~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (3) region created on heap here\n    |   12 | \n    |   13 |     for (int i = 0; i < n; i++)\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (4) following 'false' branch (when 'i >= n')...\n    |......\n    |   19 |     for (int i = 1; i < n; i++)\n    |      |              ~      ~~~~~\n    |      |              |        |\n    |      |              |        (6) following 'false' branch (when 'i >= n')...\n    |      |              (5) ...to here\n    |......\n    |   37 |     int *subset = malloc(sizeof(int)*maxSubsetSize);\n    |      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (7) ...to here\n    |......\n    |   40 |     for (int i = maxSubsetSize - 1; i >= 0; i--)\n    |      |                                     ~~~~~~\n    |      |                                       |\n    |      |                                       (8) following 'true' branch (when 'i >= 0')...\n    |   41 |     {\n    |   42 |         subset[i] = arr[currentIndex];\n    |      |                        ~\n    |      |                        |\n    |      |                        (9) ...to here\n    |   43 |         currentIndex = previousIndex[currentIndex];\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (10) use of uninitialized value '*previousIndex_89 + _56' here\n    |\ncollected_code/problem-620-0.c:43:22: warning: dereference of possibly-NULL 'previousIndex' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   43 |         currentIndex = previousIndex[currentIndex];\n      |         ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'largestDivisibleSubset': events 1-10\n    |\n    |    5 |     if (n == 0)\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch (when 'n != 0')...\n    |......\n    |    8 |     int count = 1, maxSubsetSize = 1;\n    |      |         ~~~~~\n    |      |         |\n    |      |         (2) ...to here\n    |......\n    |   11 |     int *previousIndex = malloc(sizeof(int)*n);\n    |      |                          ~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (3) this call could return NULL\n    |   12 | \n    |   13 |     for (int i = 0; i < n; i++)\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (4) following 'false' branch (when 'i >= n')...\n    |......\n    |   19 |     for (int i = 1; i < n; i++)\n    |      |              ~      ~~~~~\n    |      |              |        |\n    |      |              |        (6) following 'false' branch (when 'i >= n')...\n    |      |              (5) ...to here\n    |......\n    |   37 |     int *subset = malloc(sizeof(int)*maxSubsetSize);\n    |      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (7) ...to here\n    |......\n    |   40 |     for (int i = maxSubsetSize - 1; i >= 0; i--)\n    |      |                                     ~~~~~~\n    |      |                                       |\n    |      |                                       (8) following 'true' branch (when 'i >= 0')...\n    |   41 |     {\n    |   42 |         subset[i] = arr[currentIndex];\n    |      |                        ~\n    |      |                        |\n    |      |                        (9) ...to here\n    |   43 |         currentIndex = previousIndex[currentIndex];\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (10) 'previousIndex + (long unsigned int)currentIndex * 4' could be NULL: unchecked value from (3)\n    |\ncollected_code/problem-620-0.c:49:9: warning: use of uninitialized value '*subset_93 + _59' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   49 |         printf(""%d "", subset[i]);\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~\n  'largestDivisibleSubset': events 1-14\n    |\n    |    5 |     if (n == 0)\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch (when 'n != 0')...\n    |......\n    |    8 |     int count = 1, maxSubsetSize = 1;\n    |      |         ~~~~~\n    |      |         |\n    |      |         (2) ...to here\n    |......\n    |   13 |     for (int i = 0; i < n; i++)\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (3) following 'true' branch (when 'i < n')...\n    |      |                       (5) following 'false' branch (when 'i >= n')...\n    |   14 |     {\n    |   15 |         subsetSize[i] = 1;\n    |      |                   ~\n    |      |                   |\n    |      |                   (4) ...to here\n    |......\n    |   19 |     for (int i = 1; i < n; i++)\n    |      |              ~\n    |      |              |\n    |      |              (6) ...to here\n    |   20 |     {\n    |   21 |         for (int j = 0; j < i; j++)\n    |      |                         ~~~~~\n    |      |                           |\n    |      |                           (7) following 'true' branch (when 'j < i')...\n    |   22 |         {\n    |   23 |             if (arr[i] % arr[j] == 0 && subsetSize[i] < subsetSize[j] + 1)\n    |      |                    ~\n    |      |                    |\n    |      |                    (8) ...to here\n    |......\n    |   37 |     int *subset = malloc(sizeof(int)*maxSubsetSize);\n    |      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (9) region created on heap here\n    |......\n    |   40 |     for (int i = maxSubsetSize - 1; i >= 0; i--)\n    |      |                                     ~~~~~~\n    |      |                                       |\n    |      |                                       (10) following 'false' branch (when 'i < 0')...\n    |......\n    |   46 |     printf(""Largest Divisible Subset: "");\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (11) ...to here\n    |   47 |     for (int i = 0; i < maxSubsetSize; i++)\n    |      |                     ~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (12) following 'true' branch (when 'i < maxSubsetSize')...\n    |   48 |     {\n    |   49 |         printf(""%d "", subset[i]);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |                   |\n    |      |         |                   (13) ...to here\n    |      |         (14) use of uninitialized value '*subset_93 + _59' here\n    |\ncollected_code/problem-620-0.c:49:9: warning: dereference of possibly-NULL 'subset' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   49 |         printf(""%d "", subset[i]);\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~\n  'largestDivisibleSubset': events 1-10\n    |\n    |    5 |     if (n == 0)\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch (when 'n != 0')...\n    |......\n    |    8 |     int count = 1, maxSubsetSize = 1;\n    |      |         ~~~~~\n    |      |         |\n    |      |         (2) ...to here\n    |......\n    |   13 |     for (int i = 0; i < n; i++)\n    |      |                     ~~~~~\n    |      |                       |\n    |      |                       (3) following 'true' branch (when 'i < n')...\n    |   14 |     {\n    |   15 |         subsetSize[i] = 1;\n    |      |                   ~\n    |      |                   |\n    |      |                   (4) ...to here\n    |......\n    |   37 |     int *subset = malloc(sizeof(int)*maxSubsetSize);\n    |      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (5) this call could return NULL\n    |......\n    |   40 |     for (int i = maxSubsetSize - 1; i >= 0; i--)\n    |      |                                     ~~~~~~\n    |      |                                       |\n    |      |                                       (6) following 'true' branch (when 'i >= 0')...\n    |   41 |     {\n    |   42 |         subset[i] = arr[currentIndex];\n    |      |                        ~\n    |      |                        |\n    |      |                        (7) ...to here\n    |......\n    |   47 |     for (int i = 0; i < maxSubsetSize; i++)\n    |      |                     ~~~~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (8) following 'true' branch (when 'i < maxSubsetSize')...\n    |   48 |     {\n    |   49 |         printf(""%d "", subset[i]);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |                   |\n    |      |         |                   (9) ...to here\n    |      |         (10) 'subset + (long unsigned int)i * 4' could be NULL: unchecked value from (5)\n    |\n"
621§True§collected_code/problem-621-0.c:5:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i] != '\0') {\n              ^\ncollected_code/problem-621-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] >= '0' && str[i] <= '9') {\n               ^\ncollected_code/problem-621-0.c:7:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[i] += k;\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-621-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.58 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
622§True§collected_code/problem-622-0.c:9:15: error: Cannot determine that 'array1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (array1[i] <= array2[j]) {\n              ^\ncollected_code/problem-622-0.c:9:28: error: Cannot determine that 'array2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (array1[i] <= array2[j]) {\n                           ^\ncollected_code/problem-622-0.c:10:27: error: Cannot determine that 'array1[i++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      merged[k++] = array1[i++];\n                          ^\ncollected_code/problem-622-0.c:12:27: error: Cannot determine that 'array2[j++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      merged[k++] = array2[j++];\n                          ^\ncollected_code/problem-622-0.c:17:25: error: Cannot determine that 'array1[i++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    merged[k++] = array1[i++];\n                        ^\ncollected_code/problem-622-0.c:21:25: error: Cannot determine that 'array2[j++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    merged[k++] = array2[j++];\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-622-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 44 in approximately 0.01 seconds (5825 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 30.303 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
623§True§"collected_code/problem-623-0.c:6:25: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i] = pow(arr[i], n);\n                        ^\ncollected_code/problem-623-0.c:13:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\ncollected_code/problem-623-0.c:22:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-623-0.c:28:26: error: Cannot determine that 'arr[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", arr[i]);\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-623-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.60 seconds (53 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   9 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   9 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 346.154 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
624§True§collected_code/problem-624-0.c:6:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-624-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-624-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 16 in approximately 0.50 seconds (32 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 133.333 [1+] 66.6667 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
625§True§collected_code/problem-625-0.c:8:20: error: Cannot determine that 'list[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int temp = list[0];\n                   ^\ncollected_code/problem-625-0.c:9:19: error: Cannot determine that 'list[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    list[0] = list[size-1];\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-625-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3439 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
626§True§"collected_code/problem-626-0.c:18:17: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n  scanf(""%lf"", &radius);\n                ^\ncollected_code/problem-626-0.c:20:23: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n  findLargestTriangle(radius);\n                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-626-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3013 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
627§True§collected_code/problem-627-0.c:14:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > 0 && arr[i] <= n) {\n               ^\ncollected_code/problem-627-0.c:15:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            count[arr[i]]++;\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-627-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.01 seconds (3249 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.037 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
628§True§collected_code/problem-628-0.c:9:12: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (str[i] == ' ')\n           ^\ncollected_code/problem-628-0.c:16:12: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (str[i] == ' ') {\n           ^\ncollected_code/problem-628-0.c:22:31: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      str[newLength - 1] = str[i];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-628-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.01 seconds (5739 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.037 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
629§True§"collected_code/problem-629-0.c:7:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] % 2 == 0) {\n                ^\ncollected_code/problem-629-0.c:8:31: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", list[i]);\n                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-629-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.39 seconds (49 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 133.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
630§True§Checking collected_code/problem-630-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-630-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.55 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
631§True§collected_code/problem-631-0.c:9:28: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (regexec(&regex, str, 1, &substr, 0) == 0) {\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-631-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.30 seconds (76 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
632§True§collected_code/problem-632-0.c:7:15: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n       if (arr[i] != 0) {\n              ^\ncollected_code/problem-632-0.c:8:28: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n           arr[count] = arr[i];\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-632-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (3864 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
633§True§collected_code/problem-633-0.c:7:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += arr[i] ^ arr[j];\n                      ^\ncollected_code/problem-633-0.c:7:32: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += arr[i] ^ arr[j];\n                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-633-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.61 seconds (30 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
634§True§"collected_code/problem-634-0.c:15:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-634-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (2371 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
635§True§collected_code/problem-635-0.c:9:24: error: Cannot determine that 'arr[left]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] < arr[smallest])\n                       ^\ncollected_code/problem-635-0.c:9:36: error: Cannot determine that 'arr[smallest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] < arr[smallest])\n                                   ^\ncollected_code/problem-635-0.c:12:25: error: Cannot determine that 'arr[right]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] < arr[smallest])\n                        ^\ncollected_code/problem-635-0.c:12:38: error: Cannot determine that 'arr[smallest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] < arr[smallest])\n                                     ^\ncollected_code/problem-635-0.c:16:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[i];\n                      ^\ncollected_code/problem-635-0.c:17:21: error: Cannot determine that 'arr[smallest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i] = arr[smallest];\n                    ^\ncollected_code/problem-635-0.c:35:23: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[0];\n                      ^\ncollected_code/problem-635-0.c:36:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[0] = arr[i];\n                    ^\ncollected_code/problem-635-0.c:44:13: error: Cannot determine that '*size' is initialized [premium-bughuntingUninit]\n    *size = *size + 1;\n            ^\ncollected_code/problem-635-0.c:48:26: error: Cannot determine that 'heap[(i-1)/2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (i != 0 && heap[(i - 1) / 2] > heap[i]) {\n                         ^\ncollected_code/problem-635-0.c:58:9: error: Cannot determine that '*size' is initialized [premium-bughuntingUninit]\n    if (*size <= 0)\n        ^\ncollected_code/problem-635-0.c:61:9: error: Cannot determine that '*size' is initialized [premium-bughuntingUninit]\n    if (*size == 1) {\n        ^\ncollected_code/problem-635-0.c:62:17: error: Cannot determine that '*size' is initialized [premium-bughuntingUninit]\n        *size = *size - 1;\n                ^\ncollected_code/problem-635-0.c:63:20: error: Cannot determine that 'heap[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return heap[0];\n                   ^\ncollected_code/problem-635-0.c:66:24: error: Cannot determine that 'heap[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int smallest = heap[0];\n                       ^\ncollected_code/problem-635-0.c:67:19: error: Cannot determine that 'heap[*size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    heap[0] = heap[*size - 1];\n                  ^\ncollected_code/problem-635-0.c:67:20: error: Cannot determine that '*size' is initialized [premium-bughuntingUninit]\n    heap[0] = heap[*size - 1];\n                   ^\ncollected_code/problem-635-0.c:68:13: error: Cannot determine that '*size' is initialized [premium-bughuntingUninit]\n    *size = *size - 1;\n            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-635-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 92 in approximately 0.36 seconds (257 lines/second)\nPhysical Source Lines of Code (SLOC) = 71\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 14.0845 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
636§True§"collected_code/problem-636-0.c:31:24: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                       ^\ncollected_code/problem-636-0.c:31:28: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                           ^\ncollected_code/problem-636-0.c:31:32: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                               ^\ncollected_code/problem-636-0.c:33:30: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    if (checkReciprocalRoots(a, b, c)) {\n                             ^\ncollected_code/problem-636-0.c:33:33: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    if (checkReciprocalRoots(a, b, c)) {\n                                ^\ncollected_code/problem-636-0.c:33:36: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    if (checkReciprocalRoots(a, b, c)) {\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-636-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.30 seconds (128 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
637§True§"collected_code/problem-637-0.c:21:19: error: Cannot determine that 'amount' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &amount);\n                  ^\ncollected_code/problem-637-0.c:23:23: error: Cannot determine that 'amount' is initialized [premium-bughuntingUninit]\n    checkProfitOrLoss(amount);\n                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-637-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.57 seconds (44 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 263.158 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
638§True§"collected_code/problem-638-0.c:15:18: error: Cannot determine that 'temperature' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &temperature);\n                 ^\ncollected_code/problem-638-0.c:18:18: error: Cannot determine that 'wind_speed' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &wind_speed);\n                 ^\ncollected_code/problem-638-0.c:20:57: error: Cannot determine that 'temperature' is initialized [premium-bughuntingUninit]\n    float wind_chill_index = calculate_wind_chill_index(temperature, wind_speed);\n                                                        ^\ncollected_code/problem-638-0.c:20:70: error: Cannot determine that 'wind_speed' is initialized [premium-bughuntingUninit]\n    float wind_chill_index = calculate_wind_chill_index(temperature, wind_speed);\n                                                                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-638-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2863 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 312.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-638-0.c: In function 'calculate_wind_chill_index':\ncollected_code/problem-638-0.c:6:63: warning: implicit declaration of function 'pow' [-Wimplicit-function-declaration]\n    6 |     wind_chill_index = 35.74 + 0.6215 * temperature - 35.75 * pow(wind_speed, 0.16) + 0.4275 * temperature * pow(wind_speed, 0.16);\n      |                                                               ^~~\ncollected_code/problem-638-0.c:2:1: note: include '<math.h>' or provide a declaration of 'pow'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-638-0.c:6:63: warning: incompatible implicit declaration of built-in function 'pow' [-Wbuiltin-declaration-mismatch]\n    6 |     wind_chill_index = 35.74 + 0.6215 * temperature - 35.75 * pow(wind_speed, 0.16) + 0.4275 * temperature * pow(wind_speed, 0.16);\n      |                                                               ^~~\ncollected_code/problem-638-0.c:6:63: note: include '<math.h>' or provide a declaration of 'pow'\n
639§True§collected_code/problem-639-0.c:8:29: error: Cannot determine that 'names[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (islower(names[i][0])) {\n                            ^\ncollected_code/problem-639-0.c:11:28: error: Cannot determine that 'names[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += strlen(names[i]);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-639-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-639-0.c:11:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 21 in approximately 0.01 seconds (3174 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]  50 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
640§True§collected_code/problem-640-0.c:5:25: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length = strlen(string);\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-640-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-640-0.c:27:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-640-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 31 in approximately 0.61 seconds (51 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 115.385 [1+] 76.9231 [2+] 38.4615 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
641§True§"collected_code/problem-641-0.c:10:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-641-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.01 seconds (1739 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
642§True§"collected_code/problem-642-0.c:11:25: error: Cannot determine that '*numRows' is initialized [premium-bughuntingUninit]\n    for (int i = 0; i < *numRows; i++) {\n                        ^\ncollected_code/problem-642-0.c:20:30: error: Cannot determine that 'matrix[i][k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (matrix[i][k] != distinctRows[j][k]) {\n                             ^\ncollected_code/problem-642-0.c:20:52: error: Cannot determine that 'distinctRows[j][k]' is initialized [premium-bughuntingUninit]\n                if (matrix[i][k] != distinctRows[j][k]) {\n                                                   ^\ncollected_code/problem-642-0.c:36:59: error: Cannot determine that 'matrix[i][k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                distinctRows[distinctCount][k] = matrix[i][k];\n                                                          ^\ncollected_code/problem-642-0.c:45:43: error: Cannot determine that 'distinctRows[i][j]' is initialized [premium-bughuntingUninit]\n            matrix[i][j] = distinctRows[i][j];\n                                          ^\ncollected_code/problem-642-0.c:57:18: error: Cannot determine that 'numRows' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &numRows);\n                 ^\ncollected_code/problem-642-0.c:59:18: error: Cannot determine that 'numCols' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &numCols);\n                 ^\ncollected_code/problem-642-0.c:73:36: error: Cannot determine that 'matrix[i][j]' is initialized [premium-bughuntingUninit]\n            printf(""%d "", matrix[i][j]);\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-642-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 78 in approximately 0.35 seconds (221 lines/second)\nPhysical Source Lines of Code (SLOC) = 58\nHits@level = [0]   9 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   9 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 155.172 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
643§True§collected_code/problem-643-0.c:5:25: error: Cannot determine that 'word[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length = strlen(word);\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-643-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-643-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 26 in approximately 0.34 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   3 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 173.913 [1+] 43.4783 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
644§True§collected_code/problem-644-0.c:8:23: error: Cannot determine that 'arr[start]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[start];\n                      ^\ncollected_code/problem-644-0.c:9:25: error: Cannot determine that 'arr[end]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[start] = arr[end];\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-644-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.61 seconds (56 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
645§True§collected_code/problem-645-0.c:6:29: error: Cannot determine that 'tuples[i][k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        product *= tuples[i][k];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-645-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.61 seconds (26 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
646§True§"collected_code/problem-646-0.c:14:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\ncollected_code/problem-646-0.c:16:18: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &k);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-646-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.67 seconds (28 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 277.778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
647§True§collected_code/problem-647-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-647-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-647-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 17 in approximately 0.02 seconds (756 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   2 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+] 62.5 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
648§True§collected_code/problem-648-0.c:4:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-648-0.c:5:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-648-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.35 seconds (86 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  80 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
649§True§collected_code/problem-649-0.c:10:20: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += list[i];\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-649-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.63 seconds (35 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
650§False§collected_code/problem-650-0.c:9:17: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr1[i] != arr2[i]) {\n                ^\ncollected_code/problem-650-0.c:9:28: error: Cannot determine that 'arr2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr1[i] != arr2[i]) {\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-650-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.68 seconds (20 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
651§True§collected_code/problem-651-0.c:10:23: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (tuple1[i] == tuple2[j]) {\n                      ^\ncollected_code/problem-651-0.c:10:36: error: Cannot determine that 'tuple2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (tuple1[i] == tuple2[j]) {\n                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-651-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.44 seconds (84 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 64.5161 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
652§True§"collected_code/problem-652-0.c:9:39: error: Cannot determine that 'mat[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""(%d, %d) "", mat[i][j], j);\n                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-652-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3141 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
653§True§collected_code/problem-653-0.c:47:17: error: Cannot determine that '*key++' is initialized [premium-bughuntingUninit]\n    while ((c = *key++)) {\n                ^\ncollected_code/problem-653-0.c:58:31: error: Cannot determine that 'key[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strcpy(newNode->data.key, key);\n                              ^\ncollected_code/problem-653-0.c:59:33: error: Cannot determine that 'value[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strcpy(newNode->data.value, value);\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-653-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-653-0.c:58:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-653-0.c:59:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-653-0.c:9:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-653-0.c:10:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 122 in approximately 0.42 seconds (288 lines/second)\nPhysical Source Lines of Code (SLOC) = 97\nHits@level = [0]   5 [1]   0 [2]   2 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   9 [1+]   4 [2+]   4 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 92.7835 [1+] 41.2371 [2+] 41.2371 [3+] 20.6186 [4+] 20.6186 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-653-0.c: In function 'createMap':\ncollected_code/problem-653-0.c:31:16: warning: dereference of possibly-NULL 'map' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   31 |     map->lists = (List*)malloc(capacity * sizeof(List));\n      |     ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'createMap': events 1-2\n    |\n    |   30 |     Map* map = (Map*)malloc(sizeof(Map));\n    |      |                      ^~~~~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (1) this call could return NULL\n    |   31 |     map->lists = (List*)malloc(capacity * sizeof(List));\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                |\n    |      |                (2) 'map' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-653-0.c:36:28: warning: dereference of possibly-NULL '*map.lists + (long unsigned int)i * 16' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   36 |         map->lists[i].head = NULL;\n      |                            ^\n  'createMap': events 1-3\n    |\n    |   31 |     map->lists = (List*)malloc(capacity * sizeof(List));\n    |      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                         |\n    |      |                         (1) this call could return NULL\n    |......\n    |   35 |     for (int i = 0; i < capacity; i++) {\n    |      |                     ~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < capacity')...\n    |   36 |         map->lists[i].head = NULL;\n    |      |         ~~~~~~~~~~       \n    |      |            |\n    |      |            (3) ...to here\n    |\n  'createMap': event 4\n    |\n    |   36 |         map->lists[i].head = NULL;\n    |      |                            ^\n    |      |                            |\n    |      |                            (4) '*map.lists + (long unsigned int)i * 16' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-653-0.c: In function 'insert':\ncollected_code/problem-653-0.c:60:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   60 |     newNode->next = NULL;\n      |                   ^\n  'insert': event 1\n    |\n    |   57 |     Node* newNode = (Node*)malloc(sizeof(Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |\n  'insert': event 2\n    |\n    |   60 |     newNode->next = NULL;\n    |      |                   ^\n    |      |                   |\n    |      |                   (2) 'newNode' could be NULL: unchecked value from (1)\n    |\n
654§True§"collected_code/problem-654-0.c:11:18: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &length);\n                 ^\ncollected_code/problem-654-0.c:13:18: error: Cannot determine that 'width' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &width);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-654-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.36 seconds (44 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
655§True§"collected_code/problem-655-0.c:16:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-655-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3191 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-655-0.c: In function 'sumOfFifthPowers':\ncollected_code/problem-655-0.c:7:31: warning: implicit declaration of function 'pow' [-Wimplicit-function-declaration]\n    7 |         sum += (long long int)pow(i, 5);\n      |                               ^~~\ncollected_code/problem-655-0.c:2:1: note: include '<math.h>' or provide a declaration of 'pow'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-655-0.c:7:31: warning: incompatible implicit declaration of built-in function 'pow' [-Wbuiltin-declaration-mismatch]\n    7 |         sum += (long long int)pow(i, 5);\n      |                               ^~~\ncollected_code/problem-655-0.c:7:31: note: include '<math.h>' or provide a declaration of 'pow'\n
656§True§collected_code/problem-656-0.c:5:13: error: Cannot determine that '*(int*)a' is initialized [premium-bughuntingUninit]\n    return (*(int *) a - *(int *) b);\n            ^\ncollected_code/problem-656-0.c:5:26: error: Cannot determine that '*(int*)b' is initialized [premium-bughuntingUninit]\n    return (*(int *) a - *(int *) b);\n                         ^\ncollected_code/problem-656-0.c:9:11: error: Cannot determine that 'arr1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    qsort(arr1, n, sizeof(int), compare);\n          ^\ncollected_code/problem-656-0.c:10:11: error: Cannot determine that 'arr2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    qsort(arr2, n, sizeof(int), compare);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-656-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.39 seconds (72 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 45.4545 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
657§True§"collected_code/problem-657-0.c:24:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-657-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.31 seconds (94 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 130.435 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
658§True§collected_code/problem-658-0.c:11:21: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[j] == list[i]) {\n                    ^\ncollected_code/problem-658-0.c:11:32: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[j] == list[i]) {\n                               ^\ncollected_code/problem-658-0.c:18:27: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            maxItem = list[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-658-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.03 seconds (1242 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
659§True§"collected_code/problem-659-0.c:7:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                   ^\ncollected_code/problem-659-0.c:7:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                             ^\ncollected_code/problem-659-0.c:8:34: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                printf(""%d "", arr[i]);\n                                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-659-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.03 seconds (798 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
660§True§"collected_code/problem-660-0.c:23:21: error: Cannot determine that 'range1_start' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &range1_start, &range1_end);\n                    ^\ncollected_code/problem-660-0.c:23:36: error: Cannot determine that 'range1_end' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &range1_start, &range1_end);\n                                   ^\ncollected_code/problem-660-0.c:25:21: error: Cannot determine that 'range2_start' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &range2_start, &range2_end);\n                    ^\ncollected_code/problem-660-0.c:25:36: error: Cannot determine that 'range2_end' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &range2_start, &range2_end);\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-660-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (3472 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   9 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   9 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 409.091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
661§True§collected_code/problem-661-0.c:19:12: warning: Uninitialized variable: sum [uninitvar]\n    return sum[n - 1];\n           ^\ncollected_code/problem-661-0.c:5:11: note: Assuming condition is false\n    if (n >= 1)\n          ^\ncollected_code/problem-661-0.c:19:12: note: Uninitialized variable: sum\n    return sum[n - 1];\n           ^\ncollected_code/problem-661-0.c:6:21: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum[0] = arr[0];\n                    ^\ncollected_code/problem-661-0.c:8:21: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum[1] = arr[0] + arr[1];\n                    ^\ncollected_code/problem-661-0.c:8:30: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum[1] = arr[0] + arr[1];\n                             ^\ncollected_code/problem-661-0.c:10:21: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum[2] = arr[0] + arr[1] + arr[2];\n                    ^\ncollected_code/problem-661-0.c:10:30: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum[2] = arr[0] + arr[1] + arr[2];\n                             ^\ncollected_code/problem-661-0.c:10:39: error: Cannot determine that 'arr[2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum[2] = arr[0] + arr[1] + arr[2];\n                                      ^\ncollected_code/problem-661-0.c:13:37: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp1 = sum[i - 3] + arr[i] + arr[i - 1];\n                                    ^\ncollected_code/problem-661-0.c:13:46: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp1 = sum[i - 3] + arr[i] + arr[i - 1];\n                                             ^\ncollected_code/problem-661-0.c:14:37: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp2 = sum[i - 2] + arr[i];\n                                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-661-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (3852 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
662§True§collected_code/problem-662-0.c:10:29: error: Cannot determine that 'list[j-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (j > 0 && list[j-1] > list[j]) {\n                            ^\ncollected_code/problem-662-0.c:10:41: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (j > 0 && list[j-1] > list[j]) {\n                                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-662-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (3828 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
663§False§Checking collected_code/problem-663-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-663-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 6 in approximately 0.01 seconds (969 lines/second)\nPhysical Source Lines of Code (SLOC) = 7\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
664§True§Checking collected_code/problem-664-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-664-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.42 seconds (50 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
665§True§collected_code/problem-665-0.c:4:18: error: Cannot determine that 'list[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  int temp = list[0];\n                 ^\ncollected_code/problem-665-0.c:7:19: error: Cannot determine that 'list[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    list[i] = list[i + 1];\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-665-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2538 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
666§True§collected_code/problem-666-0.c:6:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-666-0.c:7:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == c) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-666-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2700 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
667§True§collected_code/problem-667-0.c:6:19: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n  for(int i=0; str[i]!='\0'; i++) {\n                  ^\ncollected_code/problem-667-0.c:7:11: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if(str[i]=='a' || str[i]=='e' || str[i]=='i' || str[i]=='o' || str[i]=='u' ||\n          ^\ncollected_code/problem-667-0.c:8:11: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n       str[i]=='A' || str[i]=='E' || str[i]=='I' || str[i]=='O' || str[i]=='U') {\n          ^\ncollected_code/problem-667-0.c:20:8: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n  gets(str);\n       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-667-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-667-0.c:20:  [5] (buffer) gets:\n  Does not check for buffer overflows (CWE-120, CWE-20). Use fgets() instead.\ncollected_code/problem-667-0.c:17:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 24 in approximately 0.01 seconds (3525 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   1\nHits@level+ = [0+]   4 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   1\nHits/KSLOC@level+ = [0+] 222.222 [1+] 111.111 [2+] 111.111 [3+] 55.5556 [4+] 55.5556 [5+] 55.5556\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
668§True§Checking collected_code/problem-668-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-668-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.01 seconds (5459 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 34.4828 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
669§True§"collected_code/problem-669-0.c:14:30: error: Cannot determine that 'ipAddress[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    result = regexec(&regex, ipAddress, 0, NULL, 0);\n                             ^\ncollected_code/problem-669-0.c:28:17: error: Cannot determine that 'ipAddress[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", ipAddress);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-669-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-669-0.c:28:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-669-0.c:25:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 36 in approximately 0.01 seconds (4302 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 178.571 [1+] 71.4286 [2+] 71.4286 [3+] 35.7143 [4+] 35.7143 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
670§True§collected_code/problem-670-0.c:5:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] <= arr[i+1]) {\n               ^\ncollected_code/problem-670-0.c:5:26: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] <= arr[i+1]) {\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-670-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (3336 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
671§False§Checking collected_code/problem-671-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-671-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.25 seconds (99 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-671-0.c: In function 'setRightMostUnsetBit':\ncollected_code/problem-671-0.c:5:16: error: 'UINT_MAX' undeclared (first use in this function)\n    5 |     if (num == UINT_MAX) {\n      |                ^~~~~~~~\ncollected_code/problem-671-0.c:2:1: note: 'UINT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n    1 | #include <stdio.h>\n  +++ |+#include <limits.h>\n    2 | \ncollected_code/problem-671-0.c:5:16: note: each undeclared identifier is reported only once for each function it appears in\n    5 |     if (num == UINT_MAX) {\n      |                ^~~~~~~~\n
672§True§"collected_code/problem-672-0.c:21:23: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n   scanf(""%d %d %d"", &num1, &num2, &num3);\n                      ^\ncollected_code/problem-672-0.c:21:30: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n   scanf(""%d %d %d"", &num1, &num2, &num3);\n                             ^\ncollected_code/problem-672-0.c:21:37: error: Cannot determine that 'num3' is initialized [premium-bughuntingUninit]\n   scanf(""%d %d %d"", &num1, &num2, &num3);\n                                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-672-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.10 seconds (270 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
673§True§collected_code/problem-673-0.c:6:36: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result = result * 10 + list[i];\n                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-673-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.02 seconds (748 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
674§True§"collected_code/problem-674-0.c:30:20: warning: Uninitialized variable: wordArray [uninitvar]\n    strcpy(string, wordArray[0]);\n                   ^\ncollected_code/problem-674-0.c:10:17: note: Assuming condition is false\n    while (word != NULL) {\n                ^\ncollected_code/problem-674-0.c:30:20: note: Uninitialized variable: wordArray\n    strcpy(string, wordArray[0]);\n                   ^\ncollected_code/problem-674-0.c:5:20: error: Cannot determine that 'wordArray[100]' is initialized [premium-bughuntingUninit]\n    char *wordArray[100];\n                   ^\ncollected_code/problem-674-0.c:9:25: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char *word = strtok(string, "" "");\n                        ^\ncollected_code/problem-674-0.c:30:29: error: Cannot determine that 'wordArray[0]' is initialized [premium-bughuntingUninit]\n    strcpy(string, wordArray[0]);\n                            ^\ncollected_code/problem-674-0.c:33:33: error: Cannot determine that 'wordArray[i]' is initialized [premium-bughuntingUninit]\n        strcat(string, wordArray[i]);\n                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-674-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-674-0.c:30:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-674-0.c:33:  [4] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused).\ncollected_code/problem-674-0.c:5:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-674-0.c:32:  [1] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused). Risk is low because the\n  source is a constant character.\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 41 in approximately 0.69 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   1 [1]   1 [2]   1 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   5 [1+]   4 [2+]   3 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 156.25 [1+] 125 [2+] 93.75 [3+] 62.5 [4+] 62.5 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
675§True§"collected_code/problem-675-0.c:17:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-675-0.c:20:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-675-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.51 seconds (51 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 277.778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
676§False§collected_code/problem-676-0.c:12:28: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    reti = regexec(&regex, str, 0, NULL, 0);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-676-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-676-0.c:21:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 24 in approximately 0.03 seconds (692 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   1 [1+]   1 [2+]   1 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+] 62.5 [2+] 62.5 [3+] 62.5 [4+] 62.5 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-676-0.c: In function 'removeNonAlphanumeric':\ncollected_code/problem-676-0.c:12:36: error: 'NULL' undeclared (first use in this function)\n   12 |     reti = regexec(&regex, str, 0, NULL, 0);\n      |                                    ^~~~\ncollected_code/problem-676-0.c:2:1: note: 'NULL' is defined in header '<stddef.h>'; did you forget to '#include <stddef.h>'?\n    1 | #include <regex.h>\n  +++ |+#include <stddef.h>\n    2 | \ncollected_code/problem-676-0.c:12:36: note: each undeclared identifier is reported only once for each function it appears in\n   12 |     reti = regexec(&regex, str, 0, NULL, 0);\n      |                                    ^~~~\ncollected_code/problem-676-0.c:18:22: warning: implicit declaration of function 'regreplace' [-Wimplicit-function-declaration]\n   18 |       char *result = regreplace(str, regex);\n      |                      ^~~~~~~~~~\ncollected_code/problem-676-0.c:18:22: warning: initialization of 'char *' from 'int' makes pointer from integer without a cast [-Wint-conversion]\ncollected_code/problem-676-0.c:21:7: warning: implicit declaration of function 'strcpy' [-Wimplicit-function-declaration]\n   21 |       strcpy(str, result);\n      |       ^~~~~~\ncollected_code/problem-676-0.c:2:1: note: include '<string.h>' or provide a declaration of 'strcpy'\n    1 | #include <regex.h>\n  +++ |+#include <string.h>\n    2 | \ncollected_code/problem-676-0.c:21:7: warning: incompatible implicit declaration of built-in function 'strcpy' [-Wbuiltin-declaration-mismatch]\n   21 |       strcpy(str, result);\n      |       ^~~~~~\ncollected_code/problem-676-0.c:21:7: note: include '<string.h>' or provide a declaration of 'strcpy'\n
677§True§"collected_code/problem-677-0.c:17:24: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                       ^\ncollected_code/problem-677-0.c:17:32: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                               ^\ncollected_code/problem-677-0.c:17:40: error: Cannot determine that 'side3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &side1, &side2, &side3);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-677-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3978 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 210.526 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
678§False§collected_code/problem-678-0.c:5:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i]) {\n              ^\ncollected_code/problem-678-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] != ' ') {\n               ^\ncollected_code/problem-678-0.c:7:27: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[j++] = str[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-678-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 11 in approximately 0.01 seconds (1308 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
679§False§collected_code/problem-679-0.c:11:27: error: Cannot determine that 'dict[i].key[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strcmp(dict[i].key, key) == 0) {\n                          ^\ncollected_code/problem-679-0.c:11:33: error: Cannot determine that 'key[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (strcmp(dict[i].key, key) == 0) {\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-679-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-679-0.c:5:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 15 in approximately 0.45 seconds (33 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   0 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+] 71.4286 [2+] 71.4286 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
680§False§collected_code/problem-680-0.c:3:20: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (numbers[i] <= numbers[i - 1]) {\n                   ^\ncollected_code/problem-680-0.c:3:34: error: Cannot determine that 'numbers[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (numbers[i] <= numbers[i - 1]) {\n                                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-680-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 7 in approximately 0.53 seconds (13 lines/second)\nPhysical Source Lines of Code (SLOC) = 8\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-680-0.c:1:1: error: unknown type name 'bool'\n    1 | bool isIncreasing(int numbers[], int length) {\n      | ^~~~\ncollected_code/problem-680-0.c:1:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n  +++ |+#include <stdbool.h>\n    1 | bool isIncreasing(int numbers[], int length) {\ncollected_code/problem-680-0.c: In function 'isIncreasing':\ncollected_code/problem-680-0.c:4:20: error: 'false' undeclared (first use in this function)\n    4 |             return false;\n      |                    ^~~~~\ncollected_code/problem-680-0.c:4:20: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\ncollected_code/problem-680-0.c:4:20: note: each undeclared identifier is reported only once for each function it appears in\ncollected_code/problem-680-0.c:7:12: error: 'true' undeclared (first use in this function)\n    7 |     return true;\n      |            ^~~~\ncollected_code/problem-680-0.c:7:12: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n
681§False§Checking collected_code/problem-681-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-681-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (5025 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
682§True§"collected_code/problem-682-0.c:5:26: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = list1[i] * list2[i];\n                         ^\ncollected_code/problem-682-0.c:5:37: error: Cannot determine that 'list2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result[i] = list1[i] * list2[i];\n                                    ^\ncollected_code/problem-682-0.c:20:29: error: Cannot determine that 'result[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", result[i]);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-682-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.41 seconds (57 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
683§True§"collected_code/problem-683-0.c:24:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-683-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (2451 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
684§True§collected_code/problem-684-0.c:5:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-684-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == c) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-684-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (3013 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
685§True§"collected_code/problem-685-0.c:28:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-685-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (4057 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 107.143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
686§True§collected_code/problem-686-0.c:11:18: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[arr[i]]++;\n                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-686-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.02 seconds (1268 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
687§True§"collected_code/problem-687-0.c:15:21: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                    ^\ncollected_code/problem-687-0.c:15:28: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-687-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2956 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
688§True§Checking collected_code/problem-688-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-688-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2910 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-688-0.c: In function 'getComplexNumberLength':\ncollected_code/problem-688-0.c:9:21: warning: implicit declaration of function 'sqrt' [-Wimplicit-function-declaration]\n    9 |     double length = sqrt((number.real * number.real) + (number.imag * number.imag));\n      |                     ^~~~\ncollected_code/problem-688-0.c:2:1: note: include '<math.h>' or provide a declaration of 'sqrt'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-688-0.c:9:21: warning: incompatible implicit declaration of built-in function 'sqrt' [-Wbuiltin-declaration-mismatch]\n    9 |     double length = sqrt((number.real * number.real) + (number.imag * number.imag));\n      |                     ^~~~\ncollected_code/problem-688-0.c:9:21: note: include '<math.h>' or provide a declaration of 'sqrt'\n
689§False§collected_code/problem-689-0.c:8:12: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[0] == 0)\n           ^\ncollected_code/problem-689-0.c:11:23: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int maxReach = arr[0];\n                      ^\ncollected_code/problem-689-0.c:12:20: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int steps = arr[0];\n                   ^\ncollected_code/problem-689-0.c:20:41: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        maxReach = max(maxReach, i + arr[i]);\n                                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-689-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 44 in approximately 0.44 seconds (99 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 30.303 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-689-0.c: In function 'minJumps':\ncollected_code/problem-689-0.c:20:20: warning: implicit declaration of function 'max' [-Wimplicit-function-declaration]\n   20 |         maxReach = max(maxReach, i + arr[i]);\n      |                    ^~~\nUndefined symbols for architecture x86_64:\n  ""_max"", referenced from:\n      _minJumps in ccJJkcsO.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
690§True§collected_code/problem-690-0.c:6:23: error: Cannot determine that 'nums[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result *= nums[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-690-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2470 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
691§True§collected_code/problem-691-0.c:26:14: error: Cannot determine that 'count[tupleList[i].second]' is initialized [premium-bughuntingUninit]\n        count[tupleList[i].second]++;\n             ^\ncollected_code/problem-691-0.c:35:9: error: Cannot determine that 'groupedTuples' is initialized [premium-bughuntingUninit]\n        groupedTuples[i] = (struct Tuple *)calloc(count[i], sizeof(struct Tuple));\n        ^\ncollected_code/problem-691-0.c:35:56: error: Cannot determine that 'count[i]' is initialized [premium-bughuntingUninit]\n        groupedTuples[i] = (struct Tuple *)calloc(count[i], sizeof(struct Tuple));\n                                                       ^\ncollected_code/problem-691-0.c:49:34: error: Cannot determine that 'count[i]' is initialized [premium-bughuntingUninit]\n        for (int j = 0; j < count[i]; j++)\n                                 ^\ncollected_code/problem-691-0.c:62:10: error: Cannot determine that 'count[0]' is initialized [premium-bughuntingUninit]\n    free(count);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-691-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 72 in approximately 0.47 seconds (153 lines/second)\nPhysical Source Lines of Code (SLOC) = 55\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 54.5455 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-691-0.c: In function 'groupTupleBySecond':\ncollected_code/problem-691-0.c:35:26: warning: dereference of possibly-NULL 'groupedTuples' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   35 |         groupedTuples[i] = (struct Tuple *)calloc(count[i], sizeof(struct Tuple));\n      |         ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'groupTupleBySecond': events 1-6\n    |\n    |   24 |     for (int i = 0; i < size; i++)\n    |      |                     ~~^~~~~~\n    |      |                       |\n    |      |                       (1) following 'false' branch (when 'i >= size')...\n    |......\n    |   30 |     struct Tuple **groupedTuples = (struct Tuple **)calloc(maxSecond + 1, sizeof(struct Tuple *));\n    |      |                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                                     |                |\n    |      |                                                     |                (2) ...to here\n    |      |                                                     (3) this call could return NULL\n    |......\n    |   33 |     for (int i = 0; i <= maxSecond; i++)\n    |      |                     ~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (4) following 'true' branch (when 'i <= maxSecond')...\n    |   34 |     {\n    |   35 |         groupedTuples[i] = (struct Tuple *)calloc(count[i], sizeof(struct Tuple));\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |                             |\n    |      |                          |                             (5) ...to here\n    |      |                          (6) 'groupedTuples + (long unsigned int)i * 8' could be NULL: unchecked value from (3)\n    |\ncollected_code/problem-691-0.c:35:56: warning: dereference of possibly-NULL 'count' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   35 |         groupedTuples[i] = (struct Tuple *)calloc(count[i], sizeof(struct Tuple));\n      |                                                   ~~~~~^~~\n  'groupTupleBySecond': events 1-6\n    |\n    |   21 |     int *count = (int *)calloc(maxSecond + 1, sizeof(int));\n    |      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                         |\n    |      |                         (1) this call could return NULL\n    |......\n    |   24 |     for (int i = 0; i < size; i++)\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (2) following 'false' branch (when 'i >= size')...\n    |......\n    |   30 |     struct Tuple **groupedTuples = (struct Tuple **)calloc(maxSecond + 1, sizeof(struct Tuple *));\n    |      |                                                            ~~~~~~~~~~~~~\n    |      |                                                                      |\n    |      |                                                                      (3) ...to here\n    |......\n    |   33 |     for (int i = 0; i <= maxSecond; i++)\n    |      |                     ~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (4) following 'true' branch (when 'i <= maxSecond')...\n    |   34 |     {\n    |   35 |         groupedTuples[i] = (struct Tuple *)calloc(count[i], sizeof(struct Tuple));\n    |      |                                                   ~~~~~~~~\n    |      |                                                        |\n    |      |                                                        (5) ...to here\n    |      |                                                        (6) 'count + (long unsigned int)i * 4' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-691-0.c:51:13: warning: dereference of possibly-NULL '*groupedTuples_95 + _49 + (long unsigned int)j * 8' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   51 |             printf(""(%d, %d) "", groupedTuples[i][j].first, groupedTuples[i][j].second);\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'groupTupleBySecond': events 1-14\n    |\n    |   24 |     for (int i = 0; i < size; i++)\n    |      |                     ~~^~~~~~\n    |      |                       |\n    |      |                       (1) following 'false' branch (when 'i >= size')...\n    |......\n    |   30 |     struct Tuple **groupedTuples = (struct Tuple **)calloc(maxSecond + 1, sizeof(struct Tuple *));\n    |      |                                                            ~~~~~~~~~~~~~\n    |      |                                                                      |\n    |      |                                                                      (2) ...to here\n    |......\n    |   33 |     for (int i = 0; i <= maxSecond; i++)\n    |      |                     ~~~~~~~~~~~~~~\n    |      |                       |\n    |      |                       (3) following 'true' branch (when 'i <= maxSecond')...\n    |      |                       (6) following 'false' branch (when 'i > maxSecond')...\n    |   34 |     {\n    |   35 |         groupedTuples[i] = (struct Tuple *)calloc(count[i], sizeof(struct Tuple));\n    |      |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                            |           |\n    |      |                                            |           (4) ...to here\n    |      |                                            (5) this call could return NULL\n    |......\n    |   39 |     for (int i = 0; i < size; i++)\n    |      |              ~      ~~~~~~~~\n    |      |              |        |\n    |      |              |        (8) following 'false' branch (when 'i >= size')...\n    |      |              (7) ...to here\n    |......\n    |   46 |     for (int i = 0; i <= maxSecond; i++)\n    |      |              ~      ~~~~~~~~~~~~~~\n    |      |              |        |\n    |      |              |        (10) following 'true' branch (when 'i <= maxSecond')...\n    |      |              (9) ...to here\n    |   47 |     {\n    |   48 |         printf(""Group %d: "", i);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (11) ...to here\n    |   49 |         for (int j = 0; j < count[i]; j++)\n    |      |                         ~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (12) following 'true' branch...\n    |   50 |         {\n    |   51 |             printf(""(%d, %d) "", groupedTuples[i][j].first, groupedTuples[i][j].second);\n    |      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |             |                                                           |\n    |      |             |                                                           (13) ...to here\n    |      |             (14) '*groupedTuples_95 + _49 + (long unsigned int)j * 8' could be NULL: unchecked value from (5)\n    |\n"
692§True§"collected_code/problem-692-0.c:15:16: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n  scanf(""%d"", &num);\n               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-692-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (2043 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
693§True§collected_code/problem-693-0.c:10:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-693-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-693-0.c:10:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 34 in approximately 0.48 seconds (71 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   2 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+] 37.037 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-693-0.c: In function 'removeMultipleSpaces':\ncollected_code/problem-693-0.c:10:15: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n   10 |     int len = strlen(str);\n      |               ^~~~~~\ncollected_code/problem-693-0.c:3:1: note: include '<string.h>' or provide a declaration of 'strlen'\n    2 | #include <regex.h>\n  +++ |+#include <string.h>\n    3 | \ncollected_code/problem-693-0.c:10:15: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n   10 |     int len = strlen(str);\n      |               ^~~~~~\ncollected_code/problem-693-0.c:10:15: note: include '<string.h>' or provide a declaration of 'strlen'\ncollected_code/problem-693-0.c:17:9: warning: implicit declaration of function 'memmove' [-Wimplicit-function-declaration]\n   17 |         memmove(str + start, str + end, numCharsAfterSpaces);\n      |         ^~~~~~~\ncollected_code/problem-693-0.c:17:9: note: include '<string.h>' or provide a declaration of 'memmove'\ncollected_code/problem-693-0.c:17:9: warning: incompatible implicit declaration of built-in function 'memmove' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-693-0.c:17:9: note: include '<string.h>' or provide a declaration of 'memmove'\ncollected_code/problem-693-0.c:18:9: warning: implicit declaration of function 'memset' [-Wimplicit-function-declaration]\n   18 |         memset(str + len - numSpaces, ' ', numSpaces);\n      |         ^~~~~~\ncollected_code/problem-693-0.c:18:9: note: include '<string.h>' or provide a declaration of 'memset'\ncollected_code/problem-693-0.c:18:9: warning: incompatible implicit declaration of built-in function 'memset' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-693-0.c:18:9: note: include '<string.h>' or provide a declaration of 'memset'\n
694§True§"collected_code/problem-694-0.c:13:27: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (dictionary[i] == dictionary[j])\n                          ^\ncollected_code/problem-694-0.c:13:44: error: Cannot determine that 'dictionary[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (dictionary[i] == dictionary[j])\n                                           ^\ncollected_code/problem-694-0.c:22:52: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            uniqueValues[*uniqueCount] = dictionary[i];\n                                                   ^\ncollected_code/problem-694-0.c:35:64: error: Cannot determine that 'uniqueCount' is initialized [premium-bughuntingUninit]\n    extractUniqueValues(dictionary, dictLength, uniqueValues, &uniqueCount);\n                                                               ^\ncollected_code/problem-694-0.c:38:25: error: Cannot determine that 'uniqueCount' is initialized [premium-bughuntingUninit]\n    for (int i = 0; i < uniqueCount; i++)\n                        ^\ncollected_code/problem-694-0.c:40:35: error: Cannot determine that 'uniqueValues[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", uniqueValues[i]);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-694-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 43 in approximately 0.55 seconds (79 lines/second)\nPhysical Source Lines of Code (SLOC) = 37\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 54.0541 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
695§True§collected_code/problem-695-0.c:5:19: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple2[i] <= tuple1[i]) {\n                  ^\ncollected_code/problem-695-0.c:5:32: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple2[i] <= tuple1[i]) {\n                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-695-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.51 seconds (45 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
696§True§"collected_code/problem-696-0.c:9:36: error: Cannot determine that 'lists1[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", lists1[i][j]);\n                                   ^\ncollected_code/problem-696-0.c:11:32: error: Cannot determine that 'lists2[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", lists2[i][0]);\n                               ^\ncollected_code/problem-696-0.c:12:33: error: Cannot determine that 'lists2[i][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d\n"", lists2[i][1]);\n                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-696-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.41 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
697§True§collected_code/problem-697-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % 2 == 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-697-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.55 seconds (33 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
698§True§Checking collected_code/problem-698-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-698-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 53 in approximately 0.01 seconds (5443 lines/second)\nPhysical Source Lines of Code (SLOC) = 43\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 23.2558 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
699§True§collected_code/problem-699-0.c:5:20: error: Cannot determine that 'str1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int n = strlen(str1);\n                   ^\ncollected_code/problem-699-0.c:6:20: error: Cannot determine that 'str2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int m = strlen(str2);\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-699-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-699-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-699-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-699-0.c:26:  [1] (buffer) mismatch:\n  Function does not check the second iterator for over-read conditions\n  (CWE-126). This function is often discouraged by most C++ coding standards\n  in favor of its safer alternatives provided since C++14. Consider using a\n  form of this function that checks the second iterator before potentially\n  overflowing it.\ncollected_code/problem-699-0.c:30:  [1] (buffer) mismatch:\n  Function does not check the second iterator for over-read conditions\n  (CWE-126). This function is often discouraged by most C++ coding standards\n  in favor of its safer alternatives provided since C++14. Consider using a\n  form of this function that checks the second iterator before potentially\n  overflowing it.\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 41 in approximately 0.03 seconds (1636 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   1 [1]   4 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   4 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 161.29 [1+] 129.032 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
700§True§collected_code/problem-700-0.c:6:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] >= lower && list[i] <= upper) {\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-700-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.37 seconds (54 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
701§True§collected_code/problem-701-0.c:8:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        rightSum += arr[i];\n                       ^\ncollected_code/problem-701-0.c:12:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        rightSum -= arr[i];\n                       ^\ncollected_code/problem-701-0.c:18:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        leftSum += arr[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-701-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.02 seconds (1390 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
702§True§collected_code/problem-702-0.c:5:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min = arr[0];\n                 ^\ncollected_code/problem-702-0.c:6:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max = arr[0];\n                 ^\ncollected_code/problem-702-0.c:9:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < min) {\n               ^\ncollected_code/problem-702-0.c:10:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min = arr[i];\n                     ^\ncollected_code/problem-702-0.c:11:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (arr[i] > max) {\n                      ^\ncollected_code/problem-702-0.c:12:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max = arr[i];\n                     ^\ncollected_code/problem-702-0.c:18:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] != min && arr[i] != max) {\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-702-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.44 seconds (82 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 34.4828 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
703§True§"collected_code/problem-703-0.c:19:18: error: Cannot determine that 'key' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &key);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-703-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (2510 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 181.818 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
704§True§"collected_code/problem-704-0.c:14:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-704-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2536 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
705§True§collected_code/problem-705-0.c:6:18: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    char* temp = *a;\n                 ^\ncollected_code/problem-705-0.c:7:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-705-0.c:8:10: error: Cannot determine that 'temp' is initialized [premium-bughuntingUninit]\n    *b = temp;\n         ^\ncollected_code/problem-705-0.c:16:28: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strlen(list[j]) > strlen(list[j + 1])) {\n                           ^\ncollected_code/problem-705-0.c:16:46: error: Cannot determine that 'list[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strlen(list[j]) > strlen(list[j + 1])) {\n                                             ^\ncollected_code/problem-705-0.c:20:33: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            else if (strlen(list[j]) == strlen(list[j + 1])) {\n                                ^\ncollected_code/problem-705-0.c:20:52: error: Cannot determine that 'list[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            else if (strlen(list[j]) == strlen(list[j + 1])) {\n                                                   ^\ncollected_code/problem-705-0.c:21:32: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (strcmp(list[j], list[j + 1]) > 0) {\n                               ^\ncollected_code/problem-705-0.c:21:41: error: Cannot determine that 'list[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (strcmp(list[j], list[j + 1]) > 0) {\n                                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-705-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-705-0.c:16:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-705-0.c:16:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-705-0.c:20:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-705-0.c:20:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 39 in approximately 0.39 seconds (100 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   1 [1]   4 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   4 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 156.25 [1+] 125 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
706§True§collected_code/problem-706-0.c:10:19: error: Cannot determine that 'array2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n         if(array2[i] == array1[j])\n                  ^\ncollected_code/problem-706-0.c:10:32: error: Cannot determine that 'array1[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n         if(array2[i] == array1[j])\n                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-706-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (5110 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
707§True§"collected_code/problem-707-0.c:19:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-707-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.30 seconds (72 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
708§True§collected_code/problem-708-0.c:19:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-708-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-708-0.c:19:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 40 in approximately 0.37 seconds (109 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   3 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+] 27.7778 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-708-0.c: In function 'push':\ncollected_code/problem-708-0.c:12:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   12 |     newNode->data = data;\n      |     ~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   35 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   36 |     char str[] = ""Hello"";\n    |   37 |     Node* head = convertStringToList(str);\n    |      |                  ~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                  |\n    |      |                  (2) calling 'convertStringToList' from 'main'\n    |\n    +--> 'convertStringToList': events 3-6\n           |\n           |   17 | Node* convertStringToList(char* str) {\n           |      |       ^~~~~~~~~~~~~~~~~~~\n           |      |       |\n           |      |       (3) entry to 'convertStringToList'\n           |......\n           |   20 |     for (int i = len - 1; i >= 0; i--) {\n           |      |                           ~~~~~~\n           |      |                             |\n           |      |                             (4) following 'true' branch (when 'i >= 0')...\n           |   21 |         head = push(head, str[i]);\n           |      |                ~~~~~~~~~~~~~~~~~~\n           |      |                |             |\n           |      |                |             (5) ...to here\n           |      |                (6) calling 'push' from 'convertStringToList'\n           |\n           +--> 'push': events 7-9\n                  |\n                  |   10 | Node* push(Node* head, char data) {\n                  |      |       ^~~~\n                  |      |       |\n                  |      |       (7) entry to 'push'\n                  |   11 |     Node* newNode = (Node*)malloc(sizeof(Node));\n                  |      |                            ~~~~~~~~~~~~~~~~~~~~\n                  |      |                            |\n                  |      |                            (8) this call could return NULL\n                  |   12 |     newNode->data = data;\n                  |      |     ~~~~~~~~~~~~~~~~~~~~\n                  |      |                   |\n                  |      |                   (9) 'newNode' could be NULL: unchecked value from (8)\n                  |\n"
709§True§collected_code/problem-709-0.c:6:31: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int currentKey = tuple[i];\n                              ^\ncollected_code/problem-709-0.c:11:22: error: Cannot determine that 'tuple[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (tuple[j] == currentKey) {\n                     ^\ncollected_code/problem-709-0.c:21:26: error: Cannot determine that 'tuple[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (tuple[k] == currentKey) {\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-709-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.01 seconds (6038 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 35.7143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
710§True§collected_code/problem-710-0.c:4:22: error: Cannot determine that 'tuple[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int first = tuple[0];\n                     ^\ncollected_code/problem-710-0.c:5:21: error: Cannot determine that 'tuple[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int last = tuple[size - 1];\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-710-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (2043 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 153.846 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
711§True§"collected_code/problem-711-0.c:32:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-711-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.48 seconds (83 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
712§True§"collected_code/problem-712-0.c:11:21: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (list[i] == result[k]) {\n                    ^\ncollected_code/problem-712-0.c:11:34: error: Cannot determine that 'result[k]' is initialized [premium-bughuntingUninit]\n            if (list[i] == result[k]) {\n                                 ^\ncollected_code/problem-712-0.c:18:31: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            result[j++] = list[i];\n                              ^\ncollected_code/problem-712-0.c:24:29: error: Cannot determine that 'result[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", result[i]);\n                            ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-712-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.36 seconds (112 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 181.818 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
713§False§collected_code/problem-713-0.c:5:18: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple[i] < 0) {\n                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-713-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 9 in approximately 0.01 seconds (1593 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
714§True§"collected_code/problem-714-0.c:36:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-714-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.01 seconds (2845 lines/second)\nPhysical Source Lines of Code (SLOC) = 37\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 81.0811 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
715§True§Checking collected_code/problem-715-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-715-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-715-0.c:17:  [2] (integer) atoi:\n  Unless checked, the resulting number can exceed the expected range\n  (CWE-190). If source untrusted, check both minimum and maximum, even if the\n  input had no minus sign (large numbers can roll over into negative number;\n  consider saving to an unsigned value if that is intended).\ncollected_code/problem-715-0.c:11:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 39 in approximately 0.51 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   2 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 129.032 [1+] 64.5161 [2+] 32.2581 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-715-0.c: In function 'convertStringToTuple':\ncollected_code/problem-715-0.c:17:24: warning: dereference of possibly-NULL 'values' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   17 |         values[size++] = atoi(token);\n      |         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~\n  'convertStringToTuple': event 1\n    |\n    |   12 |     int* values = malloc(length * sizeof(int));\n    |      |                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (1) this call could return NULL\n    |\n  'convertStringToTuple': events 2-4\n    |\n    |   16 |     while (token != NULL) {\n    |      |                  ^\n    |      |                  |\n    |      |                  (2) following 'true' branch (when 'token' is non-NULL)...\n    |   17 |         values[size++] = atoi(token);\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                    |   |\n    |      |                    |   (4) 'values + (long unsigned int)size * 4' could be NULL: unchecked value from (1)\n    |      |                    (3) ...to here\n    |\n
716§True§"collected_code/problem-716-0.c:15:18: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &side);\n                 ^\ncollected_code/problem-716-0.c:18:37: error: Cannot determine that 'side' is initialized [premium-bughuntingUninit]\n    float perimeter = findPerimeter(side);\n                                    ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-716-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (2773 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
717§False§collected_code/problem-717-0.c:8:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        mean += arr[i];\n                   ^\ncollected_code/problem-717-0.c:14:28: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        variance += pow(arr[i] - mean, 2);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-717-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.67 seconds (31 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
718§True§Checking collected_code/problem-718-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-718-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 74 in approximately 0.31 seconds (237 lines/second)\nPhysical Source Lines of Code (SLOC) = 57\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 70.1754 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-718-0.c: In function 'push':\ncollected_code/problem-718-0.c:11:28: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   11 |     Node* newNode = (Node*)malloc(sizeof(Node));\n      |                            ^~~~~~\ncollected_code/problem-718-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-718-0.c:11:28: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   11 |     Node* newNode = (Node*)malloc(sizeof(Node));\n      |                            ^~~~~~\ncollected_code/problem-718-0.c:11:28: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-718-0.c:12:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   12 |     newNode->data = data;\n      |     ~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   56 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   59 |     push(&originalList, 6);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'push' from 'main'\n    |\n    +--> 'push': events 3-5\n           |\n           |   10 | void push(Node** head, int data) {\n           |      |      ^~~~\n           |      |      |\n           |      |      (3) entry to 'push'\n           |   11 |     Node* newNode = (Node*)malloc(sizeof(Node));\n           |      |                            ~~~~~~~~~~~~~~~~~~~~\n           |      |                            |\n           |      |                            (4) this call could return NULL\n           |   12 |     newNode->data = data;\n           |      |     ~~~~~~~~~~~~~~~~~~~~\n           |      |                   |\n           |      |                   (5) 'newNode' could be NULL: unchecked value from (4)\n           |\n
719§False§collected_code/problem-719-0.c:4:12: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (str[0] == 'a') {\n           ^\ncollected_code/problem-719-0.c:6:19: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        while (str[i] == 'b') {\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-719-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 11 in approximately 0.01 seconds (1681 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
720§True§collected_code/problem-720-0.c:5:42: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        tuple[tupleSize + i] = dictionary[i];\n                                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-720-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2785 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
721§True§"collected_code/problem-721-0.c:15:29: error: Cannot determine that 'matrix[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += matrix[i][j];\n                            ^\ncollected_code/problem-721-0.c:23:42: error: Cannot determine that 'matrix[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                maxAvgPath[j] = matrix[i][j];\n                                         ^\ncollected_code/problem-721-0.c:31:33: error: Cannot determine that 'maxAvgPath[j]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", maxAvgPath[j]);\n                                ^\ncollected_code/problem-721-0.c:41:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-721-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 55 in approximately 0.01 seconds (8065 lines/second)\nPhysical Source Lines of Code (SLOC) = 47\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.936 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
722§True§Checking collected_code/problem-722-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-722-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.41 seconds (73 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
723§True§"collected_code/problem-723-0.c:12:25: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int num1 = list1[i];\n                        ^\ncollected_code/problem-723-0.c:15:29: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int num2 = list2[j];\n                            ^\ncollected_code/problem-723-0.c:33:18: error: Cannot determine that 'size' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &size);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-723-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 48 in approximately 0.48 seconds (100 lines/second)\nPhysical Source Lines of Code (SLOC) = 37\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 189.189 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
724§True§Checking collected_code/problem-724-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-724-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.31 seconds (86 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
725§True§collected_code/problem-725-0.c:14:34: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int result = regexec(&regex, string, 1, matches, 0);\n                                 ^\ncollected_code/problem-725-0.c:16:28: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n        int start = matches[0].rm_so + 1;\n                           ^\ncollected_code/problem-725-0.c:17:26: error: Cannot determine that 'matches[0]' is initialized [premium-bughuntingUninit]\n        int end = matches[0].rm_eo - 1;\n                         ^\ncollected_code/problem-725-0.c:19:17: error: Cannot determine that 'extractedValue[0]' is initialized [premium-bughuntingUninit]\n        strncpy(extractedValue, string + start, end - start);\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-725-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-725-0.c:18:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-725-0.c:19:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 34 in approximately 0.01 seconds (4016 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   4 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+] 66.6667 [2+] 33.3333 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-725-0.c: In function 'extractValues':\ncollected_code/problem-725-0.c:19:9: warning: implicit declaration of function 'strncpy' [-Wimplicit-function-declaration]\n   19 |         strncpy(extractedValue, string + start, end - start);\n      |         ^~~~~~~\ncollected_code/problem-725-0.c:3:1: note: include '<string.h>' or provide a declaration of 'strncpy'\n    2 | #include <regex.h>\n  +++ |+#include <string.h>\n    3 | \ncollected_code/problem-725-0.c:19:9: warning: incompatible implicit declaration of built-in function 'strncpy' [-Wbuiltin-declaration-mismatch]\n   19 |         strncpy(extractedValue, string + start, end - start);\n      |         ^~~~~~~\ncollected_code/problem-725-0.c:19:9: note: include '<string.h>' or provide a declaration of 'strncpy'\n
726§True§collected_code/problem-726-0.c:5:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int product = arr[i] * arr[i - 1];\n                         ^\ncollected_code/problem-726-0.c:5:35: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int product = arr[i] * arr[i - 1];\n                                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-726-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.38 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 13\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 76.9231 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
727§True§collected_code/problem-727-0.c:17:27: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    ret = regexec(&regex, str, 0, NULL, 0);\n                          ^\ncollected_code/problem-727-0.c:33:21: error: Cannot determine that 'result[0]' is initialized [premium-bughuntingUninit]\n        strcpy(str, result);\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-727-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-727-0.c:33:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-727-0.c:42:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-727-0.c:23:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-727-0.c:28:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\ncollected_code/problem-727-0.c:32:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\n\nANALYSIS SUMMARY:\n\nHits = 5\nLines analyzed = 45 in approximately 0.33 seconds (135 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   2 [1]   3 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   7 [1+]   5 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 194.444 [1+] 138.889 [2+] 55.5556 [3+] 27.7778 [4+] 27.7778 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-727-0.c: In function 'removeSpecialCharacters':\ncollected_code/problem-727-0.c:23:31: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   23 |         char* result = (char*)malloc(sizeof(char) * (strlen(str) + 1));\n      |                               ^~~~~~\ncollected_code/problem-727-0.c:4:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    3 | #include <string.h>\n  +++ |+#include <stdlib.h>\n    4 | \ncollected_code/problem-727-0.c:23:31: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   23 |         char* result = (char*)malloc(sizeof(char) * (strlen(str) + 1));\n      |                               ^~~~~~\ncollected_code/problem-727-0.c:23:31: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-727-0.c:34:9: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   34 |         free(result);\n      |         ^~~~\ncollected_code/problem-727-0.c:34:9: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-727-0.c:34:9: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-727-0.c:34:9: note: include '<stdlib.h>' or provide a declaration of 'free'\n
728§True§collected_code/problem-728-0.c:6:19: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      sum += list1[i] + list2[i];\n                  ^\ncollected_code/problem-728-0.c:6:30: error: Cannot determine that 'list2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      sum += list1[i] + list2[i];\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-728-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.56 seconds (31 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
729§True§collected_code/problem-729-0.c:37:31: error: Uninitialized struct member: dummy.next [uninitStructMember]\n    struct ListNode* result = dummy->next;\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-729-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 68 in approximately 0.43 seconds (157 lines/second)\nPhysical Source Lines of Code (SLOC) = 53\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 18.8679 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-729-0.c: In function 'addTwoLists':\ncollected_code/problem-729-0.c:10:48: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   10 |     struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n      |                                                ^~~~~~\ncollected_code/problem-729-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-729-0.c:10:48: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   10 |     struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n      |                                                ^~~~~~\ncollected_code/problem-729-0.c:10:48: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-729-0.c:38:5: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   38 |     free(dummy);\n      |     ^~~~\ncollected_code/problem-729-0.c:38:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-729-0.c:38:5: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-729-0.c:38:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-729-0.c: In function 'main':\ncollected_code/problem-729-0.c:44:45: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   44 |     struct ListNode* l1 = (struct ListNode*)malloc(sizeof(struct ListNode));\n      |                                             ^~~~~~\ncollected_code/problem-729-0.c:44:45: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-729-0.c: In function 'addTwoLists':\ncollected_code/problem-729-0.c:30:22: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   30 |         newNode->val = sum % 10;\n      |         ~~~~~~~~~~~~~^~~~~~~~~~\n  'addTwoLists': events 1-6\n    |\n    |   14 |     while (l1 || l2 || carry) {\n    |      |            ~~~~~~~~~^~~~~~~~\n    |      |                     |\n    |      |                     (1) following 'true' branch (when 'l1' is non-NULL)...\n    |   15 |         int sum = carry;\n    |      |             ~~~      \n    |      |             |\n    |      |             (2) ...to here\n    |   16 | \n    |   17 |         if (l1) {\n    |      |            ~         \n    |      |            |\n    |      |            (3) following 'true' branch (when 'l1' is non-NULL)...\n    |   18 |             sum += l1->val;\n    |      |                    ~~~~~~~\n    |      |                      |\n    |      |                      (4) ...to here\n    |......\n    |   29 |         struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                                      |\n    |      |                                                      (5) this call could return NULL\n    |   30 |         newNode->val = sum % 10;\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                      |\n    |      |                      (6) 'newNode' could be NULL: unchecked value from (5)\n    |\ncollected_code/problem-729-0.c:33:23: warning: dereference of possibly-NULL 'current' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   33 |         current->next = newNode;\n      |         ~~~~~~~~~~~~~~^~~~~~~~~\n  'addTwoLists': events 1-6\n    |\n    |   10 |     struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                                |\n    |      |                                                (1) this call could return NULL\n    |......\n    |   14 |     while (l1 || l2 || carry) {\n    |      |            ~~~~~~~~~~~~~~~~~                    \n    |      |                     |\n    |      |                     (2) following 'true' branch (when 'l1' is non-NULL)...\n    |   15 |         int sum = carry;\n    |      |             ~~~                                 \n    |      |             |\n    |      |             (3) ...to here\n    |   16 | \n    |   17 |         if (l1) {\n    |      |            ~                                    \n    |      |            |\n    |      |            (4) following 'true' branch (when 'l1' is non-NULL)...\n    |   18 |             sum += l1->val;\n    |      |                    ~~~~~~~                      \n    |      |                      |\n    |      |                      (5) ...to here\n    |......\n    |   33 |         current->next = newNode;\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~                 \n    |      |                       |\n    |      |                       (6) 'current' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-729-0.c:37:22: warning: use of uninitialized value '*dummy.next' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   37 |     struct ListNode* result = dummy->next;\n      |                      ^~~~~~\n  'addTwoLists': events 1-4\n    |\n    |   10 |     struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                                |\n    |      |                                                (1) region created on heap here\n    |......\n    |   14 |     while (l1 || l2 || carry) {\n    |      |            ~~~~~~~~~~~~~~~~~                    \n    |      |                     |\n    |      |                     (2) following 'false' branch...\n    |......\n    |   37 |     struct ListNode* result = dummy->next;\n    |      |                      ~~~~~~                     \n    |      |                      |\n    |      |                      (3) ...to here\n    |      |                      (4) use of uninitialized value '*dummy.next' here\n    |\ncollected_code/problem-729-0.c:37:22: warning: dereference of possibly-NULL 'dummy' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   37 |     struct ListNode* result = dummy->next;\n      |                      ^~~~~~\n  'addTwoLists': events 1-4\n    |\n    |   10 |     struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                                |\n    |      |                                                (1) this call could return NULL\n    |......\n    |   14 |     while (l1 || l2 || carry) {\n    |      |            ~~~~~~~~~~~~~~~~~                    \n    |      |                     |\n    |      |                     (2) following 'false' branch...\n    |......\n    |   37 |     struct ListNode* result = dummy->next;\n    |      |                      ~~~~~~                     \n    |      |                      |\n    |      |                      (3) ...to here\n    |      |                      (4) 'dummy' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-729-0.c: In function 'main':\ncollected_code/problem-729-0.c:45:13: warning: dereference of possibly-NULL 'l1' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   45 |     l1->val = 2;\n      |     ~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   44 |     struct ListNode* l1 = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                             |\n    |      |                                             (1) this call could return NULL\n    |   45 |     l1->val = 2;\n    |      |     ~~~~~~~~~~~                              \n    |      |             |\n    |      |             (2) 'l1' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-729-0.c:47:19: warning: dereference of possibly-NULL '*l1.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   47 |     l1->next->val = 4;\n      |     ~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   46 |     l1->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                  |\n    |      |                                  (1) this call could return NULL\n    |   47 |     l1->next->val = 4;\n    |      |     ~~~~~~~~~~~~~~~~~             \n    |      |                   |\n    |      |                   (2) '*l1.next' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-729-0.c:49:25: warning: dereference of possibly-NULL '*l1_22->next.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   49 |     l1->next->next->val = 3;\n      |     ~~~~~~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   48 |     l1->next->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                        |\n    |      |                                        (1) this call could return NULL\n    |   49 |     l1->next->next->val = 3;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~             \n    |      |                         |\n    |      |                         (2) '*l1_22->next.next' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-729-0.c:53:13: warning: dereference of possibly-NULL 'l2' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   53 |     l2->val = 5;\n      |     ~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   52 |     struct ListNode* l2 = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                             |\n    |      |                                             (1) this call could return NULL\n    |   53 |     l2->val = 5;\n    |      |     ~~~~~~~~~~~                              \n    |      |             |\n    |      |             (2) 'l2' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-729-0.c:55:19: warning: dereference of possibly-NULL '*l2.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   55 |     l2->next->val = 6;\n      |     ~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   54 |     l2->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                  |\n    |      |                                  (1) this call could return NULL\n    |   55 |     l2->next->val = 6;\n    |      |     ~~~~~~~~~~~~~~~~~             \n    |      |                   |\n    |      |                   (2) '*l2.next' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-729-0.c:57:25: warning: dereference of possibly-NULL '*l2_32->next.next' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   57 |     l2->next->next->val = 4;\n      |     ~~~~~~~~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   56 |     l2->next->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    |      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                        |\n    |      |                                        (1) this call could return NULL\n    |   57 |     l2->next->next->val = 4;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~             \n    |      |                         |\n    |      |                         (2) '*l2_32->next.next' could be NULL: unchecked value from (1)\n    |\n
730§True§collected_code/problem-730-0.c:12:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] != arr[i+1]) {\n               ^\ncollected_code/problem-730-0.c:12:26: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] != arr[i+1]) {\n                         ^\ncollected_code/problem-730-0.c:13:28: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            temp[j++] = arr[i];\n                           ^\ncollected_code/problem-730-0.c:17:20: error: Cannot determine that 'arr[n-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    temp[j++] = arr[n-1];\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-730-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (5362 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 74.0741 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
731§True§"collected_code/problem-731-0.c:12:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-731-0.c:14:18: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &height);\n                 ^\ncollected_code/problem-731-0.c:15:55: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    float lateralSurfaceArea = findLateralSurfaceArea(radius, height);\n                                                      ^\ncollected_code/problem-731-0.c:15:63: error: Cannot determine that 'height' is initialized [premium-bughuntingUninit]\n    float lateralSurfaceArea = findLateralSurfaceArea(radius, height);\n                                                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-731-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2354 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 312.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-731-0.c: In function 'findLateralSurfaceArea':\ncollected_code/problem-731-0.c:4:25: warning: implicit declaration of function 'sqrt' [-Wimplicit-function-declaration]\n    4 |     float slantHeight = sqrt(radius * radius + height * height);\n      |                         ^~~~\ncollected_code/problem-731-0.c:2:1: note: include '<math.h>' or provide a declaration of 'sqrt'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-731-0.c:4:25: warning: incompatible implicit declaration of built-in function 'sqrt' [-Wbuiltin-declaration-mismatch]\n    4 |     float slantHeight = sqrt(radius * radius + height * height);\n      |                         ^~~~\ncollected_code/problem-731-0.c:4:25: note: include '<math.h>' or provide a declaration of 'sqrt'\n
732§True§Checking collected_code/problem-732-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-732-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (3030 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
733§True§collected_code/problem-733-0.c:10:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] == target) {\n               ^\ncollected_code/problem-733-0.c:14:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] < target) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-733-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.37 seconds (107 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 64.5161 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
734§True§collected_code/problem-734-0.c:8:27: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            product *= arr[j];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-734-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (2916 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
735§True§collected_code/problem-735-0.c:8:28: error: Signed integer overflow for expression '1<<(numOfBits-1)'. [integerOverflow]\n    unsigned int mask = (1 << (numOfBits - 1)) | ((1 << (numOfBits - 1)) - 1);\n                           ^\ncollected_code/problem-735-0.c:5:33: note: Assignment 'numOfBits=sizeof(num)*8', assigned value is 32\n    int numOfBits = sizeof(num) * 8;\n                                ^\ncollected_code/problem-735-0.c:8:28: note: Integer overflow\n    unsigned int mask = (1 << (numOfBits - 1)) | ((1 << (numOfBits - 1)) - 1);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-735-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3419 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 142.857 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
736§False§collected_code/problem-736-0.c:9:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] == value) {\n               ^\ncollected_code/problem-736-0.c:11:23: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (arr[mid] < value) {\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-736-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (1776 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
737§False§collected_code/problem-737-0.c:7:34: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int result = regexec(&regex, str, 0, NULL, 0);\n                                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-737-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.35 seconds (51 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-737-0.c: In function 'startsWithVowel':\ncollected_code/problem-737-0.c:7:42: error: 'NULL' undeclared (first use in this function)\n    7 |     int result = regexec(&regex, str, 0, NULL, 0);\n      |                                          ^~~~\ncollected_code/problem-737-0.c:2:1: note: 'NULL' is defined in header '<stddef.h>'; did you forget to '#include <stddef.h>'?\n    1 | #include <regex.h>\n  +++ |+#include <stddef.h>\n    2 | \ncollected_code/problem-737-0.c:7:42: note: each undeclared identifier is reported only once for each function it appears in\n    7 |     int result = regexec(&regex, str, 0, NULL, 0);\n      |                                          ^~~~\n
738§True§"collected_code/problem-738-0.c:16:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-738-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.50 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
739§True§"collected_code/problem-739-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-739-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2812 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
740§True§collected_code/problem-740-0.c:9:25: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        dictionary[tuple[i]] = tuple[i + 1];\n                        ^\ncollected_code/problem-740-0.c:9:37: error: Cannot determine that 'tuple[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        dictionary[tuple[i]] = tuple[i + 1];\n                                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-740-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.35 seconds (71 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
741§False§collected_code/problem-741-0.c:6:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i] != '\0')\n              ^\ncollected_code/problem-741-0.c:8:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] != str[0])\n               ^\ncollected_code/problem-741-0.c:8:26: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] != str[0])\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-741-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.01 seconds (943 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
742§True§"collected_code/problem-742-0.c:16:19: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &sideLength);\n                  ^\ncollected_code/problem-742-0.c:18:33: error: Cannot determine that 'sideLength' is initialized [premium-bughuntingUninit]\n    area = calculateTetrahedron(sideLength);\n                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-742-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.33 seconds (66 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
743§True§collected_code/problem-743-0.c:8:20: error: Cannot determine that 'list[length-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        temp = list[length-1];\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-743-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.55 seconds (53 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
744§True§Checking collected_code/problem-744-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-744-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (3489 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
745§True§"collected_code/problem-745-0.c:28:18: error: Cannot determine that 'lower' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &lower);\n                 ^\ncollected_code/problem-745-0.c:30:18: error: Cannot determine that 'upper' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &upper);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-745-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.01 seconds (4015 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 233.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
746§True§"collected_code/problem-746-0.c:17:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-746-0.c:20:18: error: Cannot determine that 'angle' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &angle);\n                 ^\ncollected_code/problem-746-0.c:22:35: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    sectorArea = findAreaOfSector(radius, angle);\n                                  ^\ncollected_code/problem-746-0.c:22:43: error: Cannot determine that 'angle' is initialized [premium-bughuntingUninit]\n    sectorArea = findAreaOfSector(radius, angle);\n                                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-746-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.01 seconds (3280 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 277.778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
747§True§collected_code/problem-747-0.c:17:27: error: Cannot determine that 'X[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1])\n                          ^\ncollected_code/problem-747-0.c:17:39: error: Cannot determine that 'Y[j-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1])\n                                      ^\ncollected_code/problem-747-0.c:17:63: error: Cannot determine that 'Z[k-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                else if (X[i - 1] == Y[j - 1] && X[i - 1] == Z[k - 1])\n                                                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-747-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-747-0.c:32:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-747-0.c:33:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-747-0.c:34:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 39 in approximately 0.57 seconds (68 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   1 [1]   3 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   3 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 121.212 [1+] 90.9091 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
748§True§collected_code/problem-748-0.c:9:47: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char *result = (char *) malloc(2 * strlen(str) * sizeof(char));\n                                              ^\ncollected_code/problem-748-0.c:23:17: error: Cannot determine that 'result[0]' is initialized [premium-bughuntingUninit]\n    strcpy(str, result);\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-748-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-748-0.c:23:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-748-0.c:9:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 31 in approximately 0.56 seconds (55 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   1 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 115.385 [1+] 76.9231 [2+] 38.4615 [3+] 38.4615 [4+] 38.4615 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-748-0.c: In function 'add_spaces':\ncollected_code/problem-748-0.c:9:40: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n    9 |     char *result = (char *) malloc(2 * strlen(str) * sizeof(char));\n      |                                        ^~~~~~\ncollected_code/problem-748-0.c:4:1: note: include '<string.h>' or provide a declaration of 'strlen'\n    3 | #include <regex.h>\n  +++ |+#include <string.h>\n    4 | \ncollected_code/problem-748-0.c:9:40: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n    9 |     char *result = (char *) malloc(2 * strlen(str) * sizeof(char));\n      |                                        ^~~~~~\ncollected_code/problem-748-0.c:9:40: note: include '<string.h>' or provide a declaration of 'strlen'\ncollected_code/problem-748-0.c:23:5: warning: implicit declaration of function 'strcpy' [-Wimplicit-function-declaration]\n   23 |     strcpy(str, result);\n      |     ^~~~~~\ncollected_code/problem-748-0.c:23:5: note: include '<string.h>' or provide a declaration of 'strcpy'\ncollected_code/problem-748-0.c:23:5: warning: incompatible implicit declaration of built-in function 'strcpy' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-748-0.c:23:5: note: include '<string.h>' or provide a declaration of 'strcpy'\ncollected_code/problem-748-0.c:14:25: warning: dereference of possibly-NULL 'result' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   14 |             result[i++] = *str++;\n      |             ~~~~~~~~~~~~^~~~~~~~\n  'add_spaces': events 1-6\n    |\n    |    9 |     char *result = (char *) malloc(2 * strlen(str) * sizeof(char));\n    |      |                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                             |\n    |      |                             (1) this call could return NULL\n    |......\n    |   12 |     while (*str != '\0') {\n    |      |            ~~~~~~~~~~~~      \n    |      |                 |\n    |      |                 (2) following 'true' branch...\n    |   13 |         if (regexec(&regex, str, 0, NULL, 0) == REG_NOMATCH) {\n    |      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |            ||\n    |      |            |(3) ...to here\n    |      |            (4) following 'true' branch...\n    |   14 |             result[i++] = *str++;\n    |      |             ~~~~~~~~~~~~~~~~~~~~\n    |      |                         |     |\n    |      |                         |     (5) ...to here\n    |      |                         (6) 'result + i' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-748-0.c:16:25: warning: dereference of possibly-NULL 'result' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   16 |             result[i++] = ' ';\n      |             ~~~~~~~~~~~~^~~~~\n  'add_spaces': events 1-6\n    |\n    |    9 |     char *result = (char *) malloc(2 * strlen(str) * sizeof(char));\n    |      |                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                             |\n    |      |                             (1) this call could return NULL\n    |......\n    |   12 |     while (*str != '\0') {\n    |      |            ~~~~~~~~~~~~      \n    |      |                 |\n    |      |                 (2) following 'true' branch...\n    |   13 |         if (regexec(&regex, str, 0, NULL, 0) == REG_NOMATCH) {\n    |      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |            ||\n    |      |            |(3) ...to here\n    |      |            (4) following 'false' branch...\n    |......\n    |   16 |             result[i++] = ' ';\n    |      |             ~~~~~~~~~~~~~~~~~\n    |      |                     |   |\n    |      |                     |   (6) 'result + i' could be NULL: unchecked value from (1)\n    |      |                     (5) ...to here\n    |\ncollected_code/problem-748-0.c:21:15: warning: dereference of possibly-NULL 'result' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   21 |     result[i] = '\0';\n      |     ~~~~~~~~~~^~~~~~\n  'add_spaces': events 1-4\n    |\n    |    9 |     char *result = (char *) malloc(2 * strlen(str) * sizeof(char));\n    |      |                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                             |\n    |      |                             (1) this call could return NULL\n    |......\n    |   12 |     while (*str != '\0') {\n    |      |            ~~~~~~~~~~~~      \n    |      |                 |\n    |      |                 (2) following 'false' branch...\n    |......\n    |   21 |     result[i] = '\0';\n    |      |     ~~~~~~~~~~~~~~~~         \n    |      |           |   |\n    |      |           |   (4) 'result + i' could be NULL: unchecked value from (1)\n    |      |           (3) ...to here\n    |\n
749§True§collected_code/problem-749-0.c:8:18: error: Cannot determine that 'str1' is initialized [premium-bughuntingUninit]\n    return atoi(*str1) - atoi(*str2);\n                 ^\ncollected_code/problem-749-0.c:8:32: error: Cannot determine that 'str2' is initialized [premium-bughuntingUninit]\n    return atoi(*str1) - atoi(*str2);\n                               ^\ncollected_code/problem-749-0.c:12:11: error: Cannot determine that 'strings[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    qsort(strings, numStrings, sizeof(char *), compare);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-749-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-749-0.c:8:  [2] (integer) atoi:\n  Unless checked, the resulting number can exceed the expected range\n  (CWE-190). If source untrusted, check both minimum and maximum, even if the\n  input had no minus sign (large numbers can roll over into negative number;\n  consider saving to an unsigned value if that is intended).\ncollected_code/problem-749-0.c:8:  [2] (integer) atoi:\n  Unless checked, the resulting number can exceed the expected range\n  (CWE-190). If source untrusted, check both minimum and maximum, even if the\n  input had no minus sign (large numbers can roll over into negative number;\n  consider saving to an unsigned value if that is intended).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 25 in approximately 0.02 seconds (1081 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   2 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   2 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+] 100 [2+] 100 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
750§True§Checking collected_code/problem-750-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-750-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 50 in approximately 0.01 seconds (7018 lines/second)\nPhysical Source Lines of Code (SLOC) = 38\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 26.3158 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-750-0.c: In function 'addTupleToList':\ncollected_code/problem-750-0.c:14:29: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   14 |     Node *newNode = (Node *)malloc(sizeof(Node));\n      |                             ^~~~~~\ncollected_code/problem-750-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-750-0.c:14:29: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   14 |     Node *newNode = (Node *)malloc(sizeof(Node));\n      |                             ^~~~~~\ncollected_code/problem-750-0.c:14:29: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-750-0.c:15:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   15 |     newNode->data = tuple;\n      |     ~~~~~~~~~~~~~~^~~~~~~\n  'addTupleToList': events 1-2\n    |\n    |   14 |     Node *newNode = (Node *)malloc(sizeof(Node));\n    |      |                             ^~~~~~~~~~~~~~~~~~~~\n    |      |                             |\n    |      |                             (1) this call could return NULL\n    |   15 |     newNode->data = tuple;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~    \n    |      |                   |\n    |      |                   (2) 'newNode' could be NULL: unchecked value from (1)\n    |\n
751§True§collected_code/problem-751-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > arr[2 * i + 1])\n               ^\ncollected_code/problem-751-0.c:6:25: error: Cannot determine that 'arr[2*i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] > arr[2 * i + 1])\n                        ^\ncollected_code/problem-751-0.c:8:33: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (2 * i + 2 < n && arr[i] > arr[2 * i + 2])\n                                ^\ncollected_code/problem-751-0.c:8:42: error: Cannot determine that 'arr[2*i+2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (2 * i + 2 < n && arr[i] > arr[2 * i + 2])\n                                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-751-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.48 seconds (48 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
752§True§Checking collected_code/problem-752-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-752-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.57 seconds (44 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
753§True§Checking collected_code/problem-753-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-753-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-753-0.c:6:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 43 in approximately 0.01 seconds (6251 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   1 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+] 31.25 [2+] 31.25 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-753-0.c: In function 'findMinKRecords':\ncollected_code/problem-753-0.c:16:30: warning: use of uninitialized value '*tupleList_47(D) + _15' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   16 |                 tupleList[j] = tupleList[j + 1];\n      |                 ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n  'main': events 1-3\n    |\n    |   28 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   29 |     // Sample Tuple List\n    |   30 |     struct Tuple tupleList[] = {\n    |      |                  ~~~~~~~~~\n    |      |                  |\n    |      |                  (2) region created on stack here\n    |......\n    |   41 |     findMinKRecords(tupleList, n, k);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (3) calling 'findMinKRecords' from 'main'\n    |\n    +--> 'findMinKRecords': events 4-19\n           |\n           |   10 | void findMinKRecords(struct Tuple tupleList[], int n, int k) {\n           |      |      ^~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'findMinKRecords'\n           |   11 |     // Sort the tuple list in ascending order based on number\n           |   12 |     for (int i = 0; i < n - 1; i++) {\n           |      |                     ~~~~~~~~~\n           |      |                       |\n           |      |                       (5) following 'true' branch...\n           |   13 |         for (int j = 0; j < n - i - 1; j++) {\n           |      |                  ~      ~~~~~~~~~~~~~\n           |      |                  |        |\n           |      |                  |        (7) following 'true' branch...\n           |      |                  |        (11) following 'true' branch...\n           |      |                  |        (15) following 'true' branch...\n           |      |                  (6) ...to here\n           |   14 |             if (tupleList[j].number > tupleList[j + 1].number) {\n           |      |                ~         ~\n           |      |                |         |\n           |      |                |         (8) ...to here\n           |      |                |         (12) ...to here\n           |      |                |         (16) ...to here\n           |      |                (9) following 'true' branch...\n           |      |                (13) following 'true' branch...\n           |      |                (17) following 'true' branch...\n           |   15 |                 struct Tuple temp = tupleList[j];\n           |      |                                              ~\n           |      |                                              |\n           |      |                                              (10) ...to here\n           |      |                                              (14) ...to here\n           |      |                                              (18) ...to here\n           |   16 |                 tupleList[j] = tupleList[j + 1];\n           |      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                              |\n           |      |                              (19) use of uninitialized value '*tupleList_47(D) + _15' here\n           |\n
754§True§"collected_code/problem-754-0.c:7:26: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (list1[i] == list2[j] && list1[i] == list3[k]) {\n                         ^\ncollected_code/problem-754-0.c:7:38: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (list1[i] == list2[j] && list1[i] == list3[k]) {\n                                     ^\ncollected_code/problem-754-0.c:7:62: error: Cannot determine that 'list3[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (list1[i] == list2[j] && list1[i] == list3[k]) {\n                                                             ^\ncollected_code/problem-754-0.c:8:40: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                    printf(""%d "", list1[i]);\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-754-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.43 seconds (58 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 45.4545 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
755§True§collected_code/problem-755-0.c:11:23: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int smallest = arr[0];\n                      ^\ncollected_code/problem-755-0.c:12:29: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int secondSmallest = arr[0];\n                            ^\ncollected_code/problem-755-0.c:16:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < smallest)\n               ^\ncollected_code/problem-755-0.c:19:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            smallest = arr[i];\n                          ^\ncollected_code/problem-755-0.c:21:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[i] < secondSmallest && arr[i] != smallest)\n                    ^\ncollected_code/problem-755-0.c:23:33: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            secondSmallest = arr[i];\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-755-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 37 in approximately 0.34 seconds (108 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 64.5161 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
756§True§collected_code/problem-756-0.c:5:18: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (string[i] != '\0') {\n                 ^\ncollected_code/problem-756-0.c:6:19: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (string[i] == 'a') {\n                  ^\ncollected_code/problem-756-0.c:7:23: error: Cannot determine that 'string[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (string[i + 1] == 'b' || string[i + 1] == '\0') {\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-756-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.66 seconds (39 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
757§True§collected_code/problem-757-0.c:9:38: error: Cannot determine that 'strList[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int len1 = strlen(strList[i]);\n                                     ^\ncollected_code/problem-757-0.c:10:38: error: Cannot determine that 'strList[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int len2 = strlen(strList[j]);\n                                     ^\ncollected_code/problem-757-0.c:18:31: error: Cannot determine that 'strList[i][k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (strList[i][k] != strList[j][len1 - k - 1]) {\n                              ^\ncollected_code/problem-757-0.c:18:48: error: Cannot determine that 'strList[j][len1-k-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (strList[i][k] != strList[j][len1 - k - 1]) {\n                                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-757-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-757-0.c:9:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-757-0.c:10:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 40 in approximately 0.01 seconds (5141 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   1 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+] 60.6061 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
758§True§Checking collected_code/problem-758-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-758-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 66 in approximately 0.80 seconds (82 lines/second)\nPhysical Source Lines of Code (SLOC) = 50\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  20 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-758-0.c: In function 'countUniqueLists':\ncollected_code/problem-758-0.c:20:17: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   20 |                 free(temp);\n      |                 ^~~~\ncollected_code/problem-758-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'free'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-758-0.c:20:17: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\n   20 |                 free(temp);\n      |                 ^~~~\ncollected_code/problem-758-0.c:20:17: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-758-0.c: In function 'main':\ncollected_code/problem-758-0.c:38:19: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   38 |     head = (Node*)malloc(sizeof(Node));\n      |                   ^~~~~~\ncollected_code/problem-758-0.c:38:19: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-758-0.c:38:19: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-758-0.c:38:19: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-758-0.c:63:9: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\n   63 |         free(temp);\n      |         ^~~~\ncollected_code/problem-758-0.c:63:9: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-758-0.c:39:16: warning: dereference of possibly-NULL 'head' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   39 |     head->data = 1;\n      |     ~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   38 |     head = (Node*)malloc(sizeof(Node));\n    |      |                   ^~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (1) this call could return NULL\n    |   39 |     head->data = 1;\n    |      |     ~~~~~~~~~~~~~~ \n    |      |                |\n    |      |                (2) 'head' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-758-0.c:42:18: warning: dereference of possibly-NULL 'second' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   42 |     second->data = 2;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   41 |     Node* second = (Node*)malloc(sizeof(Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |   42 |     second->data = 2;\n    |      |     ~~~~~~~~~~~~~~~~       \n    |      |                  |\n    |      |                  (2) 'second' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-758-0.c:45:17: warning: dereference of possibly-NULL 'third' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   45 |     third->data = 1;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   44 |     Node* third = (Node*)malloc(sizeof(Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |   45 |     third->data = 1;\n    |      |     ~~~~~~~~~~~~~~~       \n    |      |                 |\n    |      |                 (2) 'third' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-758-0.c:48:18: warning: dereference of possibly-NULL 'fourth' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   48 |     fourth->data = 3;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   47 |     Node* fourth = (Node*)malloc(sizeof(Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |   48 |     fourth->data = 3;\n    |      |     ~~~~~~~~~~~~~~~~       \n    |      |                  |\n    |      |                  (2) 'fourth' could be NULL: unchecked value from (1)\n    |\n
759§True§"collected_code/problem-759-0.c:9:13: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    sprintf(str, ""%f"", num);\n            ^\ncollected_code/problem-759-0.c:26:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &num);\n                 ^\ncollected_code/problem-759-0.c:28:31: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    if (checkDecimalPrecision(num)) {\n                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-759-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-759-0.c:7:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-759-0.c:9:  [2] (buffer) sprintf:\n  Does not check for buffer overflows (CWE-120). Use sprintf_s, snprintf, or\n  vsnprintf. Risk is low because the source has a constant maximum length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 34 in approximately 0.01 seconds (3029 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   4 [1]   0 [2]   2 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   2 [2+]   2 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 230.769 [1+] 76.9231 [2+] 76.9231 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
760§True§collected_code/problem-760-0.c:6:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] != arr[0]) {\n               ^\ncollected_code/problem-760-0.c:6:26: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] != arr[0]) {\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-760-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (3138 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 160 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
761§True§"collected_code/problem-761-0.c:17:18: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &radius);\n                 ^\ncollected_code/problem-761-0.c:20:18: error: Cannot determine that 'angle' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &angle);\n                 ^\ncollected_code/problem-761-0.c:22:33: error: Cannot determine that 'radius' is initialized [premium-bughuntingUninit]\n    result = calculateArcLength(radius, angle);\n                                ^\ncollected_code/problem-761-0.c:22:41: error: Cannot determine that 'angle' is initialized [premium-bughuntingUninit]\n    result = calculateArcLength(radius, angle);\n                                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-761-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.49 seconds (54 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 294.118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
762§True§"collected_code/problem-762-0.c:23:18: error: Cannot determine that 'month' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &month);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-762-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.68 seconds (46 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
763§False§collected_code/problem-763-0.c:9:31: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int diff = abs(arr[i] - arr[j]);\n                              ^\ncollected_code/problem-763-0.c:9:40: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int diff = abs(arr[i] - arr[j]);\n                                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-763-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (4517 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-763-0.c: In function 'minDifference':\ncollected_code/problem-763-0.c:5:19: error: 'INT_MAX' undeclared (first use in this function)\n    5 |     int minDiff = INT_MAX;\n      |                   ^~~~~~~\ncollected_code/problem-763-0.c:3:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n    2 | #include <stdlib.h>\n  +++ |+#include <limits.h>\n    3 | \ncollected_code/problem-763-0.c:5:19: note: each undeclared identifier is reported only once for each function it appears in\n    5 |     int minDiff = INT_MAX;\n      |                   ^~~~~~~\n
764§True§collected_code/problem-764-0.c:5:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-764-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] >= '0' && str[i] <= '9') {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-764-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2030 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
765§True§Checking collected_code/problem-765-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-765-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.59 seconds (48 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
766§True§"collected_code/problem-766-0.c:5:33: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""(%d, %d)\n"", arr[i], arr[i+1]);\n                                ^\ncollected_code/problem-766-0.c:5:41: error: Cannot determine that 'arr[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""(%d, %d)\n"", arr[i], arr[i+1]);\n                                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-766-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 14 in approximately 0.48 seconds (29 lines/second)\nPhysical Source Lines of Code (SLOC) = 12\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
767§True§collected_code/problem-767-0.c:7:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] + arr[j] == sum)\n                   ^\ncollected_code/problem-767-0.c:7:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] + arr[j] == sum)\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-767-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.37 seconds (54 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
768§True§"collected_code/problem-768-0.c:17:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-768-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3762 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
769§True§Checking collected_code/problem-769-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-769-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 45 in approximately 0.01 seconds (5123 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 29.4118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-769-0.c: In function 'newNode':\ncollected_code/problem-769-0.c:13:16: warning: dereference of possibly-NULL 'node' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   13 |     node->data = data;\n      |     ~~~~~~~~~~~^~~~~~\n  'newNode': events 1-2\n    |\n    |   12 |     Node* node = (Node*)malloc(sizeof(Node));\n    |      |                         ^~~~~~~~~~~~~~~~~~~~\n    |      |                         |\n    |      |                         (1) this call could return NULL\n    |   13 |     node->data = data;\n    |      |     ~~~~~~~~~~~~~~~~~    \n    |      |                |\n    |      |                (2) 'node' could be NULL: unchecked value from (1)\n    |\n
770§True§"collected_code/problem-770-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-770-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.48 seconds (48 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
771§True§collected_code/problem-771-0.c:11:31: error: Cannot determine that 'expression[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; expression[i] != '\0'; i++) {\n                              ^\ncollected_code/problem-771-0.c:12:23: error: Cannot determine that 'expression[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (expression[i] == '(' || expression[i] == '[' || expression[i] == '{') {\n                      ^\ncollected_code/problem-771-0.c:13:38: error: Cannot determine that 'expression[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            stack[++top] = expression[i];\n                                     ^\ncollected_code/problem-771-0.c:15:28: error: Cannot determine that 'expression[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (expression[i] == ')' || expression[i] == ']' || expression[i] == '}') {\n                           ^\ncollected_code/problem-771-0.c:19:33: error: Cannot determine that 'expression[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            else if ((expression[i] == ')' && stack[top] != '(') ||\n                                ^\ncollected_code/problem-771-0.c:19:52: error: Cannot determine that 'stack[top]' is initialized [premium-bughuntingUninit]\n            else if ((expression[i] == ')' && stack[top] != '(') ||\n                                                   ^\ncollected_code/problem-771-0.c:20:33: error: Cannot determine that 'expression[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                     (expression[i] == ']' && stack[top] != '[') ||\n                                ^\ncollected_code/problem-771-0.c:20:52: error: Cannot determine that 'stack[top]' is initialized [premium-bughuntingUninit]\n                     (expression[i] == ']' && stack[top] != '[') ||\n                                                   ^\ncollected_code/problem-771-0.c:21:33: error: Cannot determine that 'expression[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                     (expression[i] == '}' && stack[top] != '{')) {\n                                ^\ncollected_code/problem-771-0.c:21:52: error: Cannot determine that 'stack[top]' is initialized [premium-bughuntingUninit]\n                     (expression[i] == '}' && stack[top] != '{')) {\n                                                   ^\ncollected_code/problem-771-0.c:37:11: error: Cannot determine that 'expression[0]' is initialized [premium-bughuntingUninit]\n    fgets(expression, MAX_SIZE, stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-771-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-771-0.c:8:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-771-0.c:34:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 46 in approximately 0.01 seconds (6567 lines/second)\nPhysical Source Lines of Code (SLOC) = 38\nHits@level = [0]   3 [1]   0 [2]   2 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 131.579 [1+] 52.6316 [2+] 52.6316 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
772§True§"collected_code/problem-772-0.c:8:18: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    len = strlen(str);\n                 ^\ncollected_code/problem-772-0.c:43:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str), stdin);\n          ^\ncollected_code/problem-772-0.c:45:18: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &k);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-772-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-772-0.c:39:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-772-0.c:8:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 49 in approximately 0.01 seconds (7131 lines/second)\nPhysical Source Lines of Code (SLOC) = 37\nHits@level = [0]   5 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 189.189 [1+] 54.0541 [2+] 27.027 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-772-0.c: In function 'removeWordsWithKLength':\ncollected_code/problem-772-0.c:13:13: warning: implicit declaration of function 'isalnum' [-Wimplicit-function-declaration]\n   13 |         if (isalnum(str[i])) {\n      |             ^~~~~~~\ncollected_code/problem-772-0.c:3:1: note: include '<ctype.h>' or provide a declaration of 'isalnum'\n    2 | #include <string.h>\n  +++ |+#include <ctype.h>\n    3 | \n
773§True§Checking collected_code/problem-773-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-773-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-773-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-773-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 33 in approximately 0.01 seconds (4392 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   2 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 153.846 [1+] 76.9231 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
774§False§Checking collected_code/problem-774-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-774-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (4028 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-774-0.c: In function 'isValidEmail':\ncollected_code/problem-774-0.c:15:38: error: 'NULL' undeclared (first use in this function)\n   15 |     reti = regexec(&regex, email, 0, NULL, 0);\n      |                                      ^~~~\ncollected_code/problem-774-0.c:2:1: note: 'NULL' is defined in header '<stddef.h>'; did you forget to '#include <stddef.h>'?\n    1 | #include <regex.h>\n  +++ |+#include <stddef.h>\n    2 | \ncollected_code/problem-774-0.c:15:38: note: each undeclared identifier is reported only once for each function it appears in\n   15 |     reti = regexec(&regex, email, 0, NULL, 0);\n      |                                      ^~~~\n
775§True§collected_code/problem-775-0.c:5:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % 2 == 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-775-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3624 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
776§True§collected_code/problem-776-0.c:7:14: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while(str[i] != '\0') {\n             ^\ncollected_code/problem-776-0.c:8:29: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        char curr_char = str[i];\n                            ^\ncollected_code/problem-776-0.c:11:17: error: Cannot determine that 'str[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            (str[i-1] == 'a' || str[i-1] == 'e' || str[i-1] == 'i' || str[i-1] == 'o' || str[i-1] == 'u' || str[i-1] == 'A' || str[i-1] == 'E' || str[i-1] == 'I' || str[i-1] == 'O' || str[i-1] == 'U') &&\n                ^\ncollected_code/problem-776-0.c:12:17: error: Cannot determine that 'str[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            (str[i+1] == 'a' || str[i+1] == 'e' || str[i+1] == 'i' || str[i+1] == 'o' || str[i+1] == 'u' || str[i+1] == 'A' || str[i+1] == 'E' || str[i+1] == 'I' || str[i+1] == 'O' || str[i+1] == 'U'))\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-776-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.63 seconds (44 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 45.4545 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
777§False§collected_code/problem-777-0.c:8:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (i != j && arr[i] == arr[j]) {\n                             ^\ncollected_code/problem-777-0.c:8:40: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (i != j && arr[i] == arr[j]) {\n                                       ^\ncollected_code/problem-777-0.c:14:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += arr[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-777-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.01 seconds (2305 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
778§True§"collected_code/problem-778-0.c:7:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if(i > 0 && arr[i] != arr[i-1])\n                     ^\ncollected_code/problem-778-0.c:7:32: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if(i > 0 && arr[i] != arr[i-1])\n                               ^\ncollected_code/problem-778-0.c:9:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if(i == 0 || arr[i] != arr[i-1]) {\n                      ^\ncollected_code/problem-778-0.c:9:33: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      if(i == 0 || arr[i] != arr[i-1]) {\n                                ^\ncollected_code/problem-778-0.c:12:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n      printf(""%d"", arr[i]);\n                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-778-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.45 seconds (46 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
779§True§collected_code/problem-779-0.c:65:10: error: Cannot determine that 'head[0]' is initialized [premium-bughuntingUninit]\n    free(head);\n         ^\ncollected_code/problem-779-0.c:66:10: error: Cannot determine that 'second[0]' is initialized [premium-bughuntingUninit]\n    free(second);\n         ^\ncollected_code/problem-779-0.c:67:10: error: Cannot determine that 'third[0]' is initialized [premium-bughuntingUninit]\n    free(third);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-779-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 69 in approximately 0.01 seconds (7575 lines/second)\nPhysical Source Lines of Code (SLOC) = 43\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 23.2558 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-779-0.c: In function 'main':\ncollected_code/problem-779-0.c:45:26: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   45 |     head = (struct Node*)malloc(sizeof(struct Node));\n      |                          ^~~~~~\ncollected_code/problem-779-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-779-0.c:45:26: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   45 |     head = (struct Node*)malloc(sizeof(struct Node));\n      |                          ^~~~~~\ncollected_code/problem-779-0.c:45:26: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-779-0.c:65:5: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   65 |     free(head);\n      |     ^~~~\ncollected_code/problem-779-0.c:65:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-779-0.c:65:5: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-779-0.c:65:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-779-0.c:49:16: warning: dereference of possibly-NULL 'head' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   49 |     head->data = 1;\n      |     ~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   45 |     head = (struct Node*)malloc(sizeof(struct Node));\n    |      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                          |\n    |      |                          (1) this call could return NULL\n    |......\n    |   49 |     head->data = 1;\n    |      |     ~~~~~~~~~~~~~~        \n    |      |                |\n    |      |                (2) 'head' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-779-0.c:52:18: warning: dereference of possibly-NULL 'second' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   52 |     second->data = 2;\n      |     ~~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   46 |     second = (struct Node*)malloc(sizeof(struct Node));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |......\n    |   52 |     second->data = 2;\n    |      |     ~~~~~~~~~~~~~~~~        \n    |      |                  |\n    |      |                  (2) 'second' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-779-0.c:55:17: warning: dereference of possibly-NULL 'third' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   55 |     third->data = 1;\n      |     ~~~~~~~~~~~~^~~\n  'main': events 1-2\n    |\n    |   47 |     third = (struct Node*)malloc(sizeof(struct Node));\n    |      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (1) this call could return NULL\n    |......\n    |   55 |     third->data = 1;\n    |      |     ~~~~~~~~~~~~~~~        \n    |      |                 |\n    |      |                 (2) 'third' could be NULL: unchecked value from (1)\n    |\n
780§True§"collected_code/problem-780-0.c:8:33: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d, "", tuple[i]);\n                                ^\ncollected_code/problem-780-0.c:10:31: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d"", tuple[i]);\n                              ^\ncollected_code/problem-780-0.c:19:18: error: Cannot determine that 'tuple[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple[0] + tuple[1] == targetSum) {\n                 ^\ncollected_code/problem-780-0.c:19:29: error: Cannot determine that 'tuple[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple[0] + tuple[1] == targetSum) {\n                            ^\ncollected_code/problem-780-0.c:29:40: error: Cannot determine that 'tupleList[index][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    tuple[tupleSize] = tupleList[index][0];\n                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-780-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 50 in approximately 0.01 seconds (7215 lines/second)\nPhysical Source Lines of Code (SLOC) = 39\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 102.564 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
781§True§"collected_code/problem-781-0.c:26:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-781-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.01 seconds (3211 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
782§True§collected_code/problem-782-0.c:9:27: error: Cannot determine that 'arr[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                sum += arr[k];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-782-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3877 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
783§False§Checking collected_code/problem-783-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-783-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.31 seconds (84 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-783-0.c: In function 'RGBtoHSV':\ncollected_code/problem-783-0.c:2:18: warning: implicit declaration of function 'fmax' [-Wimplicit-function-declaration]\n    2 |     double max = fmax(fmax(r, g), b);\n      |                  ^~~~\ncollected_code/problem-783-0.c:1:1: note: include '<math.h>' or provide a declaration of 'fmax'\n  +++ |+#include <math.h>\n    1 | void RGBtoHSV(int r, int g, int b, double* h, double* s, double* v) {\ncollected_code/problem-783-0.c:2:18: warning: incompatible implicit declaration of built-in function 'fmax' [-Wbuiltin-declaration-mismatch]\n    2 |     double max = fmax(fmax(r, g), b);\n      |                  ^~~~\ncollected_code/problem-783-0.c:2:18: note: include '<math.h>' or provide a declaration of 'fmax'\ncollected_code/problem-783-0.c:3:18: warning: implicit declaration of function 'fmin' [-Wimplicit-function-declaration]\n    3 |     double min = fmin(fmin(r, g), b);\n      |                  ^~~~\ncollected_code/problem-783-0.c:3:18: note: include '<math.h>' or provide a declaration of 'fmin'\ncollected_code/problem-783-0.c:3:18: warning: incompatible implicit declaration of built-in function 'fmin' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-783-0.c:3:18: note: include '<math.h>' or provide a declaration of 'fmin'\ncollected_code/problem-783-0.c:10:19: warning: implicit declaration of function 'fmod' [-Wimplicit-function-declaration]\n   10 |         *h = 60 * fmod(((g - b) / delta), 6);\n      |                   ^~~~\ncollected_code/problem-783-0.c:10:19: note: include '<math.h>' or provide a declaration of 'fmod'\ncollected_code/problem-783-0.c:10:19: warning: incompatible implicit declaration of built-in function 'fmod' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-783-0.c:10:19: note: include '<math.h>' or provide a declaration of 'fmod'\nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
784§True§collected_code/problem-784-0.c:8:20: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (numbers[i] % 2 == 0 && even == -1) {\n                   ^\ncollected_code/problem-784-0.c:9:27: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            even = numbers[i];\n                          ^\ncollected_code/problem-784-0.c:10:27: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (numbers[i] % 2 != 0 && odd == -1) {\n                          ^\ncollected_code/problem-784-0.c:11:26: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            odd = numbers[i];\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-784-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (3898 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 41.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
785§True§"collected_code/problem-785-0.c:7:28: error: Cannot determine that 'tupleString[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int tupleSize = strlen(tupleString) / 2;\n                           ^\ncollected_code/problem-785-0.c:29:31: error: Cannot determine that 'intTuple[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", intTuple[i]);\n                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-785-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-785-0.c:15:  [2] (integer) atoi:\n  Unless checked, the resulting number can exceed the expected range\n  (CWE-190). If source untrusted, check both minimum and maximum, even if the\n  input had no minus sign (large numbers can roll over into negative number;\n  consider saving to an unsigned value if that is intended).\ncollected_code/problem-785-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 32 in approximately 0.01 seconds (4141 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 130.435 [1+] 86.9565 [2+] 43.4783 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
786§True§collected_code/problem-786-0.c:9:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] == value)\n               ^\ncollected_code/problem-786-0.c:11:21: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[mid] < value)\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-786-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.01 seconds (4173 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 45.4545 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
787§False§Checking collected_code/problem-787-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-787-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.56 seconds (32 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
788§True§collected_code/problem-788-0.c:18:27: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int str_size = strlen(str);\n                          ^\ncollected_code/problem-788-0.c:25:29: error: Cannot determine that 'list[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    memcpy(new_tuple->list, list, list_size * sizeof(int));\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-788-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-788-0.c:20:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-788-0.c:25:  [2] (buffer) memcpy:\n  Does not check for buffer overflows when copying to destination (CWE-120).\n  Make sure destination can always hold the source data.\ncollected_code/problem-788-0.c:18:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 51 in approximately 0.02 seconds (3202 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   4 [1]   1 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   7 [1+]   3 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 205.882 [1+] 88.2353 [2+] 58.8235 [3+] 29.4118 [4+] 29.4118 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-788-0.c: In function 'createNewTuple':\ncollected_code/problem-788-0.c:19:20: warning: dereference of possibly-NULL 'new_tuple' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   19 |     new_tuple->str = (char*)malloc((str_size + 1) * sizeof(char));\n      |     ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'createNewTuple': events 1-2\n    |\n    |   15 |     Tuple* new_tuple = (Tuple*)malloc(sizeof(Tuple));\n    |      |                                ^~~~~~~~~~~~~~~~~~~~~\n    |      |                                |\n    |      |                                (1) this call could return NULL\n    |......\n    |   19 |     new_tuple->str = (char*)malloc((str_size + 1) * sizeof(char));\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                    |\n    |      |                    (2) 'new_tuple' could be NULL: unchecked value from (1)\n    |\n
789§True§"collected_code/problem-789-0.c:12:19: error: Cannot determine that 'sides' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &sides);\n                  ^\ncollected_code/problem-789-0.c:15:19: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    scanf(""%lf"", &length);\n                  ^\ncollected_code/problem-789-0.c:17:36: error: Cannot determine that 'sides' is initialized [premium-bughuntingUninit]\n    perimeter = calculatePerimeter(sides, length);\n                                   ^\ncollected_code/problem-789-0.c:17:43: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    perimeter = calculatePerimeter(sides, length);\n                                          ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-789-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3028 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
790§False§collected_code/problem-790-0.c:5:16: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(list[i] % 2 != 0) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-790-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 9 in approximately 0.43 seconds (21 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
791§True§Checking collected_code/problem-791-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-791-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.41 seconds (72 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
792§True§collected_code/problem-792-0.c:7:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] == -1) {\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-792-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.65 seconds (40 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-792-0.c: In function 'main':\ncollected_code/problem-792-0.c:23:41: warning: passing argument 2 of 'countLists' from incompatible pointer type [-Wincompatible-pointer-types]\n   23 |     int result = countLists(numOfLists, lists);\n      |                                         ^~~~~\n      |                                         |\n      |                                         int **\ncollected_code/problem-792-0.c:3:36: note: expected 'int *' but argument is of type 'int **'\n    3 | int countLists(int numOfLists, int list[]) {\n      |                                ~~~~^~~~~~\n
793§True§collected_code/problem-793-0.c:12:16: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[mid] == element) {\n               ^\ncollected_code/problem-793-0.c:17:21: error: Cannot determine that 'arr[mid]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[mid] < element) {\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-793-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.53 seconds (79 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 60.6061 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
794§True§"collected_code/problem-794-0.c:6:15: error: Cannot determine that 'str[len]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[len] != '\0') {\n              ^\ncollected_code/problem-794-0.c:10:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == 'a' && str[i + 2] == 'b') {\n               ^\ncollected_code/problem-794-0.c:10:33: error: Cannot determine that 'str[i+2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == 'a' && str[i + 2] == 'b') {\n                                ^\ncollected_code/problem-794-0.c:21:17: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-794-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-794-0.c:21:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-794-0.c:19:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 28 in approximately 0.01 seconds (3144 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 185.185 [1+] 74.0741 [2+] 74.0741 [3+] 37.037 [4+] 37.037 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
795§True§Checking collected_code/problem-795-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-795-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-795-0.c:7:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 115 in approximately 0.62 seconds (186 lines/second)\nPhysical Source Lines of Code (SLOC) = 94\nHits@level = [0]   4 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 53.1915 [1+] 10.6383 [2+] 10.6383 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-795-0.c: In function 'createHeap':\ncollected_code/problem-795-0.c:41:16: warning: dereference of possibly-NULL 'heap' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   41 |     heap->data = (Item*)malloc(sizeof(Item) * capacity);\n      |     ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   99 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |  113 |     findNcheapItems(dataset, size, n);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'findNcheapItems' from 'main'\n    |\n    +--> 'findNcheapItems': events 3-4\n           |\n           |   79 | void findNcheapItems(Item* dataset, int size, int n) {\n           |      |      ^~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'findNcheapItems'\n           |   80 |     Heap* heap = createHeap(n);\n           |      |                  ~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'findNcheapItems'\n           |\n           +--> 'createHeap': events 5-7\n                  |\n                  |   39 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   40 |     Heap* heap = (Heap*)malloc(sizeof(Heap));\n                  |      |                         ~~~~~~~~~~~~~~~~~~~~\n                  |      |                         |\n                  |      |                         (6) this call could return NULL\n                  |   41 |     heap->data = (Item*)malloc(sizeof(Item) * capacity);\n                  |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                |\n                  |      |                (7) 'heap' could be NULL: unchecked value from (6)\n                  |\ncollected_code/problem-795-0.c: In function 'insert':\ncollected_code/problem-795-0.c:54:19: warning: dereference of possibly-NULL '*heap.data + (long unsigned int)i * 104' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   54 |     heap->data[i] = item;\n      |     ~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   99 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |  113 |     findNcheapItems(dataset, size, n);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'findNcheapItems' from 'main'\n    |\n    +--> 'findNcheapItems': events 3-4\n           |\n           |   79 | void findNcheapItems(Item* dataset, int size, int n) {\n           |      |      ^~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'findNcheapItems'\n           |   80 |     Heap* heap = createHeap(n);\n           |      |                  ~~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (4) calling 'createHeap' from 'findNcheapItems'\n           |\n           +--> 'createHeap': events 5-6\n                  |\n                  |   39 | Heap* createHeap(int capacity) {\n                  |      |       ^~~~~~~~~~\n                  |      |       |\n                  |      |       (5) entry to 'createHeap'\n                  |   40 |     Heap* heap = (Heap*)malloc(sizeof(Heap));\n                  |   41 |     heap->data = (Item*)malloc(sizeof(Item) * capacity);\n                  |      |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                  |      |                         |\n                  |      |                         (6) this call could return NULL\n                  |\n           <------+\n           |\n         'findNcheapItems': events 7-12\n           |\n           |   80 |     Heap* heap = createHeap(n);\n           |      |                  ^~~~~~~~~~~~~\n           |      |                  |\n           |      |                  (7) returning to 'findNcheapItems' from 'createHeap'\n           |   81 | \n           |   82 |     for (int i = 0; i < size; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (8) following 'true' branch (when 'i < size')...\n           |   83 |         if (heap->size < n) {\n           |      |            ~~~~~~~~~~~\n           |      |            |    |\n           |      |            |    (9) ...to here\n           |      |            (10) following 'true' branch...\n           |   84 |             insert(heap, dataset[i]);\n           |      |             ~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |             |                   |\n           |      |             |                   (11) ...to here\n           |      |             (12) calling 'insert' from 'findNcheapItems'\n           |\n           +--> 'insert': events 13-16\n                  |\n                  |   47 | void insert(Heap* heap, Item item) {\n                  |      |      ^~~~~~\n                  |      |      |\n                  |      |      (13) entry to 'insert'\n                  |   48 |     if (heap->size == heap->capacity) {\n                  |      |        ~\n                  |      |        |\n                  |      |        (14) following 'false' branch...\n                  |......\n                  |   53 |     int i = heap->size;\n                  |      |         ~\n                  |      |         |\n                  |      |         (15) ...to here\n                  |   54 |     heap->data[i] = item;\n                  |      |     ~~~~~~~~~~~~~~~~~~~~\n                  |      |                   |\n                  |      |                   (16) '*heap.data + (long unsigned int)i * 104' could be NULL: unchecked value from (6)\n                  |\n
796§True§collected_code/problem-796-0.c:7:26: error: Cannot determine that 'dictionary[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += dictionary[i];\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-796-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.52 seconds (40 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
797§True§"collected_code/problem-797-0.c:28:21: error: Cannot determine that 'l' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &l, &r);\n                    ^\ncollected_code/problem-797-0.c:28:25: error: Cannot determine that 'r' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &l, &r);\n                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-797-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.76 seconds (48 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 130.435 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
798§True§collected_code/problem-798-0.c:6:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += arr[i];\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-798-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2359 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
799§True§Checking collected_code/problem-799-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-799-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 12 in approximately 0.01 seconds (1736 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
800§True§collected_code/problem-800-0.c:5:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i]) {\n              ^\ncollected_code/problem-800-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] != ' ') {\n               ^\ncollected_code/problem-800-0.c:7:27: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[j++] = str[i];\n                          ^\ncollected_code/problem-800-0.c:17:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str), stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-800-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-800-0.c:15:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 21 in approximately 0.51 seconds (41 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]  50 [2+]  50 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
801§True§"collected_code/problem-801-0.c:20:24: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &num1, &num2, &num3);\n                       ^\ncollected_code/problem-801-0.c:20:31: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &num1, &num2, &num3);\n                              ^\ncollected_code/problem-801-0.c:20:38: error: Cannot determine that 'num3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &num1, &num2, &num3);\n                                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-801-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (2933 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
802§True§collected_code/problem-802-0.c:4:18: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int min = arr[0];\n                 ^\ncollected_code/problem-802-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < min) {\n               ^\ncollected_code/problem-802-0.c:8:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            min = arr[i];\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-802-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.03 seconds (689 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
803§True§"collected_code/problem-803-0.c:16:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-803-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.59 seconds (41 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 190.476 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
804§False§Checking collected_code/problem-804-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-804-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 10 in approximately 0.01 seconds (1546 lines/second)\nPhysical Source Lines of Code (SLOC) = 9\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
805§False§collected_code/problem-805-0.c:9:22: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        total += list[i];\n                     ^\ncollected_code/problem-805-0.c:20:41: error: Cannot determine that 'listOfLists[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int currentSum = sum(listOfLists[i], listSizes[i]);\n                                        ^\ncollected_code/problem-805-0.c:20:55: error: Cannot determine that 'listSizes[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int currentSum = sum(listOfLists[i], listSizes[i]);\n                                                      ^\ncollected_code/problem-805-0.c:23:41: error: Cannot determine that 'listOfLists[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            highestSumList = listOfLists[i];\n                                        ^\ncollected_code/problem-805-0.c:26:12: error: Cannot determine that 'highestSumList' is initialized [premium-bughuntingUninit]\n    return highestSumList;\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-805-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.01 seconds (6661 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 64.5161 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-805-0.c: In function 'main':\ncollected_code/problem-805-0.c:37:34: error: array subscript is not an integer\n   37 |     for (int i = 0; i < listSizes[highestSumList]; i++) {\n      |                                  ^\n
806§True§collected_code/problem-806-0.c:9:28: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; i < strlen(str); i++) {\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-806-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-806-0.c:9:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 29 in approximately 0.52 seconds (56 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+] 41.6667 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
807§True§collected_code/problem-807-0.c:5:19: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if(numbers[i] % 2 != 0) {\n                  ^\ncollected_code/problem-807-0.c:6:27: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            return numbers[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-807-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (3003 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
808§False§collected_code/problem-808-0.c:3:19: error: Cannot determine that 'tuples[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuples[i] == k) {\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-808-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 7 in approximately 0.16 seconds (44 lines/second)\nPhysical Source Lines of Code (SLOC) = 8\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-808-0.c:1:1: error: unknown type name 'bool'\n    1 | bool containsK(int tuples[], int k, int size) {\n      | ^~~~\ncollected_code/problem-808-0.c:1:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n  +++ |+#include <stdbool.h>\n    1 | bool containsK(int tuples[], int k, int size) {\ncollected_code/problem-808-0.c: In function 'containsK':\ncollected_code/problem-808-0.c:4:20: error: 'true' undeclared (first use in this function)\n    4 |             return true;\n      |                    ^~~~\ncollected_code/problem-808-0.c:4:20: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\ncollected_code/problem-808-0.c:4:20: note: each undeclared identifier is reported only once for each function it appears in\ncollected_code/problem-808-0.c:7:12: error: 'false' undeclared (first use in this function)\n    7 |     return false;\n      |            ^~~~~\ncollected_code/problem-808-0.c:7:12: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n
809§True§collected_code/problem-809-0.c:5:19: error: Cannot determine that 'second[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (second[i] >= i && first[i] >= second[i]) {\n                  ^\ncollected_code/problem-809-0.c:5:36: error: Cannot determine that 'first[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (second[i] >= i && first[i] >= second[i]) {\n                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-809-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3468 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
810§True§"collected_code/problem-810-0.c:5:31: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        for(int j = 0; j < arr[i]; j++) {\n                              ^\ncollected_code/problem-810-0.c:6:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", arr[i]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-810-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.47 seconds (36 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
811§True§Checking collected_code/problem-811-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-811-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 36 in approximately 0.58 seconds (62 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 68.9655 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
812§True§"collected_code/problem-812-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\ncollected_code/problem-812-0.c:17:22: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%[^\n]s"", str);\n                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-812-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-812-0.c:15:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-812-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 22 in approximately 0.03 seconds (671 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   1 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 263.158 [1+] 105.263 [2+] 52.6316 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
813§True§collected_code/problem-813-0.c:5:12: error: Cannot determine that '*str' is initialized [premium-bughuntingUninit]\n    while (*str != '\0') {\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-813-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (1583 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
814§True§"collected_code/problem-814-0.c:12:18: error: Cannot determine that 'diagonal1' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &diagonal1);\n                 ^\ncollected_code/problem-814-0.c:15:18: error: Cannot determine that 'diagonal2' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &diagonal2);\n                 ^\ncollected_code/problem-814-0.c:17:38: error: Cannot determine that 'diagonal1' is initialized [premium-bughuntingUninit]\n    float area = calculateRombusArea(diagonal1, diagonal2);\n                                     ^\ncollected_code/problem-814-0.c:17:49: error: Cannot determine that 'diagonal2' is initialized [premium-bughuntingUninit]\n    float area = calculateRombusArea(diagonal1, diagonal2);\n                                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-814-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3291 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
815§True§collected_code/problem-815-0.c:6:18: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[arr[i]]++;\n                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-815-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.42 seconds (76 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-815-0.c: In function 'main':\ncollected_code/problem-815-0.c:29:9: warning: implicit declaration of function 'printf' [-Wimplicit-function-declaration]\n   29 |         printf(""%d "", arr[i]);\n      |         ^~~~~~\ncollected_code/problem-815-0.c:1:1: note: include '<stdio.h>' or provide a declaration of 'printf'\n  +++ |+#include <stdio.h>\n    1 | void sortArray(int arr[], int n) {\ncollected_code/problem-815-0.c:29:9: warning: incompatible implicit declaration of built-in function 'printf' [-Wbuiltin-declaration-mismatch]\n   29 |         printf(""%d "", arr[i]);\n      |         ^~~~~~\ncollected_code/problem-815-0.c:29:9: note: include '<stdio.h>' or provide a declaration of 'printf'\n"
816§True§Checking collected_code/problem-816-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-816-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.46 seconds (40 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
817§True§"collected_code/problem-817-0.c:9:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % m == 0 || arr[i] % n == 0)\n               ^\ncollected_code/problem-817-0.c:11:30: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", arr[i]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-817-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3070 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
818§True§collected_code/problem-818-0.c:7:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i] != '\0') {\n              ^\ncollected_code/problem-818-0.c:8:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] >= 'a' && str[i] <= 'z') {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-818-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (1955 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
819§True§collected_code/problem-819-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == arr[i - 1]) {  // Check if current element is equal to its previous element\n               ^\ncollected_code/problem-819-0.c:7:26: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == arr[i - 1]) {  // Check if current element is equal to its previous element\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-819-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.02 seconds (1350 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
820§True§"collected_code/problem-820-0.c:17:18: error: Cannot determine that 'month' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &month);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-820-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2524 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 222.222 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
821§True§"collected_code/problem-821-0.c:9:22: error: Cannot determine that 'result[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        strcpy(result[i], dict1[i]);\n                     ^\ncollected_code/problem-821-0.c:9:32: error: Cannot determine that 'dict1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        strcpy(result[i], dict1[i]);\n                               ^\ncollected_code/problem-821-0.c:13:22: error: Cannot determine that 'result[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        strcpy(result[k], dict2[j]);\n                     ^\ncollected_code/problem-821-0.c:13:32: error: Cannot determine that 'dict2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        strcpy(result[k], dict2[j]);\n                               ^\ncollected_code/problem-821-0.c:28:30: error: Cannot determine that 'result[i]' is initialized [premium-bughuntingUninit]\n        printf(""%s\n"", result[i]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-821-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-821-0.c:9:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-821-0.c:13:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-821-0.c:23:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 31 in approximately 0.01 seconds (2302 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   1 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   4 [1+]   3 [2+]   3 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+] 111.111 [2+] 111.111 [3+] 74.0741 [4+] 74.0741 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
822§False§Checking collected_code/problem-822-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-822-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.60 seconds (45 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-822-0.c:1:1: error: unknown type name 'bool'\n    1 | bool isValidPassword(const char* password) {\n      | ^~~~\ncollected_code/problem-822-0.c:1:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n  +++ |+#include <stdbool.h>\n    1 | bool isValidPassword(const char* password) {\ncollected_code/problem-822-0.c: In function 'isValidPassword':\ncollected_code/problem-822-0.c:12:16: error: 'false' undeclared (first use in this function)\n   12 |         return false;\n      |                ^~~~~\ncollected_code/problem-822-0.c:12:16: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\ncollected_code/problem-822-0.c:12:16: note: each undeclared identifier is reported only once for each function it appears in\ncollected_code/problem-822-0.c:17:13: warning: implicit declaration of function 'islower' [-Wimplicit-function-declaration]\n   17 |         if (islower(password[i])) {\n      |             ^~~~~~~\ncollected_code/problem-822-0.c:1:1: note: include '<ctype.h>' or provide a declaration of 'islower'\n  +++ |+#include <ctype.h>\n    1 | bool isValidPassword(const char* password) {\ncollected_code/problem-822-0.c:19:20: warning: implicit declaration of function 'isupper' [-Wimplicit-function-declaration]\n   19 |         } else if (isupper(password[i])) {\n      |                    ^~~~~~~\ncollected_code/problem-822-0.c:19:20: note: include '<ctype.h>' or provide a declaration of 'isupper'\ncollected_code/problem-822-0.c:21:20: warning: implicit declaration of function 'isdigit' [-Wimplicit-function-declaration]\n   21 |         } else if (isdigit(password[i])) {\n      |                    ^~~~~~~\ncollected_code/problem-822-0.c:21:20: note: include '<ctype.h>' or provide a declaration of 'isdigit'\n
823§True§Checking collected_code/problem-823-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-823-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (4687 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 107.143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
824§True§collected_code/problem-824-0.c:7:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] % 2 != 0) {\n                ^\ncollected_code/problem-824-0.c:8:27: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            list[j] = list[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-824-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.38 seconds (70 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
825§True§"collected_code/problem-825-0.c:6:18: error: Cannot determine that 'index[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (index[i] >= 0 && index[i] < numElements) {\n                 ^\ncollected_code/problem-825-0.c:7:52: error: Cannot determine that 'index[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""Value at index %d: %d\n"", index[i], list[index[i]]);\n                                                   ^\ncollected_code/problem-825-0.c:7:61: error: Cannot determine that 'list[index[i]]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""Value at index %d: %d\n"", index[i], list[index[i]]);\n                                                            ^\ncollected_code/problem-825-0.c:9:47: error: Cannot determine that 'index[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""Invalid index %d\n"", index[i]);\n                                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-825-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2726 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
826§True§"collected_code/problem-826-0.c:17:23: error: Cannot determine that 'side1' is initialized [premium-bughuntingUninit]\n   scanf(""%d %d %d"", &side1, &side2, &side3);\n                      ^\ncollected_code/problem-826-0.c:17:31: error: Cannot determine that 'side2' is initialized [premium-bughuntingUninit]\n   scanf(""%d %d %d"", &side1, &side2, &side3);\n                              ^\ncollected_code/problem-826-0.c:17:39: error: Cannot determine that 'side3' is initialized [premium-bughuntingUninit]\n   scanf(""%d %d %d"", &side1, &side2, &side3);\n                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-826-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (2981 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 294.118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
827§True§collected_code/problem-827-0.c:6:23: error: Cannot determine that 'list[i][column]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += list[i][column];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-827-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (2486 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
828§True§collected_code/problem-828-0.c:8:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str[i] != '\0'; i++) {\n                       ^\ncollected_code/problem-828-0.c:9:17: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if ((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z')) {\n                ^\ncollected_code/problem-828-0.c:11:23: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (str[i] >= '0' && str[i] <= '9') {\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-828-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.01 seconds (3928 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 130.435 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
829§True§"collected_code/problem-829-0.c:56:16: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n  scanf(""%d"", &n);\n               ^\ncollected_code/problem-829-0.c:58:17: error: Cannot determine that 'sequence[100]' is initialized [premium-bughuntingUninit]\n  char* sequence[MAX_SIZE];\n                ^\ncollected_code/problem-829-0.c:63:25: error: Cannot determine that 'sequence[i][0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", sequence[i]);\n                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-829-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-829-0.c:63:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 79 in approximately 0.63 seconds (125 lines/second)\nPhysical Source Lines of Code (SLOC) = 60\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   6 [1+]   1 [2+]   1 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+] 16.6667 [2+] 16.6667 [3+] 16.6667 [4+] 16.6667 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-829-0.c: In function 'main':\ncollected_code/problem-829-0.c:62:26: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   62 |     sequence[i] = (char*)malloc(MAX_SIZE * sizeof(char));\n      |                          ^~~~~~\ncollected_code/problem-829-0.c:3:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    2 | #include <string.h>\n  +++ |+#include <stdlib.h>\n    3 | \ncollected_code/problem-829-0.c:62:26: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   62 |     sequence[i] = (char*)malloc(MAX_SIZE * sizeof(char));\n      |                          ^~~~~~\ncollected_code/problem-829-0.c:62:26: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-829-0.c:76:5: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   76 |     free(sequence[i]);\n      |     ^~~~\ncollected_code/problem-829-0.c:76:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-829-0.c:76:5: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-829-0.c:76:5: note: include '<stdlib.h>' or provide a declaration of 'free'\n
830§False§Checking collected_code/problem-830-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-830-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 6 in approximately 0.70 seconds (9 lines/second)\nPhysical Source Lines of Code (SLOC) = 6\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
831§True§collected_code/problem-831-0.c:7:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                   ^\ncollected_code/problem-831-0.c:7:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j]) {\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-831-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.03 seconds (780 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
832§True§"collected_code/problem-832-0.c:17:30: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    status = regexec(&regex, str, 1, &match, 0);\n                             ^\ncollected_code/problem-832-0.c:21:18: error: Cannot determine that 'numeric_value[0]' is initialized [premium-bughuntingUninit]\n        snprintf(numeric_value, match.rm_eo - match.rm_so + 1, ""%.*s"", match.rm_eo - match.rm_so, str + match.rm_so);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-832-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-832-0.c:20:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-832-0.c:24:  [2] (integer) atoi:\n  Unless checked, the resulting number can exceed the expected range\n  (CWE-190). If source untrusted, check both minimum and maximum, even if the\n  input had no minus sign (large numbers can roll over into negative number;\n  consider saving to an unsigned value if that is intended).\ncollected_code/problem-832-0.c:29:  [2] (integer) atoi:\n  Unless checked, the resulting number can exceed the expected range\n  (CWE-190). If source untrusted, check both minimum and maximum, even if the\n  input had no minus sign (large numbers can roll over into negative number;\n  consider saving to an unsigned value if that is intended).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 50 in approximately 0.01 seconds (5470 lines/second)\nPhysical Source Lines of Code (SLOC) = 37\nHits@level = [0]   5 [1]   0 [2]   3 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   8 [1+]   3 [2+]   3 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 216.216 [1+] 81.0811 [2+] 81.0811 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-832-0.c: In function 'extract_max_numeric_value':\ncollected_code/problem-832-0.c:24:25: warning: implicit declaration of function 'atoi' [-Wimplicit-function-declaration]\n   24 |         int max_value = atoi(numeric_value);\n      |                         ^~~~\n
833§True§"collected_code/problem-833-0.c:12:9: error: Cannot determine that 'keys' is initialized [premium-bughuntingUninit]\n        keys[i] = dictionary[i].key;\n        ^\ncollected_code/problem-833-0.c:20:15: error: Cannot determine that 'dictionary[0] members' is initialized [premium-bughuntingUninit]\n    dictionary[0].key = ""apple"";\n              ^\ncollected_code/problem-833-0.c:21:15: error: Cannot determine that 'dictionary[0] members' is initialized [premium-bughuntingUninit]\n    dictionary[0].value = 10;\n              ^\ncollected_code/problem-833-0.c:23:15: error: Cannot determine that 'dictionary[1] members' is initialized [premium-bughuntingUninit]\n    dictionary[1].key = ""banana"";\n              ^\ncollected_code/problem-833-0.c:24:15: error: Cannot determine that 'dictionary[1] members' is initialized [premium-bughuntingUninit]\n    dictionary[1].value = 5;\n              ^\ncollected_code/problem-833-0.c:26:15: error: Cannot determine that 'dictionary[2] members' is initialized [premium-bughuntingUninit]\n    dictionary[2].key = ""orange"";\n              ^\ncollected_code/problem-833-0.c:27:15: error: Cannot determine that 'dictionary[2] members' is initialized [premium-bughuntingUninit]\n    dictionary[2].value = 7;\n              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-833-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.01 seconds (5790 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 33.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-833-0.c: In function 'getDictionaryKeys':\ncollected_code/problem-833-0.c:12:17: warning: dereference of possibly-NULL 'keys' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   12 |         keys[i] = dictionary[i].key;\n      |         ~~~~~~~~^~~~~~~~~~~~~~~~~~~\n  'getDictionaryKeys': events 1-4\n    |\n    |   10 |     char** keys = (char**) malloc(size * sizeof(char*));\n    |      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (1) this call could return NULL\n    |   11 |     for (int i = 0; i < size; i++) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < size')...\n    |   12 |         keys[i] = dictionary[i].key;\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                 |           |\n    |      |                 |           (3) ...to here\n    |      |                 (4) 'keys + (long unsigned int)i * 8' could be NULL: unchecked value from (1)\n    |\ncollected_code/problem-833-0.c: In function 'main':\ncollected_code/problem-833-0.c:34:9: warning: 'free' of '""apple""' which points to memory not on the heap [CWE-590] [-Wanalyzer-free-of-non-heap]\n   34 |         free(keys[i]);\n      |         ^~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   17 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   30 |     char** keys = getDictionaryKeys(dictionary, size);\n    |      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (2) calling 'getDictionaryKeys' from 'main'\n    |\n    +--> 'getDictionaryKeys': events 3-9\n           |\n           |    9 | char** getDictionaryKeys(Dictionary* dictionary, int size) {\n           |      |        ^~~~~~~~~~~~~~~~~\n           |      |        |\n           |      |        (3) entry to 'getDictionaryKeys'\n           |   10 |     char** keys = (char**) malloc(size * sizeof(char*));\n           |   11 |     for (int i = 0; i < size; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (4) following 'true' branch (when 'i < size')...\n           |      |                       (6) following 'true' branch (when 'i < size')...\n           |      |                       (8) following 'false' branch (when 'i >= size')...\n           |   12 |         keys[i] = dictionary[i].key;\n           |      |                             ~\n           |      |                             |\n           |      |                             (5) ...to here\n           |      |                             (7) ...to here\n           |   13 |     }\n           |   14 |     return keys;\n           |      |            ~~~~\n           |      |            |\n           |      |            (9) ...to here\n           |\n    <------+\n    |\n  'main': events 10-13\n    |\n    |   30 |     char** keys = getDictionaryKeys(dictionary, size);\n    |      |                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                   |\n    |      |                   (10) returning to 'main' from 'getDictionaryKeys'\n    |   31 | \n    |   32 |     for (int i = 0; i < size; i++) {\n    |      |                     ~~~~~~~~\n    |      |                       |\n    |      |                       (11) following 'true' branch (when 'i < size')...\n    |   33 |         printf(""%s\n"", keys[i]);\n    |      |                            ~\n    |      |                            |\n    |      |                            (12) ...to here\n    |   34 |         free(keys[i]);\n    |      |         ~~~~~~~~~~~~~\n    |      |         |\n    |      |         (13) call to 'free' here\n    |\n"
834§True§"collected_code/problem-834-0.c:27:36: error: Cannot determine that 'matrix[i][j]' is initialized [premium-bughuntingUninit]\n            printf(""%d "", matrix[i][j]);\n                                   ^\ncollected_code/problem-834-0.c:36:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-834-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.01 seconds (3066 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
835§True§"collected_code/problem-835-0.c:11:21: error: Cannot determine that 'x1' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f"", &x1, &y1);\n                    ^\ncollected_code/problem-835-0.c:11:26: error: Cannot determine that 'y1' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f"", &x1, &y1);\n                         ^\ncollected_code/problem-835-0.c:13:21: error: Cannot determine that 'x2' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f"", &x2, &y2);\n                    ^\ncollected_code/problem-835-0.c:13:26: error: Cannot determine that 'y2' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f"", &x2, &y2);\n                         ^\ncollected_code/problem-835-0.c:15:29: error: Cannot determine that 'x1' is initialized [premium-bughuntingUninit]\n    float slope = findSlope(x1, y1, x2, y2);\n                            ^\ncollected_code/problem-835-0.c:15:33: error: Cannot determine that 'y1' is initialized [premium-bughuntingUninit]\n    float slope = findSlope(x1, y1, x2, y2);\n                                ^\ncollected_code/problem-835-0.c:15:37: error: Cannot determine that 'x2' is initialized [premium-bughuntingUninit]\n    float slope = findSlope(x1, y1, x2, y2);\n                                    ^\ncollected_code/problem-835-0.c:15:41: error: Cannot determine that 'y2' is initialized [premium-bughuntingUninit]\n    float slope = findSlope(x1, y1, x2, y2);\n                                        ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-835-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (2197 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 400 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
836§True§collected_code/problem-836-0.c:12:34: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        curr_sum = curr_sum + arr[i];\n                                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-836-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.01 seconds (6456 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
837§True§"collected_code/problem-837-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-837-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3619 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
838§True§collected_code/problem-838-0.c:8:23: error: Cannot determine that 's1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; s1[i]; i++) {\n                      ^\ncollected_code/problem-838-0.c:9:15: error: Cannot determine that 's1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (s1[i] != s2[i]) {\n              ^\ncollected_code/problem-838-0.c:9:24: error: Cannot determine that 's2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (s1[i] != s2[i]) {\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-838-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.02 seconds (1208 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
839§False§collected_code/problem-839-0.c:7:30: error: Cannot determine that 'tuples[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strcmp(tuples[j], tuples[j + 1]) > 0) {\n                             ^\ncollected_code/problem-839-0.c:7:41: error: Cannot determine that 'tuples[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (strcmp(tuples[j], tuples[j + 1]) > 0) {\n                                        ^\ncollected_code/problem-839-0.c:9:24: error: Cannot determine that 'temp[0]' is initialized [premium-bughuntingUninit]\n                strcpy(temp, tuples[j]);\n                       ^\ncollected_code/problem-839-0.c:9:36: error: Cannot determine that 'tuples[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                strcpy(temp, tuples[j]);\n                                   ^\ncollected_code/problem-839-0.c:10:30: error: Cannot determine that 'tuples[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                strcpy(tuples[j], tuples[j + 1]);\n                             ^\ncollected_code/problem-839-0.c:10:41: error: Cannot determine that 'tuples[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                strcpy(tuples[j], tuples[j + 1]);\n                                        ^\ncollected_code/problem-839-0.c:11:30: error: Cannot determine that 'tuples[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                strcpy(tuples[j + 1], temp);\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-839-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-839-0.c:9:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-839-0.c:10:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-839-0.c:11:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-839-0.c:8:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 4\nLines analyzed = 27 in approximately 0.01 seconds (3972 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   1 [3]   0 [4]   3 [5]   0\nHits@level+ = [0+]   5 [1+]   4 [2+]   4 [3+]   3 [4+]   3 [5+]   0\nHits/KSLOC@level+ = [0+] 217.391 [1+] 173.913 [2+] 173.913 [3+] 130.435 [4+] 130.435 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-839-0.c: In function 'main':\ncollected_code/problem-839-0.c:18:31: error: excess elements in 'char' array initializer\n   18 |     char tuples[][2] = {{""b"", ""2""}, {""a"", ""1""}, {""c"", ""3""}};\n      |                               ^~~\ncollected_code/problem-839-0.c:18:31: note: (near initialization for 'tuples[0]')\ncollected_code/problem-839-0.c:18:43: error: excess elements in 'char' array initializer\n   18 |     char tuples[][2] = {{""b"", ""2""}, {""a"", ""1""}, {""c"", ""3""}};\n      |                                           ^~~\ncollected_code/problem-839-0.c:18:43: note: (near initialization for 'tuples[1]')\ncollected_code/problem-839-0.c:18:55: error: excess elements in 'char' array initializer\n   18 |     char tuples[][2] = {{""b"", ""2""}, {""a"", ""1""}, {""c"", ""3""}};\n      |                                                       ^~~\ncollected_code/problem-839-0.c:18:55: note: (near initialization for 'tuples[2]')\n"
840§True§"collected_code/problem-840-0.c:26:24: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                       ^\ncollected_code/problem-840-0.c:26:28: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                           ^\ncollected_code/problem-840-0.c:26:32: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                               ^\ncollected_code/problem-840-0.c:28:16: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    checkRoots(a, b, c);\n               ^\ncollected_code/problem-840-0.c:28:19: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    checkRoots(a, b, c);\n                  ^\ncollected_code/problem-840-0.c:28:22: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    checkRoots(a, b, c);\n                     ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-840-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (3484 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 240 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-840-0.c: In function 'checkRoots':\ncollected_code/problem-840-0.c:7:29: warning: implicit declaration of function 'sqrt' [-Wimplicit-function-declaration]\n    7 |         float root1 = (-b + sqrt(discriminant)) / (2 * a);\n      |                             ^~~~\ncollected_code/problem-840-0.c:2:1: note: include '<math.h>' or provide a declaration of 'sqrt'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-840-0.c:7:29: warning: incompatible implicit declaration of built-in function 'sqrt' [-Wbuiltin-declaration-mismatch]\n    7 |         float root1 = (-b + sqrt(discriminant)) / (2 * a);\n      |                             ^~~~\ncollected_code/problem-840-0.c:7:29: note: include '<math.h>' or provide a declaration of 'sqrt'\n
841§True§collected_code/problem-841-0.c:7:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j]) {\n                   ^\ncollected_code/problem-841-0.c:7:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] > arr[j]) {\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-841-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (1629 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
842§True§collected_code/problem-842-0.c:6:22: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result ^= arr[i];\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-842-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.01 seconds (2532 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
843§False§collected_code/problem-843-0.c:16:44: error: Memory is allocated but not initialized: indices[j] [uninitdata]\n            ugNums[j] = uglyNumbers[indices[j]] * primes[j];\n                                           ^\ncollected_code/problem-843-0.c:16:44: error: Cannot determine that 'indices[j]' is initialized [premium-bughuntingUninit]\n            ugNums[j] = uglyNumbers[indices[j]] * primes[j];\n                                           ^\ncollected_code/problem-843-0.c:16:57: error: Cannot determine that 'primes[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            ugNums[j] = uglyNumbers[indices[j]] * primes[j];\n                                                        ^\ncollected_code/problem-843-0.c:27:24: error: Cannot determine that 'indices[j]' is initialized [premium-bughuntingUninit]\n                indices[j]++;\n                       ^\ncollected_code/problem-843-0.c:34:10: error: Cannot determine that 'uglyNumbers[0]' is initialized [premium-bughuntingUninit]\n    free(uglyNumbers);\n         ^\ncollected_code/problem-843-0.c:35:10: error: Cannot determine that 'indices[0]' is initialized [premium-bughuntingUninit]\n    free(indices);\n         ^\ncollected_code/problem-843-0.c:36:10: error: Cannot determine that 'ugNums[0]' is initialized [premium-bughuntingUninit]\n    free(ugNums);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-843-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 50 in approximately 0.01 seconds (6140 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 27.7778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-843-0.c: In function 'nthSuperUglyNumber':\ncollected_code/problem-843-0.c:13:23: error: 'INT_MAX' undeclared (first use in this function)\n   13 |         int minUgly = INT_MAX;\n      |                       ^~~~~~~\ncollected_code/problem-843-0.c:3:1: note: 'INT_MAX' is defined in header '<limits.h>'; did you forget to '#include <limits.h>'?\n    2 | #include <stdlib.h>\n  +++ |+#include <limits.h>\n    3 | \ncollected_code/problem-843-0.c:13:23: note: each undeclared identifier is reported only once for each function it appears in\n   13 |         int minUgly = INT_MAX;\n      |                       ^~~~~~~\n
844§True§"collected_code/problem-844-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % 2 != 0) {\n               ^\ncollected_code/problem-844-0.c:12:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                return arr[i];\n                          ^\ncollected_code/problem-844-0.c:20:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % 2 == 0) {\n               ^\ncollected_code/problem-844-0.c:24:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                return arr[i];\n                          ^\ncollected_code/problem-844-0.c:39:18: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &k);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-844-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 49 in approximately 0.01 seconds (7490 lines/second)\nPhysical Source Lines of Code (SLOC) = 39\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 102.564 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
845§True§"collected_code/problem-845-0.c:24:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-845-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.01 seconds (3155 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 160 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-845-0.c: In function 'countDigitsInFactorial':\ncollected_code/problem-845-0.c:15:19: warning: implicit declaration of function 'log10' [-Wimplicit-function-declaration]\n   15 |         digits += log10(i);\n      |                   ^~~~~\ncollected_code/problem-845-0.c:2:1: note: include '<math.h>' or provide a declaration of 'log10'\n    1 | #include <stdio.h>\n  +++ |+#include <math.h>\n    2 | \ncollected_code/problem-845-0.c:15:19: warning: incompatible implicit declaration of built-in function 'log10' [-Wbuiltin-declaration-mismatch]\n   15 |         digits += log10(i);\n      |                   ^~~~~\ncollected_code/problem-845-0.c:15:19: note: include '<math.h>' or provide a declaration of 'log10'\n
846§True§collected_code/problem-846-0.c:11:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if ((arr[i] >= arr[j] && arr[i] <= dep[j]) ||\n                    ^\ncollected_code/problem-846-0.c:11:31: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if ((arr[i] >= arr[j] && arr[i] <= dep[j]) ||\n                              ^\ncollected_code/problem-846-0.c:11:51: error: Cannot determine that 'dep[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if ((arr[i] >= arr[j] && arr[i] <= dep[j]) ||\n                                                  ^\ncollected_code/problem-846-0.c:12:21: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                (arr[j] >= arr[i] && arr[j] <= dep[i])) {\n                    ^\ncollected_code/problem-846-0.c:12:31: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                (arr[j] >= arr[i] && arr[j] <= dep[i])) {\n                              ^\ncollected_code/problem-846-0.c:12:51: error: Cannot determine that 'dep[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                (arr[j] >= arr[i] && arr[j] <= dep[i])) {\n                                                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-846-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.01 seconds (4102 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
847§False§Checking collected_code/problem-847-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-847-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.26 seconds (123 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 33.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
848§True§"collected_code/problem-848-0.c:11:18: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &a);\n                 ^\ncollected_code/problem-848-0.c:13:18: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &b);\n                 ^\ncollected_code/problem-848-0.c:15:18: error: Cannot determine that 'h' is initialized [premium-bughuntingUninit]\n    scanf(""%f"", &h);\n                 ^\ncollected_code/problem-848-0.c:16:29: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    float result = findArea(a, b, h);\n                            ^\ncollected_code/problem-848-0.c:16:32: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    float result = findArea(a, b, h);\n                               ^\ncollected_code/problem-848-0.c:16:35: error: Cannot determine that 'h' is initialized [premium-bughuntingUninit]\n    float result = findArea(a, b, h);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-848-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.01 seconds (2862 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   7 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   7 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 411.765 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
849§True§"collected_code/problem-849-0.c:26:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-849-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.48 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 115.385 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
850§True§"collected_code/problem-850-0.c:18:24: error: Cannot determine that 'angle1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &angle1, &angle2, &angle3);\n                       ^\ncollected_code/problem-850-0.c:18:33: error: Cannot determine that 'angle2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &angle1, &angle2, &angle3);\n                                ^\ncollected_code/problem-850-0.c:18:42: error: Cannot determine that 'angle3' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d"", &angle1, &angle2, &angle3);\n                                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-850-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.38 seconds (74 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 190.476 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
851§True§"collected_code/problem-851-0.c:16:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-851-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.03 seconds (612 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 166.667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
852§True§collected_code/problem-852-0.c:6:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] >= 0) {\n                ^\ncollected_code/problem-852-0.c:7:31: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            list[count] = list[i];\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-852-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.28 seconds (92 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 45.4545 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
853§False§Checking collected_code/problem-853-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-853-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 11 in approximately 0.01 seconds (999 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-853-0.c:1:1: error: stray '`' in program\n    1 | ```\n      | ^\ncollected_code/problem-853-0.c:1:2: error: stray '`' in program\n    1 | ```\n      |  ^\ncollected_code/problem-853-0.c:1:3: error: stray '`' in program\n    1 | ```\n      |   ^\n
854§True§"collected_code/problem-854-0.c:8:24: error: Cannot determine that 'arr[left]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] > arr[largest])\n                       ^\ncollected_code/problem-854-0.c:8:36: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] > arr[largest])\n                                   ^\ncollected_code/problem-854-0.c:11:25: error: Cannot determine that 'arr[right]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] > arr[largest])\n                        ^\ncollected_code/problem-854-0.c:11:38: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] > arr[largest])\n                                     ^\ncollected_code/problem-854-0.c:15:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[i];\n                      ^\ncollected_code/problem-854-0.c:16:21: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i] = arr[largest];\n                    ^\ncollected_code/problem-854-0.c:33:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printf(""%d "", arr[i]);\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-854-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 48 in approximately 0.46 seconds (105 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
855§True§"collected_code/problem-855-0.c:15:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-855-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.58 seconds (39 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
856§True§collected_code/problem-856-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == 0)\n               ^\ncollected_code/problem-856-0.c:13:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == 1)\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-856-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.33 seconds (84 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
857§True§"collected_code/problem-857-0.c:6:20: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    printf(""%s\n"", str);\n                   ^\ncollected_code/problem-857-0.c:11:28: error: Cannot determine that 'strings[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        printString(strings[i]);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-857-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2475 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
858§True§collected_code/problem-858-0.c:7:18: error: Cannot determine that 'lists[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (lists[i] != NULL) {\n                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-858-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 26 in approximately 0.37 seconds (71 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
859§True§"collected_code/problem-859-0.c:11:35: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                printf(""%d "", list[j]);\n                                  ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-859-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.51 seconds (47 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
860§False§collected_code/problem-860-0.c:17:28: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    reti = regexec(&regex, string, 0, NULL, 0);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-860-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.01 seconds (3597 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
861§True§"collected_code/problem-861-0.c:7:26: error: Cannot determine that 'str1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length1 = strlen(str1);\n                         ^\ncollected_code/problem-861-0.c:8:26: error: Cannot determine that 'str2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length2 = strlen(str2);\n                         ^\ncollected_code/problem-861-0.c:28:39: error: Cannot determine that 'wordList[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (areAnagrams(word, wordList[i])) {\n                                      ^\ncollected_code/problem-861-0.c:29:36: error: Cannot determine that 'wordList[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%s\n"", wordList[i]);\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-861-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-861-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-861-0.c:8:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 42 in approximately 0.55 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   1 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 93.75 [1+] 62.5 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
862§True§"collected_code/problem-862-0.c:21:20: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; str[i] != '\0'; i++) {\n                   ^\ncollected_code/problem-862-0.c:22:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (isalpha(str[i]) || str[i] == ' ') {\n                       ^\ncollected_code/problem-862-0.c:23:35: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[j++] = tolower(str[i]);\n                                  ^\ncollected_code/problem-862-0.c:35:26: error: Cannot determine that 'text[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char *token = strtok(text, "" "");\n                         ^\ncollected_code/problem-862-0.c:88:11: error: Cannot determine that 'text[0]' is initialized [premium-bughuntingUninit]\n    fgets(text, sizeof(text), stdin);\n          ^\ncollected_code/problem-862-0.c:90:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-862-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-862-0.c:50:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-862-0.c:10:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-862-0.c:84:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 99 in approximately 0.40 seconds (250 lines/second)\nPhysical Source Lines of Code (SLOC) = 79\nHits@level = [0]   5 [1]   0 [2]   2 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   8 [1+]   3 [2+]   3 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 101.266 [1+] 37.9747 [2+] 37.9747 [3+] 12.6582 [4+] 12.6582 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-862-0.c: In function 'findMostCommonWords':\ncollected_code/problem-862-0.c:61:60: warning: use of uninitialized value 'wordList.words[j].count' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   61 |             if (wordList.words[i].count < wordList.words[j].count) {\n      |                                           ~~~~~~~~~~~~~~~~~^~~~~~\n  'main': events 1-2\n    |\n    |   83 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   92 |     WordList commonWords = findMostCommonWords(text, n);\n    |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (2) calling 'findMostCommonWords' from 'main'\n    |\n    +--> 'findMostCommonWords': events 3-4\n           |\n           |   29 | WordList findMostCommonWords(char *text, int n) {\n           |      |          ^~~~~~~~~~~~~~~~~~~\n           |      |          |\n           |      |          (3) entry to 'findMostCommonWords'\n           |   30 |     WordList wordList;\n           |      |              ~~~~~~~~\n           |      |              |\n           |      |              (4) region created on stack here\n           |\n         'findMostCommonWords': events 5-9\n           |\n           |   37 |     while (token != NULL) {\n           |      |                  ^\n           |      |                  |\n           |      |                  (5) following 'true' branch (when 'token' is non-NULL)...\n           |   38 |         int i, found = 0;\n           |      |                ~~~~~\n           |      |                |\n           |      |                (6) ...to here\n           |   39 | \n           |   40 |         for (i = 0; i < wordList.size; i++) {\n           |      |                     ~~~~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (7) following 'false' branch...\n           |......\n           |   48 |         if (!found) {\n           |      |            ~      \n           |      |            |\n           |      |            (8) ...to here\n           |      |            (9) following 'true' branch (when 'found == 0')...\n           |\n         'findMostCommonWords': event 10\n           |\n           |   50 |             strcpy(newWord.word, token);\n           |      |             ^~~~~~\n           |      |             |\n           |      |             (10) ...to here\n           |\n         'findMostCommonWords': events 11-23\n           |\n           |   37 |     while (token != NULL) {\n           |      |                  ^\n           |      |                  |\n           |      |                  (11) following 'true' branch (when 'token' is non-NULL)...\n           |   38 |         int i, found = 0;\n           |      |                ~~~~~\n           |      |                |\n           |      |                (12) ...to here\n           |   39 | \n           |   40 |         for (i = 0; i < wordList.size; i++) {\n           |      |                     ~~~~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (13) following 'true' branch...\n           |   41 |             if (strcmp(wordList.words[i].word, token) == 0) {\n           |      |                ~       ~~~~~~~~~~~~~~~~~~~~~~\n           |      |                |                        |\n           |      |                |                        (14) ...to here\n           |      |                (15) following 'true' branch (when the strings are equal)...\n           |   42 |                 wordList.words[i].count++;\n           |      |                 ~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                  |\n           |      |                                  (16) ...to here\n           |......\n           |   48 |         if (!found) {\n           |      |            ~      \n           |      |            |\n           |      |            (17) following 'false' branch (when 'found != 0')...\n           |......\n           |   56 |         token = strtok(NULL, "" "");\n           |      |                 ~~~~~~~~~~~~~~~~~\n           |      |                 |\n           |      |                 (18) ...to here\n           |......\n           |   59 |     for (int i = 0; i < wordList.size; i++) {\n           |      |                     ~~~~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (19) following 'true' branch...\n           |   60 |         for (int j = i + 1; j < wordList.size; j++) {\n           |      |                  ~          ~~~~~~~~~~~~~~~~~\n           |      |                  |            |\n           |      |                  |            (21) following 'true' branch...\n           |      |                  (20) ...to here\n           |   61 |             if (wordList.words[i].count < wordList.words[j].count) {\n           |      |                 ~~~~~~~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                  |                         |\n           |      |                                  (22) ...to here           (23) use of uninitialized value 'wordList.words[j].count' here\n           |\ncollected_code/problem-862-0.c:77:30: warning: use of uninitialized value 'wordList.words[i]' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   77 |         commonWords.words[i] = wordList.words[i];\n      |         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   83 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   92 |     WordList commonWords = findMostCommonWords(text, n);\n    |      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                            |\n    |      |                            (2) calling 'findMostCommonWords' from 'main'\n    |\n    +--> 'findMostCommonWords': events 3-4\n           |\n           |   29 | WordList findMostCommonWords(char *text, int n) {\n           |      |          ^~~~~~~~~~~~~~~~~~~\n           |      |          |\n           |      |          (3) entry to 'findMostCommonWords'\n           |   30 |     WordList wordList;\n           |      |              ~~~~~~~~\n           |      |              |\n           |      |              (4) region created on stack here\n           |\n         'findMostCommonWords': events 5-9\n           |\n           |   37 |     while (token != NULL) {\n           |      |                  ^\n           |      |                  |\n           |      |                  (5) following 'true' branch (when 'token' is non-NULL)...\n           |   38 |         int i, found = 0;\n           |      |                ~~~~~\n           |      |                |\n           |      |                (6) ...to here\n           |   39 | \n           |   40 |         for (i = 0; i < wordList.size; i++) {\n           |      |                     ~~~~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (7) following 'false' branch...\n           |......\n           |   48 |         if (!found) {\n           |      |            ~      \n           |      |            |\n           |      |            (8) ...to here\n           |      |            (9) following 'true' branch (when 'found == 0')...\n           |\n         'findMostCommonWords': event 10\n           |\n           |   50 |             strcpy(newWord.word, token);\n           |      |             ^~~~~~\n           |      |             |\n           |      |             (10) ...to here\n           |\n         'findMostCommonWords': events 11-27\n           |\n           |   37 |     while (token != NULL) {\n           |      |                  ^\n           |      |                  |\n           |      |                  (11) following 'true' branch (when 'token' is non-NULL)...\n           |   38 |         int i, found = 0;\n           |      |                ~~~~~\n           |      |                |\n           |      |                (12) ...to here\n           |   39 | \n           |   40 |         for (i = 0; i < wordList.size; i++) {\n           |      |                     ~~~~~~~~~~~~~~~~~\n           |      |                       |\n           |      |                       (13) following 'true' branch...\n           |   41 |             if (strcmp(wordList.words[i].word, token) == 0) {\n           |      |                ~       ~~~~~~~~~~~~~~~~~~~~~~\n           |      |                |                        |\n           |      |                |                        (14) ...to here\n           |      |                (15) following 'true' branch (when the strings are equal)...\n           |   42 |                 wordList.words[i].count++;\n           |      |                 ~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                                  |\n           |      |                                  (16) ...to here\n           |......\n           |   48 |         if (!found) {\n           |      |            ~      \n           |      |            |\n           |      |            (17) following 'false' branch (when 'found != 0')...\n           |......\n           |   56 |         token = strtok(NULL, "" "");\n           |      |                 ~~~~~~~~~~~~~~~~~\n           |      |                 |\n           |      |                 (18) ...to here\n           |......\n           |   59 |     for (int i = 0; i < wordList.size; i++) {\n           |      |                     ~~~~~~~~~~~~~~~~~  ~~~\n           |      |                       |                 |\n           |      |                       |                 (22) ...to here\n           |      |                       (19) following 'true' branch...\n           |   60 |         for (int j = i + 1; j < wordList.size; j++) {\n           |      |                  ~          ~~~~~~~~~~~~~~~~~\n           |      |                  |            |\n           |      |                  |            (21) following 'false' branch...\n           |      |                  (20) ...to here\n           |......\n           |   76 |     for (int i = 0; i < n; i++) {\n           |      |                     ~~~~~\n           |      |                       |\n           |      |                       (23) following 'true' branch (when 'i < n')...\n           |      |                       (25) following 'true' branch (when 'i < n')...\n           |   77 |         commonWords.words[i] = wordList.words[i];\n           |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                              |\n           |      |                              (24) ...to here\n           |      |                              (26) ...to here\n           |      |                              (27) use of uninitialized value 'wordList.words[i]' here\n           |\n"
863§True§collected_code/problem-863-0.c:8:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] - arr[i-1] == 1) {\n               ^\ncollected_code/problem-863-0.c:8:25: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] - arr[i-1] == 1) {\n                        ^\ncollected_code/problem-863-0.c:11:21: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[i] != arr[i-1]) {\n                    ^\ncollected_code/problem-863-0.c:11:31: error: Cannot determine that 'arr[i-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        else if (arr[i] != arr[i-1]) {\n                              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-863-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (5805 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 35.7143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
864§True§"collected_code/problem-864-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\ncollected_code/problem-864-0.c:16:33: error: Cannot determine that 'strings[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (isPalindrome(strings[i])) {\n                                ^\ncollected_code/problem-864-0.c:17:52: error: Cannot determine that 'strings[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%s is a palindrome.\n"", strings[i]);\n                                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-864-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-864-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 28 in approximately 0.01 seconds (4454 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+] 41.6667 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
865§True§"collected_code/problem-865-0.c:14:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-865-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.46 seconds (39 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
866§True§"collected_code/problem-866-0.c:4:15: error: Cannot determine that 'month[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if(strcmp(month, ""January"") == 0 || strcmp(month, ""March"") == 0 || strcmp(month, ""May"") == 0 || strcmp(month, ""July"") == 0 || strcmp(month, ""August"") == 0 || strcmp(month, ""October"") == 0 || strcmp(month, ""December"") == 0) {\n              ^\ncollected_code/problem-866-0.c:15:17: error: Cannot determine that 'month[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", month);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-866-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-866-0.c:15:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-866-0.c:13:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 22 in approximately 0.01 seconds (3031 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 238.095 [1+] 95.2381 [2+] 95.2381 [3+] 47.619 [4+] 47.619 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-866-0.c: In function 'checkDays':\ncollected_code/problem-866-0.c:4:8: warning: implicit declaration of function 'strcmp' [-Wimplicit-function-declaration]\n    4 |     if(strcmp(month, ""January"") == 0 || strcmp(month, ""March"") == 0 || strcmp(month, ""May"") == 0 || strcmp(month, ""July"") == 0 || strcmp(month, ""August"") == 0 || strcmp(month, ""October"") == 0 || strcmp(month, ""December"") == 0) {\n      |        ^~~~~~\ncollected_code/problem-866-0.c:2:1: note: include '<string.h>' or provide a declaration of 'strcmp'\n    1 | #include <stdio.h>\n  +++ |+#include <string.h>\n    2 | \n"
867§True§collected_code/problem-867-0.c:6:19: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += arr[i];\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-867-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.56 seconds (41 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 52.6316 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
868§True§collected_code/problem-868-0.c:8:13: error: Cannot determine that 's[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (s[i] != '\0') {\n            ^\ncollected_code/problem-868-0.c:9:14: error: Cannot determine that 's[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (s[i] != ' ') {\n             ^\ncollected_code/problem-868-0.c:16:13: error: Cannot determine that 's[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (s[i] != '\0') {\n            ^\ncollected_code/problem-868-0.c:17:14: error: Cannot determine that 's[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (s[i] != ' ') {\n             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-868-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.26 seconds (121 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 38.4615 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
869§True§Checking collected_code/problem-869-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-869-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 65 in approximately 0.01 seconds (7666 lines/second)\nPhysical Source Lines of Code (SLOC) = 55\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 72.7273 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-869-0.c: In function 'insert':\ncollected_code/problem-869-0.c:30:42: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   30 |     struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n      |                                          ^~~~~~\ncollected_code/problem-869-0.c:2:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    1 | #include <stdio.h>\n  +++ |+#include <stdlib.h>\n    2 | \ncollected_code/problem-869-0.c:30:42: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   30 |     struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n      |                                          ^~~~~~\ncollected_code/problem-869-0.c:30:42: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-869-0.c:31:19: warning: dereference of possibly-NULL 'newNode' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   31 |     newNode->data = newData;\n      |     ~~~~~~~~~~~~~~^~~~~~~~~\n  'insert': events 1-2\n    |\n    |   30 |     struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                          |\n    |      |                                          (1) this call could return NULL\n    |   31 |     newNode->data = newData;\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~               \n    |      |                   |\n    |      |                   (2) 'newNode' could be NULL: unchecked value from (1)\n    |\n
870§True§collected_code/problem-870-0.c:6:20: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (numbers[i] > 0) {\n                   ^\ncollected_code/problem-870-0.c:7:27: error: Cannot determine that 'numbers[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sum += numbers[i];\n                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-870-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.50 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 58.8235 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
871§True§collected_code/problem-871-0.c:13:18: error: Overlapping read/write in strcat() is undefined behavior [overlappingWriteFunction]\n    char* temp = strcat(str1, str1);\n                 ^\ncollected_code/problem-871-0.c:6:24: error: Cannot determine that 'str1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int size1 = strlen(str1);\n                       ^\ncollected_code/problem-871-0.c:7:24: error: Cannot determine that 'str2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int size2 = strlen(str2);\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-871-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-871-0.c:13:  [4] (buffer) strcat:\n  Does not check for buffer overflows when concatenating to destination\n  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or\n  snprintf (warning: strncat is easily misused).\ncollected_code/problem-871-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-871-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 3\nLines analyzed = 33 in approximately 0.31 seconds (108 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   2 [1]   2 [2]   0 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   3 [2+]   1 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 192.308 [1+] 115.385 [2+] 38.4615 [3+] 38.4615 [4+] 38.4615 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
872§True§collected_code/problem-872-0.c:10:18: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list1[i] != list2[i]) {\n                 ^\ncollected_code/problem-872-0.c:10:30: error: Cannot determine that 'list2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list1[i] != list2[i]) {\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-872-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.37 seconds (112 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
873§True§"collected_code/problem-873-0.c:14:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-873-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3453 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 235.294 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
874§True§collected_code/problem-874-0.c:6:23: error: Cannot determine that 'str1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len1 = strlen(str1);\n                      ^\ncollected_code/problem-874-0.c:7:23: error: Cannot determine that 'str2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len2 = strlen(str2);\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-874-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-874-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-874-0.c:7:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 32 in approximately 0.01 seconds (4522 lines/second)\nPhysical Source Lines of Code (SLOC) = 26\nHits@level = [0]   2 [1]   2 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   2 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 153.846 [1+] 76.9231 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
875§True§collected_code/problem-875-0.c:5:29: error: Cannot determine that 'tuple1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int minDiff = abs(tuple1[0] - tuple2[0]);\n                            ^\ncollected_code/problem-875-0.c:5:41: error: Cannot determine that 'tuple2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int minDiff = abs(tuple1[0] - tuple2[0]);\n                                        ^\ncollected_code/problem-875-0.c:7:30: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int diff = abs(tuple1[i] - tuple2[i]);\n                             ^\ncollected_code/problem-875-0.c:7:42: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int diff = abs(tuple1[i] - tuple2[i]);\n                                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-875-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.32 seconds (66 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
876§True§"collected_code/problem-876-0.c:20:21: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                    ^\ncollected_code/problem-876-0.c:20:28: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d"", &num1, &num2);\n                           ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-876-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.49 seconds (45 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
877§True§collected_code/problem-877-0.c:5:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-877-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-877-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 25 in approximately 0.01 seconds (3921 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+] 47.619 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
878§True§collected_code/problem-878-0.c:7:18: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuple[i] != 0) {\n                 ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-878-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3973 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
879§True§collected_code/problem-879-0.c:15:28: error: Cannot determine that 'string[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    reti = regexec(&regex, string, 0, NULL, 0);\n                           ^\ncollected_code/problem-879-0.c:23:32: error: Cannot determine that 'msgbuf[0]' is initialized [premium-bughuntingUninit]\n        regerror(reti, &regex, msgbuf, sizeof(msgbuf));\n                               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-879-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-879-0.c:7:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 38 in approximately 0.39 seconds (97 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   5 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 181.818 [1+] 30.303 [2+] 30.303 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
880§True§"collected_code/problem-880-0.c:18:24: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                       ^\ncollected_code/problem-880-0.c:18:28: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                           ^\ncollected_code/problem-880-0.c:18:32: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                               ^\ncollected_code/problem-880-0.c:20:36: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    int solutions = countSolutions(a, b, c);\n                                   ^\ncollected_code/problem-880-0.c:20:39: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    int solutions = countSolutions(a, b, c);\n                                      ^\ncollected_code/problem-880-0.c:20:42: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    int solutions = countSolutions(a, b, c);\n                                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-880-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.32 seconds (73 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
881§True§collected_code/problem-881-0.c:10:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] % 2 == 0) {\n               ^\ncollected_code/problem-881-0.c:11:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sumEven += arr[i];\n                          ^\ncollected_code/problem-881-0.c:14:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            sumOdd += arr[i];\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-881-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.01 seconds (4420 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 74.0741 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
882§True§"collected_code/problem-882-0.c:11:18: error: Cannot determine that 'length' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &length);\n                 ^\ncollected_code/problem-882-0.c:13:18: error: Cannot determine that 'width' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &width);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-882-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2765 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 333.333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
883§True§"collected_code/problem-883-0.c:8:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] % m == 0 && list[i] % n == 0) {\n                ^\ncollected_code/problem-883-0.c:9:31: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", list[i]);\n                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-883-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.33 seconds (70 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
884§False§Checking collected_code/problem-884-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-884-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 7 in approximately 0.01 seconds (1175 lines/second)\nPhysical Source Lines of Code (SLOC) = 6\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
885§True§collected_code/problem-885-0.c:8:25: error: Cannot determine that 'str1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; str1[i] != '\0'; i++) {\n                        ^\ncollected_code/problem-885-0.c:9:22: error: Cannot determine that 'str1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (map1[str1[i]] == 0 && map2[str2[i]] == 0) {\n                     ^\ncollected_code/problem-885-0.c:9:44: error: Cannot determine that 'str2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (map1[str1[i]] == 0 && map2[str2[i]] == 0) {\n                                           ^\ncollected_code/problem-885-0.c:10:22: error: Cannot determine that 'str1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            map1[str1[i]] = str2[i];\n                     ^\ncollected_code/problem-885-0.c:10:33: error: Cannot determine that 'str2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            map1[str1[i]] = str2[i];\n                                ^\ncollected_code/problem-885-0.c:11:22: error: Cannot determine that 'str2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            map2[str2[i]] = str1[i];\n                     ^\ncollected_code/problem-885-0.c:11:33: error: Cannot determine that 'str1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            map2[str2[i]] = str1[i];\n                                ^\ncollected_code/problem-885-0.c:12:29: error: Cannot determine that 'str1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (map1[str1[i]] != str2[i] || map2[str2[i]] != str1[i]) {\n                            ^\ncollected_code/problem-885-0.c:12:41: error: Cannot determine that 'str2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (map1[str1[i]] != str2[i] || map2[str2[i]] != str1[i]) {\n                                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-885-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.34 seconds (88 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  80 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
886§True§collected_code/problem-886-0.c:6:20: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        sum += list[i];\n                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-886-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (1142 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
887§True§"collected_code/problem-887-0.c:11:18: error: Cannot determine that 'num' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-887-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.74 seconds (23 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 250 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
888§True§collected_code/problem-888-0.c:8:37: error: Cannot determine that 'tuple1[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            result[i][j] = tuple1[i][j] - tuple2[i][j];\n                                    ^\ncollected_code/problem-888-0.c:8:52: error: Cannot determine that 'tuple2[i][j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            result[i][j] = tuple1[i][j] - tuple2[i][j];\n                                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-888-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 22 in approximately 0.01 seconds (2903 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
889§True§collected_code/problem-889-0.c:8:23: error: Cannot determine that 'arr[start]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[start];\n                      ^\ncollected_code/problem-889-0.c:9:25: error: Cannot determine that 'arr[end]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[start] = arr[end];\n                        ^\ncollected_code/problem-889-0.c:19:26: error: Cannot determine that 'lists[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        reverseList(lists[i], sizes[i]);\n                         ^\ncollected_code/problem-889-0.c:19:36: error: Cannot determine that 'sizes[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        reverseList(lists[i], sizes[i]);\n                                   ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-889-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.41 seconds (101 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
890§True§collected_code/problem-890-0.c:8:17: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr1[i] != arr2[i])\n                ^\ncollected_code/problem-890-0.c:8:28: error: Cannot determine that 'arr2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr1[i] != arr2[i])\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-890-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.31 seconds (91 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 45.4545 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
891§True§"collected_code/problem-891-0.c:29:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-891-0.c:32:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-891-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.01 seconds (4852 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
892§True§collected_code/problem-892-0.c:18:9: warning: Uninitialized variable: j [uninitvar]\n    str[j] = '\0';\n        ^\ncollected_code/problem-892-0.c:7:20: note: Assuming condition is false\n    for (i = 0; str[i]; i++) {\n                   ^\ncollected_code/problem-892-0.c:18:9: note: Uninitialized variable: j\n    str[j] = '\0';\n        ^\ncollected_code/problem-892-0.c:15:17: error: Uninitialized variable: j [legacyUninitvar]\n            str[j++] = str[i];\n                ^\ncollected_code/problem-892-0.c:7:20: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (i = 0; str[i]; i++) {\n                   ^\ncollected_code/problem-892-0.c:8:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == ' ' && str[i + 1] == ' ') {\n               ^\ncollected_code/problem-892-0.c:8:33: error: Cannot determine that 'str[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == ' ' && str[i + 1] == ' ') {\n                                ^\ncollected_code/problem-892-0.c:12:22: error: Cannot determine that 'j++' is initialized [premium-bughuntingUninit]\n                str[j++] = ' ';\n                     ^\ncollected_code/problem-892-0.c:15:27: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[j++] = str[i];\n                          ^\ncollected_code/problem-892-0.c:24:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str), stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-892-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-892-0.c:22:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 31 in approximately 0.01 seconds (4985 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+] 37.037 [2+] 37.037 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-892-0.c: In function 'removeMultipleSpaces':\ncollected_code/problem-892-0.c:12:22: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   12 |                 str[j++] = ' ';\n      |                     ~^~\n  'main': events 1-2\n    |\n    |   21 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   27 |     removeMultipleSpaces(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeMultipleSpaces' from 'main'\n    |\n    +--> 'removeMultipleSpaces': events 3-14\n           |\n           |    4 | void removeMultipleSpaces(char *str) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeMultipleSpaces'\n           |    5 |     int i, j;\n           |      |            ~\n           |      |            |\n           |      |            (4) region created on stack here\n           |      |            (5) capacity: 4 bytes\n           |    6 |     int flag = 0;\n           |    7 |     for (i = 0; str[i]; i++) {\n           |      |                 ~~~\n           |      |                 |\n           |      |                 (6) following 'true' branch...\n           |      |                 (10) following 'true' branch...\n           |    8 |         if (str[i] == ' ' && str[i + 1] == ' ') {\n           |      |            ~   ~\n           |      |            |   |\n           |      |            |   (7) ...to here\n           |      |            |   (11) ...to here\n           |      |            (8) following 'true' branch...\n           |    9 |             flag = 1;\n           |      |             ~~~~~~~~\n           |      |                  |\n           |      |                  (9) ...to here\n           |   10 |         } else {\n           |   11 |             if (flag == 1) {\n           |      |                ~\n           |      |                |\n           |      |                (12) following 'true' branch (when 'flag == 1')...\n           |   12 |                 str[j++] = ' ';\n           |      |                     ~~~\n           |      |                      |\n           |      |                      (13) ...to here\n           |      |                      (14) use of uninitialized value 'j' here\n           |\ncollected_code/problem-892-0.c:12:22: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   12 |                 str[j++] = ' ';\n      |                     ~^~\n  'removeMultipleSpaces': events 1-11\n    |\n    |    5 |     int i, j;\n    |      |            ^\n    |      |            |\n    |      |            (1) region created on stack here\n    |      |            (2) capacity: 4 bytes\n    |    6 |     int flag = 0;\n    |    7 |     for (i = 0; str[i]; i++) {\n    |      |                 ~~~\n    |      |                 |\n    |      |                 (3) following 'true' branch...\n    |      |                 (7) following 'true' branch...\n    |    8 |         if (str[i] == ' ' && str[i + 1] == ' ') {\n    |      |            ~   ~\n    |      |            |   |\n    |      |            |   (4) ...to here\n    |      |            |   (8) ...to here\n    |      |            (5) following 'true' branch...\n    |    9 |             flag = 1;\n    |      |             ~~~~~~~~\n    |      |                  |\n    |      |                  (6) ...to here\n    |   10 |         } else {\n    |   11 |             if (flag == 1) {\n    |      |                ~\n    |      |                |\n    |      |                (9) following 'true' branch (when 'flag == 1')...\n    |   12 |                 str[j++] = ' ';\n    |      |                     ~~~\n    |      |                      |\n    |      |                      (10) ...to here\n    |      |                      (11) use of uninitialized value 'j' here\n    |\ncollected_code/problem-892-0.c:15:18: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   15 |             str[j++] = str[i];\n      |                 ~^~\n  'removeMultipleSpaces': events 1-7\n    |\n    |    5 |     int i, j;\n    |      |            ^\n    |      |            |\n    |      |            (1) region created on stack here\n    |      |            (2) capacity: 4 bytes\n    |    6 |     int flag = 0;\n    |    7 |     for (i = 0; str[i]; i++) {\n    |      |                 ~~~\n    |      |                 |\n    |      |                 (3) following 'true' branch...\n    |    8 |         if (str[i] == ' ' && str[i + 1] == ' ') {\n    |      |                ~\n    |      |                |\n    |      |                (4) ...to here\n    |......\n    |   11 |             if (flag == 1) {\n    |      |                ~\n    |      |                |\n    |      |                (5) following 'false' branch (when 'flag != 1')...\n    |......\n    |   15 |             str[j++] = str[i];\n    |      |                 ~~~       ~\n    |      |                  |        |\n    |      |                  |        (6) ...to here\n    |      |                  (7) use of uninitialized value 'j' here\n    |\ncollected_code/problem-892-0.c:15:18: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   15 |             str[j++] = str[i];\n      |                 ~^~\n  'main': events 1-2\n    |\n    |   21 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   27 |     removeMultipleSpaces(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeMultipleSpaces' from 'main'\n    |\n    +--> 'removeMultipleSpaces': events 3-10\n           |\n           |    4 | void removeMultipleSpaces(char *str) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeMultipleSpaces'\n           |    5 |     int i, j;\n           |      |            ~\n           |      |            |\n           |      |            (4) region created on stack here\n           |      |            (5) capacity: 4 bytes\n           |    6 |     int flag = 0;\n           |    7 |     for (i = 0; str[i]; i++) {\n           |      |                 ~~~\n           |      |                 |\n           |      |                 (6) following 'true' branch...\n           |    8 |         if (str[i] == ' ' && str[i + 1] == ' ') {\n           |      |                ~\n           |      |                |\n           |      |                (7) ...to here\n           |......\n           |   11 |             if (flag == 1) {\n           |      |                ~\n           |      |                |\n           |      |                (8) following 'false' branch (when 'flag != 1')...\n           |......\n           |   15 |             str[j++] = str[i];\n           |      |                 ~~~       ~\n           |      |                  |        |\n           |      |                  |        (9) ...to here\n           |      |                  (10) use of uninitialized value 'j' here\n           |\ncollected_code/problem-892-0.c:18:8: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   18 |     str[j] = '\0';\n      |        ^\n  'removeMultipleSpaces': events 1-3\n    |\n    |    5 |     int i, j;\n    |      |            ^\n    |      |            |\n    |      |            (1) region created on stack here\n    |      |            (2) capacity: 4 bytes\n    |......\n    |   18 |     str[j] = '\0';\n    |      |        ~    \n    |      |        |\n    |      |        (3) use of uninitialized value 'j' here\n    |\ncollected_code/problem-892-0.c:18:8: warning: use of uninitialized value 'j' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   18 |     str[j] = '\0';\n      |        ^\n  'main': events 1-2\n    |\n    |   21 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   27 |     removeMultipleSpaces(str);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'removeMultipleSpaces' from 'main'\n    |\n    +--> 'removeMultipleSpaces': events 3-6\n           |\n           |    4 | void removeMultipleSpaces(char *str) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'removeMultipleSpaces'\n           |    5 |     int i, j;\n           |      |            ~\n           |      |            |\n           |      |            (4) region created on stack here\n           |      |            (5) capacity: 4 bytes\n           |......\n           |   18 |     str[j] = '\0';\n           |      |        ~\n           |      |        |\n           |      |        (6) use of uninitialized value 'j' here\n           |\n
893§True§collected_code/problem-893-0.c:5:33: error: Cannot determine that 'arr[i][2]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int lastElement = arr[i][2];\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-893-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.01 seconds (1486 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-893-0.c: In function 'main':\ncollected_code/problem-893-0.c:15:21: warning: initialization of 'int' from 'int *' makes integer from pointer without a cast [-Wint-conversion]\n   15 |     int arr[][3] = {sublist1, sublist2, sublist3};\n      |                     ^~~~~~~~\ncollected_code/problem-893-0.c:15:21: note: (near initialization for 'arr[0][0]')\ncollected_code/problem-893-0.c:15:31: warning: initialization of 'int' from 'int *' makes integer from pointer without a cast [-Wint-conversion]\n   15 |     int arr[][3] = {sublist1, sublist2, sublist3};\n      |                               ^~~~~~~~\ncollected_code/problem-893-0.c:15:31: note: (near initialization for 'arr[0][1]')\ncollected_code/problem-893-0.c:15:41: warning: initialization of 'int' from 'int *' makes integer from pointer without a cast [-Wint-conversion]\n   15 |     int arr[][3] = {sublist1, sublist2, sublist3};\n      |                                         ^~~~~~~~\ncollected_code/problem-893-0.c:15:41: note: (near initialization for 'arr[0][2]')\n
894§True§"collected_code/problem-894-0.c:13:26: error: Cannot determine that 'floatString[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char* token = strtok(floatString, "" "");\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-894-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.44 seconds (64 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
895§True§collected_code/problem-895-0.c:7:19: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return arr[0];\n                  ^\ncollected_code/problem-895-0.c:9:20: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return (arr[0] > arr[1]) ? arr[0] : arr[1];\n                   ^\ncollected_code/problem-895-0.c:9:29: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return (arr[0] > arr[1]) ? arr[0] : arr[1];\n                            ^\ncollected_code/problem-895-0.c:11:24: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int prev_prev = arr[0];\n                       ^\ncollected_code/problem-895-0.c:12:20: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int prev = (arr[0] > arr[1]) ? arr[0] : arr[1];\n                   ^\ncollected_code/problem-895-0.c:12:29: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int prev = (arr[0] > arr[1]) ? arr[0] : arr[1];\n                            ^\ncollected_code/problem-895-0.c:16:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        curr_max = (arr[i] + prev_prev > prev) ? arr[i] + prev_prev : prev;\n                       ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-895-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 32 in approximately 0.35 seconds (90 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
896§True§Checking collected_code/problem-896-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-896-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 28 in approximately 0.01 seconds (4205 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
897§True§collected_code/problem-897-0.c:5:33: error: Cannot determine that 'sentence[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int sentenceLength = strlen(sentence);\n                                ^\ncollected_code/problem-897-0.c:6:29: error: Cannot determine that 'word[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int wordLength = strlen(word);\n                            ^\ncollected_code/problem-897-0.c:27:10: error: Cannot determine that 'sentence[0]' is initialized [premium-bughuntingUninit]\n    gets(sentence);\n         ^\ncollected_code/problem-897-0.c:30:10: error: Cannot determine that 'word[0]' is initialized [premium-bughuntingUninit]\n    gets(word);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-897-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-897-0.c:27:  [5] (buffer) gets:\n  Does not check for buffer overflows (CWE-120, CWE-20). Use fgets() instead.\ncollected_code/problem-897-0.c:30:  [5] (buffer) gets:\n  Does not check for buffer overflows (CWE-120, CWE-20). Use fgets() instead.\ncollected_code/problem-897-0.c:23:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-897-0.c:24:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-897-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-897-0.c:6:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 6\nLines analyzed = 38 in approximately 0.37 seconds (104 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   4 [1]   2 [2]   2 [3]   0 [4]   0 [5]   2\nHits@level+ = [0+]  10 [1+]   6 [2+]   4 [3+]   2 [4+]   2 [5+]   2\nHits/KSLOC@level+ = [0+] 312.5 [1+] 187.5 [2+] 125 [3+] 62.5 [4+] 62.5 [5+] 62.5\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
898§True§"collected_code/problem-898-0.c:12:31: error: Cannot determine that 'list[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", list[j]);\n                              ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-898-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.48 seconds (52 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 190.476 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
899§True§collected_code/problem-899-0.c:8:12: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[0] > arr[size - 1]) {\n           ^\ncollected_code/problem-899-0.c:8:21: error: Cannot determine that 'arr[size-1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (arr[0] > arr[size - 1]) {\n                    ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-899-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3689 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
900§False§Checking collected_code/problem-900-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-900-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-900-0.c:4:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 22 in approximately 0.01 seconds (3171 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   0 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 71.4286 [1+] 71.4286 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-900-0.c: In function 'startsWithNumber':\ncollected_code/problem-900-0.c:12:8: warning: implicit declaration of function 'isdigit' [-Wimplicit-function-declaration]\n   12 |    if (isdigit(str[0])) {\n      |        ^~~~~~~\ncollected_code/problem-900-0.c:2:1: note: include '<ctype.h>' or provide a declaration of 'isdigit'\n    1 | #include <string.h>\n  +++ |+#include <ctype.h>\n    2 | \nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
901§True§"collected_code/problem-901-0.c:24:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-901-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 33 in approximately 0.38 seconds (87 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 148.148 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
902§True§collected_code/problem-902-0.c:27:27: error: Uninitialized variable: k [uninitvar]\n            dict3[size1 + k] = dict2[i]; // Adding new key\n                          ^\ncollected_code/problem-902-0.c:10:25: error: Cannot determine that 'dict1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        dict3[i] = dict1[i];\n                        ^\ncollected_code/problem-902-0.c:19:22: error: Cannot determine that 'dict2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (dict2[i] == dict3[j]) {\n                     ^\ncollected_code/problem-902-0.c:20:42: error: Cannot determine that 'dict2[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                dict3[j + size1] += dict2[i + 1]; // Adding values for common key\n                                         ^\ncollected_code/problem-902-0.c:27:37: error: Cannot determine that 'dict2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            dict3[size1 + k] = dict2[i]; // Adding new key\n                                    ^\ncollected_code/problem-902-0.c:28:41: error: Cannot determine that 'dict2[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            dict3[size1 + k + 1] = dict2[i + 1]; // Adding new value\n                                        ^\ncollected_code/problem-902-0.c:29:13: error: Cannot determine that 'k' is initialized [premium-bughuntingUninit]\n            k += 2; // Updating index for next key-value pair\n            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-902-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 50 in approximately 0.01 seconds (4056 lines/second)\nPhysical Source Lines of Code (SLOC) = 34\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 29.4118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-902-0.c: In function 'combineDictionaries':\ncollected_code/problem-902-0.c:27:25: warning: use of uninitialized value 'k' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   27 |             dict3[size1 + k] = dict2[i]; // Adding new key\n      |                   ~~~~~~^~~\n  'combineDictionaries': events 1-7\n    |\n    |    6 |     int i, j, k;\n    |      |               ^\n    |      |               |\n    |      |               (1) region created on stack here\n    |      |               (2) capacity: 4 bytes\n    |......\n    |   14 |     for (i = 0; i < size2; i++) {\n    |      |                 ~~~~~~~~~\n    |      |                   |\n    |      |                   (3) following 'true' branch (when 'i < size2')...\n    |   15 |         int flag = 0; // Flag to check if key is already present in dict3\n    |      |             ~~~~\n    |      |             |\n    |      |             (4) ...to here\n    |......\n    |   26 |         if (flag == 0) {\n    |      |            ~   \n    |      |            |\n    |      |            (5) following 'true' branch (when 'flag == 0')...\n    |   27 |             dict3[size1 + k] = dict2[i]; // Adding new key\n    |      |                   ~~~~~~~~~         ~\n    |      |                         |           |\n    |      |                         |           (6) ...to here\n    |      |                         (7) use of uninitialized value 'k' here\n    |\ncollected_code/problem-902-0.c:27:25: warning: use of uninitialized value 'k' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   27 |             dict3[size1 + k] = dict2[i]; // Adding new key\n      |                   ~~~~~~^~~\n  'main': events 1-2\n    |\n    |   39 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   48 |     combineDictionaries(dict1, dict2, size1, size2);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'combineDictionaries' from 'main'\n    |\n    +--> 'combineDictionaries': events 3-14\n           |\n           |    4 | void combineDictionaries(int dict1[], int dict2[], int size1, int size2) {\n           |      |      ^~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'combineDictionaries'\n           |    5 |     int dict3[size1 + size2]; // Combined dictionary\n           |    6 |     int i, j, k;\n           |      |               ~\n           |      |               |\n           |      |               (4) region created on stack here\n           |      |               (5) capacity: 4 bytes\n           |......\n           |    9 |     for (i = 0; i < size1; i++) {\n           |      |                 ~~~~~~~~~\n           |      |                   |\n           |      |                   (6) following 'true' branch (when 'i < size1')...\n           |   10 |         dict3[i] = dict1[i];\n           |      |                         ~\n           |      |                         |\n           |      |                         (7) ...to here\n           |......\n           |   14 |     for (i = 0; i < size2; i++) {\n           |      |                 ~~~~~~~~~\n           |      |                   |\n           |      |                   (8) following 'true' branch (when 'i < size2')...\n           |   15 |         int flag = 0; // Flag to check if key is already present in dict3\n           |      |             ~~~~\n           |      |             |\n           |      |             (9) ...to here\n           |......\n           |   18 |         for (j = 0; j < size1; j++) {\n           |      |                     ~~~~~~~~~\n           |      |                       |\n           |      |                       (10) following 'true' branch (when 'j < size1')...\n           |   19 |             if (dict2[i] == dict3[j]) {\n           |      |                      ~\n           |      |                      |\n           |      |                      (11) ...to here\n           |......\n           |   26 |         if (flag == 0) {\n           |      |            ~\n           |      |            |\n           |      |            (12) following 'true' branch (when 'flag == 0')...\n           |   27 |             dict3[size1 + k] = dict2[i]; // Adding new key\n           |      |                   ~~~~~~~~~         ~\n           |      |                         |           |\n           |      |                         |           (13) ...to here\n           |      |                         (14) use of uninitialized value 'k' here\n           |\n
903§True§"collected_code/problem-903-0.c:7:27: error: Signed integer overflow for expression '1<<bit'. [integerOverflow]\n            if ((num & (1 << bit)) == 0) {\n                          ^\ncollected_code/problem-903-0.c:6:31: note: Assuming that condition 'bit<sizeof(int)*8' is not redundant\n        for (int bit = 0; bit < sizeof(int) * 8; bit++) {\n                              ^\ncollected_code/problem-903-0.c:7:27: note: Integer overflow\n            if ((num & (1 << bit)) == 0) {\n                          ^\ncollected_code/problem-903-0.c:18:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-903-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 20 in approximately 0.53 seconds (38 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
904§False§Checking collected_code/problem-904-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-904-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 6 in approximately 0.70 seconds (9 lines/second)\nPhysical Source Lines of Code (SLOC) = 7\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-904-0.c:1:1: error: unknown type name 'bool'\n    1 | bool isEven(int number) {\n      | ^~~~\ncollected_code/problem-904-0.c:1:1: note: 'bool' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n  +++ |+#include <stdbool.h>\n    1 | bool isEven(int number) {\ncollected_code/problem-904-0.c: In function 'isEven':\ncollected_code/problem-904-0.c:3:16: error: 'true' undeclared (first use in this function)\n    3 |         return true;\n      |                ^~~~\ncollected_code/problem-904-0.c:3:16: note: 'true' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\ncollected_code/problem-904-0.c:3:16: note: each undeclared identifier is reported only once for each function it appears in\ncollected_code/problem-904-0.c:5:16: error: 'false' undeclared (first use in this function)\n    5 |         return false;\n      |                ^~~~~\ncollected_code/problem-904-0.c:5:16: note: 'false' is defined in header '<stdbool.h>'; did you forget to '#include <stdbool.h>'?\n
905§True§"collected_code/problem-905-0.c:30:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-905-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.48 seconds (73 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 120 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
906§True§"collected_code/problem-906-0.c:27:32: error: Cannot determine that 'match[1]' is initialized [premium-bughuntingUninit]\n        int year_length = match[1].rm_eo - match[1].rm_so;\n                               ^\ncollected_code/problem-906-0.c:28:33: error: Cannot determine that 'match[2]' is initialized [premium-bughuntingUninit]\n        int month_length = match[2].rm_eo - match[2].rm_so;\n                                ^\ncollected_code/problem-906-0.c:29:32: error: Cannot determine that 'match[3]' is initialized [premium-bughuntingUninit]\n        int date_length = match[3].rm_eo - match[3].rm_so;\n                               ^\ncollected_code/problem-906-0.c:36:16: error: Cannot determine that 'year[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        memcpy(year, url + match[1].rm_so, year_length);\n               ^\ncollected_code/problem-906-0.c:36:33: error: Cannot determine that 'match[1]' is initialized [premium-bughuntingUninit]\n        memcpy(year, url + match[1].rm_so, year_length);\n                                ^\ncollected_code/problem-906-0.c:39:16: error: Cannot determine that 'month[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        memcpy(month, url + match[2].rm_so, month_length);\n               ^\ncollected_code/problem-906-0.c:39:34: error: Cannot determine that 'match[2]' is initialized [premium-bughuntingUninit]\n        memcpy(month, url + match[2].rm_so, month_length);\n                                 ^\ncollected_code/problem-906-0.c:42:16: error: Cannot determine that 'date[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        memcpy(date, url + match[3].rm_so, date_length);\n               ^\ncollected_code/problem-906-0.c:42:33: error: Cannot determine that 'match[3]' is initialized [premium-bughuntingUninit]\n        memcpy(date, url + match[3].rm_so, date_length);\n                                ^\ncollected_code/problem-906-0.c:65:30: error: Cannot determine that 'year[0]' is initialized [premium-bughuntingUninit]\n        printf(""Year: %s\n"", year);\n                             ^\ncollected_code/problem-906-0.c:66:31: error: Cannot determine that 'month[0]' is initialized [premium-bughuntingUninit]\n        printf(""Month: %s\n"", month);\n                              ^\ncollected_code/problem-906-0.c:67:30: error: Cannot determine that 'date[0]' is initialized [premium-bughuntingUninit]\n        printf(""Date: %s\n"", date);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-906-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-906-0.c:13:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-906-0.c:14:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-906-0.c:15:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-906-0.c:36:  [2] (buffer) memcpy:\n  Does not check for buffer overflows when copying to destination (CWE-120).\n  Make sure destination can always hold the source data.\ncollected_code/problem-906-0.c:39:  [2] (buffer) memcpy:\n  Does not check for buffer overflows when copying to destination (CWE-120).\n  Make sure destination can always hold the source data.\ncollected_code/problem-906-0.c:42:  [2] (buffer) memcpy:\n  Does not check for buffer overflows when copying to destination (CWE-120).\n  Make sure destination can always hold the source data.\ncollected_code/problem-906-0.c:58:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-906-0.c:59:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-906-0.c:60:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 9\nLines analyzed = 70 in approximately 0.01 seconds (5140 lines/second)\nPhysical Source Lines of Code (SLOC) = 56\nHits@level = [0]   7 [1]   0 [2]   9 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]  16 [1+]   9 [2+]   9 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 285.714 [1+] 160.714 [2+] 160.714 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-906-0.c: In function 'extract_date_from_url':\ncollected_code/problem-906-0.c:13:44: warning: initializer-string for array of 'char' is too long\n   13 |     char year_regex[MAX_YEAR_LENGTH + 1] = ""[0-9]{4}"";\n      |                                            ^~~~~~~~~~\ncollected_code/problem-906-0.c:14:46: warning: initializer-string for array of 'char' is too long\n   14 |     char month_regex[MAX_MONTH_LENGTH + 1] = ""[0-9]{2}"";\n      |                                              ^~~~~~~~~~\ncollected_code/problem-906-0.c:15:44: warning: initializer-string for array of 'char' is too long\n   15 |     char date_regex[MAX_DATE_LENGTH + 1] = ""[0-9]{2}"";\n      |                                            ^~~~~~~~~~\ncollected_code/problem-906-0.c:36:9: warning: implicit declaration of function 'memcpy' [-Wimplicit-function-declaration]\n   36 |         memcpy(year, url + match[1].rm_so, year_length);\n      |         ^~~~~~\ncollected_code/problem-906-0.c:4:1: note: include '<string.h>' or provide a declaration of 'memcpy'\n    3 | #include <regex.h>\n  +++ |+#include <string.h>\n    4 | \ncollected_code/problem-906-0.c:36:9: warning: incompatible implicit declaration of built-in function 'memcpy' [-Wbuiltin-declaration-mismatch]\n   36 |         memcpy(year, url + match[1].rm_so, year_length);\n      |         ^~~~~~\ncollected_code/problem-906-0.c:36:9: note: include '<string.h>' or provide a declaration of 'memcpy'\n"
907§True§"collected_code/problem-907-0.c:41:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-907-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 46 in approximately 0.01 seconds (6586 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 137.931 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
908§True§collected_code/problem-908-0.c:5:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] == i) {\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-908-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.64 seconds (36 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
909§True§"collected_code/problem-909-0.c:33:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-909-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 38 in approximately 0.58 seconds (65 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 96.7742 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
910§False§Checking collected_code/problem-910-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-910-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 42 in approximately 0.56 seconds (75 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
911§True§collected_code/problem-911-0.c:8:24: error: Cannot determine that 'arr[left]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] > arr[largest])\n                       ^\ncollected_code/problem-911-0.c:8:36: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (left < n && arr[left] > arr[largest])\n                                   ^\ncollected_code/problem-911-0.c:11:25: error: Cannot determine that 'arr[right]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] > arr[largest])\n                        ^\ncollected_code/problem-911-0.c:11:38: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (right < n && arr[right] > arr[largest])\n                                     ^\ncollected_code/problem-911-0.c:15:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int temp = arr[i];\n                      ^\ncollected_code/problem-911-0.c:16:21: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        arr[i] = arr[largest];\n                    ^\ncollected_code/problem-911-0.c:36:23: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        product *= arr[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-911-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 48 in approximately 0.01 seconds (4563 lines/second)\nPhysical Source Lines of Code (SLOC) = 35\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 28.5714 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
912§True§"collected_code/problem-912-0.c:19:18: error: Cannot determine that 'm' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &m);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-912-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3132 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 150 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
913§True§collected_code/problem-913-0.c:8:18: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (string[i] != '\0') {\n                 ^\ncollected_code/problem-913-0.c:16:15: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (string[i] >= '0' && string[i] <= '9') {\n              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-913-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.44 seconds (68 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
914§False§collected_code/problem-914-0.c:8:15: error: Cannot determine that 'str[length]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[length] != '\0') {\n              ^\ncollected_code/problem-914-0.c:19:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == str[i + 1]) {\n               ^\ncollected_code/problem-914-0.c:19:26: error: Cannot determine that 'str[i+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == str[i + 1]) {\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-914-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3448 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
915§True§collected_code/problem-915-0.c:7:16: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (arr[i] < 0) {\n               ^\ncollected_code/problem-915-0.c:9:27: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                temp = arr[i];\n                          ^\ncollected_code/problem-915-0.c:10:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                arr[i] = arr[j];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-915-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 29 in approximately 0.59 seconds (49 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 83.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
916§True§collected_code/problem-916-0.c:15:24: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (arr[i] + arr[j] + arr[k] == given)\n                       ^\ncollected_code/problem-916-0.c:15:33: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (arr[i] + arr[j] + arr[k] == given)\n                                ^\ncollected_code/problem-916-0.c:15:42: error: Cannot determine that 'arr[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (arr[i] + arr[j] + arr[k] == given)\n                                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-916-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (4630 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 74.0741 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
917§True§collected_code/problem-917-0.c:5:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i] != '\0') {\n              ^\ncollected_code/problem-917-0.c:6:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n               ^\ncollected_code/problem-917-0.c:7:24: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            putchar(str[i]);\n                       ^\ncollected_code/problem-917-0.c:9:23: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            while (str[i] >= 'a' && str[i] <= 'z') {\n                      ^\ncollected_code/problem-917-0.c:10:28: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                putchar(str[i]);\n                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-917-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3726 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
918§True§collected_code/problem-918-0.c:16:39: error: Cannot determine that 'coins[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int includeCoin = (i-coins[j] >= 0) ? table[i-coins[j]][j] : 0;\n                                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-918-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.51 seconds (77 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
919§True§collected_code/problem-919-0.c:6:23: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        result *= list[i];\n                      ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-919-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 16 in approximately 0.01 seconds (2296 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
920§True§"collected_code/problem-920-0.c:20:21: error: Uninitialized variables: noneTuple.x, noneTuple.y [uninitvar]\n        tuples[i] = noneTuple;\n                    ^\ncollected_code/problem-920-0.c:13:14: warning: Uninitialized variable: tuples [uninitvar]\n        if (!tuples[i].isEmpty) {\n             ^\ncollected_code/problem-920-0.c:28:22: note: Calling function 'removeNoneValues', 1st argument 'tuples' value is <Uninit>\n    removeNoneValues(tuples, size);\n                     ^\ncollected_code/problem-920-0.c:13:14: note: Uninitialized variable: tuples\n        if (!tuples[i].isEmpty) {\n             ^\ncollected_code/problem-920-0.c:20:21: error: Uninitialized struct member: noneTuple.x [uninitStructMember]\n        tuples[i] = noneTuple;\n                    ^\ncollected_code/problem-920-0.c:20:21: error: Uninitialized struct member: noneTuple.y [uninitStructMember]\n        tuples[i] = noneTuple;\n                    ^\ncollected_code/problem-920-0.c:32:36: error: Cannot determine that 'tuples[i] members' is initialized [premium-bughuntingUninit]\n        printf(""(%d, %d)\n"", tuples[i].x, tuples[i].y);\n                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-920-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 35 in approximately 0.01 seconds (5471 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 34.4828 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-920-0.c: In function 'removeNoneValues':\ncollected_code/problem-920-0.c:13:23: warning: use of uninitialized value '*tuples_29(D) + _2.isEmpty' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   13 |         if (!tuples[i].isEmpty) {\n      |              ~~~~~~~~~^~~~~~~~\n  'main': events 1-3\n    |\n    |   24 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |   25 |     int size = 5; // replace with actual size of tuple list\n    |   26 |     Tuple tuples[size]; // replace with actual tuple list\n    |      |           ~~~~~~\n    |      |           |\n    |      |           (2) region created on stack here\n    |   27 |     // call removeNoneValues function passing the tuple list and size\n    |   28 |     removeNoneValues(tuples, size);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (3) calling 'removeNoneValues' from 'main'\n    |\n    +--> 'removeNoneValues': events 4-7\n           |\n           |   10 | void removeNoneValues(Tuple tuples[], int size) {\n           |      |      ^~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (4) entry to 'removeNoneValues'\n           |   11 |     int count = 0;\n           |   12 |     for (int i = 0; i < size; i++) {\n           |      |                     ~~~~~~~~\n           |      |                       |\n           |      |                       (5) following 'true' branch (when 'i < size')...\n           |   13 |         if (!tuples[i].isEmpty) {\n           |      |              ~~~~~~~~~~~~~~~~~\n           |      |                    |  |\n           |      |                    |  (7) use of uninitialized value '*tuples_29(D) + _2.isEmpty' here\n           |      |                    (6) ...to here\n           |\n
921§True§"collected_code/problem-921-0.c:8:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""%d "", arr[j]);\n                             ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-921-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3380 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 111.111 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
922§True§"collected_code/problem-922-0.c:9:26: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max_product = arr[0] * arr[1];\n                         ^\ncollected_code/problem-922-0.c:9:35: error: Cannot determine that 'arr[1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int max_product = arr[0] * arr[1];\n                                  ^\ncollected_code/problem-922-0.c:14:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] * arr[j] > max_product) {\n                   ^\ncollected_code/problem-922-0.c:14:29: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] * arr[j] > max_product) {\n                            ^\ncollected_code/problem-922-0.c:15:34: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                max_product = arr[i] * arr[j];\n                                 ^\ncollected_code/problem-922-0.c:15:43: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                max_product = arr[i] * arr[j];\n                                          ^\ncollected_code/problem-922-0.c:22:56: error: Cannot determine that 'arr[max_i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    printf(""Pair with highest product: (%d, %d)\n"", arr[max_i], arr[max_j]);\n                                                       ^\ncollected_code/problem-922-0.c:22:68: error: Cannot determine that 'arr[max_j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    printf(""Pair with highest product: (%d, %d)\n"", arr[max_i], arr[max_j]);\n                                                                   ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-922-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.03 seconds (942 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  80 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
923§False§collected_code/problem-923-0.c:9:23: error: Cannot determine that 'str1[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len1 = strlen(str1);\n                      ^\ncollected_code/problem-923-0.c:10:23: error: Cannot determine that 'str2[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len2 = strlen(str2);\n                      ^\ncollected_code/problem-923-0.c:33:10: error: Cannot determine that 'str1[0]' is initialized [premium-bughuntingUninit]\n    gets(str1);\n         ^\ncollected_code/problem-923-0.c:35:10: error: Cannot determine that 'str2[0]' is initialized [premium-bughuntingUninit]\n    gets(str2);\n         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-923-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-923-0.c:33:  [5] (buffer) gets:\n  Does not check for buffer overflows (CWE-120, CWE-20). Use fgets() instead.\ncollected_code/problem-923-0.c:35:  [5] (buffer) gets:\n  Does not check for buffer overflows (CWE-120, CWE-20). Use fgets() instead.\ncollected_code/problem-923-0.c:30:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-923-0.c:9:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-923-0.c:10:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 5\nLines analyzed = 40 in approximately 0.58 seconds (69 lines/second)\nPhysical Source Lines of Code (SLOC) = 33\nHits@level = [0]   3 [1]   2 [2]   1 [3]   0 [4]   0 [5]   2\nHits@level+ = [0+]   8 [1+]   5 [2+]   3 [3+]   2 [4+]   2 [5+]   2\nHits/KSLOC@level+ = [0+] 242.424 [1+] 151.515 [2+] 90.9091 [3+] 60.6061 [4+] 60.6061 [5+] 60.6061\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-923-0.c: In function 'findShortestString':\ncollected_code/problem-923-0.c:20:28: warning: implicit declaration of function 'max' [-Wimplicit-function-declaration]\n   20 |                 dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n      |                            ^~~\nUndefined symbols for architecture x86_64:\n  ""_max"", referenced from:\n      _findShortestString in ccCr7l9X.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
924§True§Checking collected_code/problem-924-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-924-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.01 seconds (1687 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
925§True§collected_code/problem-925-0.c:7:25: error: Cannot determine that 'tuple[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        product *= tuple[i];\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-925-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3125 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 66.6667 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
926§True§"collected_code/problem-926-0.c:13:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-926-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.77 seconds (22 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 214.286 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
927§True§Checking collected_code/problem-927-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-927-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 43 in approximately 0.01 seconds (4208 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 27.7778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-927-0.c: In function 'newNode':\ncollected_code/problem-927-0.c:26:16: warning: dereference of possibly-NULL 'node' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   26 |     node->data = data;\n      |     ~~~~~~~~~~~^~~~~~\n  'newNode': events 1-2\n    |\n    |   25 |     struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    |      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                       |\n    |      |                                       (1) this call could return NULL\n    |   26 |     node->data = data;\n    |      |     ~~~~~~~~~~~~~~~~~                  \n    |      |                |\n    |      |                (2) 'node' could be NULL: unchecked value from (1)\n    |\n
928§True§collected_code/problem-928-0.c:6:13: error: Cannot determine that 'temp[0]' is initialized [premium-bughuntingUninit]\n    strncpy(temp, date, 2); // Extract day\n            ^\ncollected_code/problem-928-0.c:6:19: error: Cannot determine that 'date[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    strncpy(temp, date, 2); // Extract day\n                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-928-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-928-0.c:13:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-928-0.c:19:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-928-0.c:5:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-928-0.c:17:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-928-0.c:6:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\ncollected_code/problem-928-0.c:8:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\ncollected_code/problem-928-0.c:10:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\n\nANALYSIS SUMMARY:\n\nHits = 7\nLines analyzed = 24 in approximately 0.44 seconds (55 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   3 [2]   2 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]   9 [1+]   7 [2+]   4 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 450 [1+] 350 [2+] 200 [3+] 100 [4+] 100 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
929§True§collected_code/problem-929-0.c:7:26: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int current = arr[i];\n                         ^\ncollected_code/problem-929-0.c:11:31: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (current == arr[j]) {\n                              ^\ncollected_code/problem-929-0.c:21:35: error: Cannot determine that 'arr[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                if (current == arr[k]) {\n                                  ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-929-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.01 seconds (2897 lines/second)\nPhysical Source Lines of Code (SLOC) = 32\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 31.25 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
930§True§Checking collected_code/problem-930-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-930-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.01 seconds (5023 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 120 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
931§True§"collected_code/problem-931-0.c:14:17: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n   scanf(""%d"", &n);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-931-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 17 in approximately 0.06 seconds (271 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 187.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
932§True§Checking collected_code/problem-932-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-932-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.43 seconds (80 lines/second)\nPhysical Source Lines of Code (SLOC) = 30\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 33.3333 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
933§False§collected_code/problem-933-0.c:16:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    length += strlen(str) + 1;\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-933-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-933-0.c:37:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-933-0.c:16:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-933-0.c:29:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\ncollected_code/problem-933-0.c:31:  [1] (buffer) strncpy:\n  Easily used incorrectly; doesn't always \0-terminate or check for invalid\n  pointers [MS-banned] (CWE-120).\ncollected_code/problem-933-0.c:31:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-933-0.c:32:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 6\nLines analyzed = 48 in approximately 0.58 seconds (83 lines/second)\nPhysical Source Lines of Code (SLOC) = 38\nHits@level = [0]   2 [1]   5 [2]   0 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   8 [1+]   6 [2+]   1 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 210.526 [1+] 157.895 [2+] 26.3158 [3+] 26.3158 [4+] 26.3158 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-933-0.c: In function 'camelToSnake':\ncollected_code/problem-933-0.c:15:27: error: 'REG_EBUF' undeclared (first use in this function); did you mean 'REG_EBRACE'?\n   15 |     int length = regerror(REG_EBUF, &regex, NULL, 0);\n      |                           ^~~~~~~~\n      |                           REG_EBRACE\ncollected_code/problem-933-0.c:15:27: note: each undeclared identifier is reported only once for each function it appears in\ncollected_code/problem-933-0.c:16:15: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n   16 |     length += strlen(str) + 1;\n      |               ^~~~~~\ncollected_code/problem-933-0.c:3:1: note: include '<string.h>' or provide a declaration of 'strlen'\n    2 | #include <regex.h>\n  +++ |+#include <string.h>\n    3 | \ncollected_code/problem-933-0.c:16:15: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n   16 |     length += strlen(str) + 1;\n      |               ^~~~~~\ncollected_code/problem-933-0.c:16:15: note: include '<string.h>' or provide a declaration of 'strlen'\ncollected_code/problem-933-0.c:17:14: warning: implicit declaration of function 'malloc' [-Wimplicit-function-declaration]\n   17 |     result = malloc(length);\n      |              ^~~~~~\ncollected_code/problem-933-0.c:3:1: note: include '<stdlib.h>' or provide a declaration of 'malloc'\n    2 | #include <regex.h>\n  +++ |+#include <stdlib.h>\n    3 | \ncollected_code/problem-933-0.c:17:14: warning: incompatible implicit declaration of built-in function 'malloc' [-Wbuiltin-declaration-mismatch]\n   17 |     result = malloc(length);\n      |              ^~~~~~\ncollected_code/problem-933-0.c:17:14: note: include '<stdlib.h>' or provide a declaration of 'malloc'\ncollected_code/problem-933-0.c:29:9: warning: implicit declaration of function 'strncpy' [-Wimplicit-function-declaration]\n   29 |         strncpy(result + i, str + offset, start);\n      |         ^~~~~~~\ncollected_code/problem-933-0.c:29:9: note: include '<string.h>' or provide a declaration of 'strncpy'\ncollected_code/problem-933-0.c:29:9: warning: incompatible implicit declaration of built-in function 'strncpy' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-933-0.c:29:9: note: include '<string.h>' or provide a declaration of 'strncpy'\ncollected_code/problem-933-0.c:37:5: warning: implicit declaration of function 'strcpy' [-Wimplicit-function-declaration]\n   37 |     strcpy(result + i, str + offset);\n      |     ^~~~~~\ncollected_code/problem-933-0.c:37:5: note: include '<string.h>' or provide a declaration of 'strcpy'\ncollected_code/problem-933-0.c:37:5: warning: incompatible implicit declaration of built-in function 'strcpy' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-933-0.c:37:5: note: include '<string.h>' or provide a declaration of 'strcpy'\ncollected_code/problem-933-0.c:40:5: warning: implicit declaration of function 'free' [-Wimplicit-function-declaration]\n   40 |     free(result);\n      |     ^~~~\ncollected_code/problem-933-0.c:40:5: note: include '<stdlib.h>' or provide a declaration of 'free'\ncollected_code/problem-933-0.c:40:5: warning: incompatible implicit declaration of built-in function 'free' [-Wbuiltin-declaration-mismatch]\ncollected_code/problem-933-0.c:40:5: note: include '<stdlib.h>' or provide a declaration of 'free'\n
934§False§Checking collected_code/problem-934-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-934-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 10 in approximately 0.01 seconds (1427 lines/second)\nPhysical Source Lines of Code (SLOC) = 8\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
935§True§"collected_code/problem-935-0.c:16:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-935-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 19 in approximately 0.32 seconds (59 lines/second)\nPhysical Source Lines of Code (SLOC) = 15\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 200 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
936§True§collected_code/problem-936-0.c:6:25: error: Cannot determine that 'orderedList[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        temp[orderedList[i]] = tuples[i];\n                        ^\ncollected_code/problem-936-0.c:6:38: error: Cannot determine that 'tuples[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        temp[orderedList[i]] = tuples[i];\n                                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-936-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.40 seconds (62 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
937§True§collected_code/problem-937-0.c:9:27: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; string[i] != '\0'; i++) {\n                          ^\ncollected_code/problem-937-0.c:10:21: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        count[string[i]]++;\n                    ^\ncollected_code/problem-937-0.c:13:25: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (count[string[i]] > max_count) {\n                        ^\ncollected_code/problem-937-0.c:14:37: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            max_count = count[string[i]];\n                                    ^\ncollected_code/problem-937-0.c:15:33: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            most_common = string[i];\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-937-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.40 seconds (67 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  50 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
938§False§"collected_code/problem-938-0.c:30:44: warning: Uninitialized variable: res1 [uninitvar]\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                           ^\ncollected_code/problem-938-0.c:10:29: note: Assuming condition is false\n    while (i < n1 && j < n2 && k < n3) {\n                            ^\ncollected_code/problem-938-0.c:30:44: note: Uninitialized variable: res1\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                           ^\ncollected_code/problem-938-0.c:30:50: warning: Uninitialized variable: res2 [uninitvar]\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                                 ^\ncollected_code/problem-938-0.c:10:29: note: Assuming condition is false\n    while (i < n1 && j < n2 && k < n3) {\n                            ^\ncollected_code/problem-938-0.c:30:50: note: Uninitialized variable: res2\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                                 ^\ncollected_code/problem-938-0.c:30:56: warning: Uninitialized variable: res3 [uninitvar]\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                                       ^\ncollected_code/problem-938-0.c:10:29: note: Assuming condition is false\n    while (i < n1 && j < n2 && k < n3) {\n                            ^\ncollected_code/problem-938-0.c:30:56: note: Uninitialized variable: res3\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                                       ^\ncollected_code/problem-938-0.c:11:31: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int minimum = min(arr1[i], min(arr2[j], arr3[k]));\n                              ^\ncollected_code/problem-938-0.c:11:44: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int minimum = min(arr1[i], min(arr2[j], arr3[k]));\n                                           ^\ncollected_code/problem-938-0.c:11:53: error: Cannot determine that 'arr3[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int minimum = min(arr1[i], min(arr2[j], arr3[k]));\n                                                    ^\ncollected_code/problem-938-0.c:12:31: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int maximum = max(arr1[i], max(arr2[j], arr3[k]));\n                              ^\ncollected_code/problem-938-0.c:12:44: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int maximum = max(arr1[i], max(arr2[j], arr3[k]));\n                                           ^\ncollected_code/problem-938-0.c:12:53: error: Cannot determine that 'arr3[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        int maximum = max(arr1[i], max(arr2[j], arr3[k]));\n                                                    ^\ncollected_code/problem-938-0.c:16:24: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            res1 = arr1[i];\n                       ^\ncollected_code/problem-938-0.c:17:24: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            res2 = arr2[j];\n                       ^\ncollected_code/problem-938-0.c:18:24: error: Cannot determine that 'arr3[k]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            res3 = arr3[k];\n                       ^\ncollected_code/problem-938-0.c:21:28: error: Cannot determine that 'arr1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (minimum == arr1[i]) {\n                           ^\ncollected_code/problem-938-0.c:23:35: error: Cannot determine that 'arr2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        } else if (minimum == arr2[j]) {\n                                  ^\ncollected_code/problem-938-0.c:30:44: error: Cannot determine that 'res1' is initialized [premium-bughuntingUninit]\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                           ^\ncollected_code/problem-938-0.c:30:50: error: Cannot determine that 'res2' is initialized [premium-bughuntingUninit]\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                                 ^\ncollected_code/problem-938-0.c:30:56: error: Cannot determine that 'res3' is initialized [premium-bughuntingUninit]\n    printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n                                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-938-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 45 in approximately 0.01 seconds (6643 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 27.7778 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-938-0.c: In function 'threeClosestElements':\ncollected_code/problem-938-0.c:11:23: warning: implicit declaration of function 'min' [-Wimplicit-function-declaration]\n   11 |         int minimum = min(arr1[i], min(arr2[j], arr3[k]));\n      |                       ^~~\ncollected_code/problem-938-0.c:12:23: warning: implicit declaration of function 'max' [-Wimplicit-function-declaration]\n   12 |         int maximum = max(arr1[i], max(arr2[j], arr3[k]));\n      |                       ^~~\ncollected_code/problem-938-0.c:30:5: warning: use of uninitialized value 'res2' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   30 |     printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   33 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   42 |     threeClosestElements(arr1, arr2, arr3, n1, n2, n3);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'threeClosestElements' from 'main'\n    |\n    +--> 'threeClosestElements': events 3-10\n           |\n           |    5 | void threeClosestElements(int arr1[], int arr2[], int arr3[], int n1, int n2, int n3) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'threeClosestElements'\n           |......\n           |    8 |     int res1, res2, res3;\n           |      |               ~~~~\n           |      |               |\n           |      |               (4) region created on stack here\n           |      |               (5) capacity: 4 bytes\n           |    9 | \n           |   10 |     while (i < n1 && j < n2 && k < n3) {\n           |      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                             |\n           |      |                             (6) following 'true' branch...\n           |   11 |         int minimum = min(arr1[i], min(arr2[j], arr3[k]));\n           |      |                                                     ~\n           |      |                                                     |\n           |      |                                                     (7) ...to here\n           |......\n           |   14 |         if (maximum - minimum < diff) {\n           |      |            ~\n           |      |            |\n           |      |            (8) following 'false' branch...\n           |......\n           |   21 |         if (minimum == arr1[i]) {\n           |      |                            ~\n           |      |                            |\n           |      |                            (9) ...to here\n           |......\n           |   30 |     printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n           |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (10) use of uninitialized value 'res2' here\n           |\ncollected_code/problem-938-0.c:30:5: warning: use of uninitialized value 'res3' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   30 |     printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   33 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   42 |     threeClosestElements(arr1, arr2, arr3, n1, n2, n3);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'threeClosestElements' from 'main'\n    |\n    +--> 'threeClosestElements': events 3-10\n           |\n           |    5 | void threeClosestElements(int arr1[], int arr2[], int arr3[], int n1, int n2, int n3) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'threeClosestElements'\n           |......\n           |    8 |     int res1, res2, res3;\n           |      |                     ~~~~\n           |      |                     |\n           |      |                     (4) region created on stack here\n           |      |                     (5) capacity: 4 bytes\n           |    9 | \n           |   10 |     while (i < n1 && j < n2 && k < n3) {\n           |      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                             |\n           |      |                             (6) following 'true' branch...\n           |   11 |         int minimum = min(arr1[i], min(arr2[j], arr3[k]));\n           |      |                                                     ~\n           |      |                                                     |\n           |      |                                                     (7) ...to here\n           |......\n           |   14 |         if (maximum - minimum < diff) {\n           |      |            ~\n           |      |            |\n           |      |            (8) following 'false' branch...\n           |......\n           |   21 |         if (minimum == arr1[i]) {\n           |      |                            ~\n           |      |                            |\n           |      |                            (9) ...to here\n           |......\n           |   30 |     printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n           |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (10) use of uninitialized value 'res3' here\n           |\ncollected_code/problem-938-0.c:30:5: warning: use of uninitialized value 'res1' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]\n   30 |     printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'main': events 1-2\n    |\n    |   33 | int main() {\n    |      |     ^~~~\n    |      |     |\n    |      |     (1) entry to 'main'\n    |......\n    |   42 |     threeClosestElements(arr1, arr2, arr3, n1, n2, n3);\n    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |     |\n    |      |     (2) calling 'threeClosestElements' from 'main'\n    |\n    +--> 'threeClosestElements': events 3-10\n           |\n           |    5 | void threeClosestElements(int arr1[], int arr2[], int arr3[], int n1, int n2, int n3) {\n           |      |      ^~~~~~~~~~~~~~~~~~~~\n           |      |      |\n           |      |      (3) entry to 'threeClosestElements'\n           |......\n           |    8 |     int res1, res2, res3;\n           |      |         ~~~~\n           |      |         |\n           |      |         (4) region created on stack here\n           |      |         (5) capacity: 4 bytes\n           |    9 | \n           |   10 |     while (i < n1 && j < n2 && k < n3) {\n           |      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |                             |\n           |      |                             (6) following 'true' branch...\n           |   11 |         int minimum = min(arr1[i], min(arr2[j], arr3[k]));\n           |      |                                                     ~\n           |      |                                                     |\n           |      |                                                     (7) ...to here\n           |......\n           |   14 |         if (maximum - minimum < diff) {\n           |      |            ~\n           |      |            |\n           |      |            (8) following 'false' branch...\n           |......\n           |   21 |         if (minimum == arr1[i]) {\n           |      |                            ~\n           |      |                            |\n           |      |                            (9) ...to here\n           |......\n           |   30 |     printf(""Closest elements: %d %d %d\n"", res1, res2, res3);\n           |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           |      |     |\n           |      |     (10) use of uninitialized value 'res1' here\n           |\nUndefined symbols for architecture x86_64:\n  ""_max"", referenced from:\n      _threeClosestElements in ccuVwsQg.o\n  ""_min"", referenced from:\n      _threeClosestElements in ccuVwsQg.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
939§True§Checking collected_code/problem-939-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-939-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.01 seconds (4738 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
940§False§collected_code/problem-940-0.c:9:21: error: Cannot determine that 'arr[l]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (l < n && arr[l] > arr[largest])\n                    ^\ncollected_code/problem-940-0.c:9:30: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (l < n && arr[l] > arr[largest])\n                             ^\ncollected_code/problem-940-0.c:13:21: error: Cannot determine that 'arr[r]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (r < n && arr[r] > arr[largest])\n                    ^\ncollected_code/problem-940-0.c:13:30: error: Cannot determine that 'arr[largest]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    if (r < n && arr[r] > arr[largest])\n                             ^\ncollected_code/problem-940-0.c:37:15: error: Cannot determine that 'arr[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        swap(&arr[0], &arr[i]);\n              ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-940-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 41 in approximately 0.35 seconds (116 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-940-0.c: In function 'heapify':\ncollected_code/problem-940-0.c:19:9: warning: implicit declaration of function 'swap' [-Wimplicit-function-declaration]\n   19 |         swap(&arr[i], &arr[largest]);\n      |         ^~~~\nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\n  ""_swap"", referenced from:\n      _heapify in cciAQruB.o\n      _heapSort in cciAQruB.o\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
941§True§collected_code/problem-941-0.c:6:12: error: Cannot determine that '*list' is initialized [premium-bughuntingUninit]\n    while (*list) {\n           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-941-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.51 seconds (42 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
942§True§collected_code/problem-942-0.c:5:17: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list[i] == element) {\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-942-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3215 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
943§True§"collected_code/problem-943-0.c:7:18: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list1[i] < list2[j]) {\n                 ^\ncollected_code/problem-943-0.c:7:29: error: Cannot determine that 'list2[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list1[i] < list2[j]) {\n                            ^\ncollected_code/problem-943-0.c:8:36: error: Cannot determine that 'list1[i++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            mergedList[k++] = list1[i++];\n                                   ^\ncollected_code/problem-943-0.c:10:36: error: Cannot determine that 'list2[j++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            mergedList[k++] = list2[j++];\n                                   ^\ncollected_code/problem-943-0.c:15:32: error: Cannot determine that 'list1[i++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        mergedList[k++] = list1[i++];\n                               ^\ncollected_code/problem-943-0.c:19:32: error: Cannot determine that 'list2[j++]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        mergedList[k++] = list2[j++];\n                               ^\ncollected_code/problem-943-0.c:36:33: error: Cannot determine that 'mergedList[i]' is initialized [premium-bughuntingUninit]\n        printf(""%d "", mergedList[i]);\n                                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-943-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 40 in approximately 0.01 seconds (5568 lines/second)\nPhysical Source Lines of Code (SLOC) = 31\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 96.7742 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
944§True§"collected_code/problem-944-0.c:6:27: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for (int i = 0; string[i] != '\0'; i++) {\n                          ^\ncollected_code/problem-944-0.c:7:27: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (isdigit(string[i])) {\n                          ^\ncollected_code/problem-944-0.c:8:56: error: Cannot determine that 'string[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            printf(""Number: %c, Position: %d\n"", string[i], i);\n                                                       ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-944-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 21 in approximately 0.01 seconds (3443 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-944-0.c: In function 'separateAndPrintNumbers':\ncollected_code/problem-944-0.c:7:13: warning: implicit declaration of function 'isdigit' [-Wimplicit-function-declaration]\n    7 |         if (isdigit(string[i])) {\n      |             ^~~~~~~\ncollected_code/problem-944-0.c:2:1: note: include '<ctype.h>' or provide a declaration of 'isdigit'\n    1 | #include <stdio.h>\n  +++ |+#include <ctype.h>\n    2 | \n
945§True§Checking collected_code/problem-945-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-945-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.01 seconds (4306 lines/second)\nPhysical Source Lines of Code (SLOC) = 29\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 137.931 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
946§True§"collected_code/problem-946-0.c:16:25: error: Cannot determine that 'text[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length = strlen(text);\n                        ^\ncollected_code/problem-946-0.c:81:11: error: Cannot determine that 'text[0]' is initialized [premium-bughuntingUninit]\n    fgets(text, sizeof(text), stdin);\n          ^\ncollected_code/problem-946-0.c:87:34: error: Cannot determine that 'result[i] members' is initialized [premium-bughuntingUninit]\n        printf(""%s: %d\n"", result[i].element, result[i].count);\n                                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-946-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-946-0.c:48:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-946-0.c:68:  [4] (buffer) strcpy:\n  Does not check for buffer overflows when copying to destination [MS-banned]\n  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy\n  easily misused).\ncollected_code/problem-946-0.c:8:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-946-0.c:21:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-946-0.c:76:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\ncollected_code/problem-946-0.c:16:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\ncollected_code/problem-946-0.c:32:  [1] (buffer) strncat:\n  Easily used incorrectly (e.g., incorrectly computing the correct maximum\n  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,\n  or automatically resizing strings.\n\nANALYSIS SUMMARY:\n\nHits = 7\nLines analyzed = 90 in approximately 0.01 seconds (11059 lines/second)\nPhysical Source Lines of Code (SLOC) = 72\nHits@level = [0]   3 [1]   2 [2]   3 [3]   0 [4]   2 [5]   0\nHits@level+ = [0+]  10 [1+]   7 [2+]   5 [3+]   2 [4+]   2 [5+]   0\nHits/KSLOC@level+ = [0+] 138.889 [1+] 97.2222 [2+] 69.4444 [3+] 27.7778 [4+] 27.7778 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
947§True§"collected_code/problem-947-0.c:6:26: error: Cannot determine that 'sentence[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char* token = strtok(sentence, "" "");\n                         ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-947-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-947-0.c:8:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 21 in approximately 0.01 seconds (1534 lines/second)\nPhysical Source Lines of Code (SLOC) = 20\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 100 [1+]  50 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
948§True§collected_code/problem-948-0.c:4:17: error: Cannot determine that 'tuple[index]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    return tuple[index];\n                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-948-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 13 in approximately 0.37 seconds (35 lines/second)\nPhysical Source Lines of Code (SLOC) = 11\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 90.9091 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
949§True§collected_code/problem-949-0.c:16:16: error: Cannot determine that '*a' is initialized [premium-bughuntingUninit]\n    int temp = *a;\n               ^\ncollected_code/problem-949-0.c:17:10: error: Cannot determine that '*b' is initialized [premium-bughuntingUninit]\n    *a = *b;\n         ^\ncollected_code/problem-949-0.c:25:44: error: Cannot determine that 'tuples[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int digits1 = findDigits(tuples[j]);\n                                           ^\ncollected_code/problem-949-0.c:26:44: error: Cannot determine that 'tuples[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            int digits2 = findDigits(tuples[j + 1]);\n                                           ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-949-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 46 in approximately 0.45 seconds (102 lines/second)\nPhysical Source Lines of Code (SLOC) = 36\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
950§True§"collected_code/problem-950-0.c:50:18: error: Cannot determine that 'year' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &year);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-950-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 52 in approximately 0.01 seconds (5563 lines/second)\nPhysical Source Lines of Code (SLOC) = 51\nHits@level = [0]  15 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]  15 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 294.118 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
951§True§collected_code/problem-951-0.c:7:18: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list1[i] == list2[i] && list1[i] > maxIndex) {\n                 ^\ncollected_code/problem-951-0.c:7:30: error: Cannot determine that 'list2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (list1[i] == list2[i] && list1[i] > maxIndex) {\n                             ^\ncollected_code/problem-951-0.c:8:29: error: Cannot determine that 'list1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            maxIndex = list1[i];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-951-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (2952 lines/second)\nPhysical Source Lines of Code (SLOC) = 18\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 55.5556 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
952§True§Checking collected_code/problem-952-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-952-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 53 in approximately 0.50 seconds (106 lines/second)\nPhysical Source Lines of Code (SLOC) = 41\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 24.3902 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
953§True§collected_code/problem-953-0.c:13:20: error: Cannot determine that 'arr[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                   ^\ncollected_code/problem-953-0.c:13:30: error: Cannot determine that 'arr[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (arr[i] == arr[j])\n                             ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-953-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 31 in approximately 0.55 seconds (57 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 43.4783 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
954§True§Checking collected_code/problem-954-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-954-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 24 in approximately 0.01 seconds (3817 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 95.2381 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
955§True§"collected_code/problem-955-0.c:22:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-955-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.01 seconds (3732 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   4 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   4 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 160 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
956§True§collected_code/problem-956-0.c:15:26: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    char* token = strtok(str, pattern);\n                         ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-956-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 27 in approximately 0.20 seconds (137 lines/second)\nPhysical Source Lines of Code (SLOC) = 23\nHits@level = [0]   2 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 86.9565 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-956-0.c: In function 'splitString':\ncollected_code/problem-956-0.c:15:19: warning: implicit declaration of function 'strtok' [-Wimplicit-function-declaration]\n   15 |     char* token = strtok(str, pattern);\n      |                   ^~~~~~\ncollected_code/problem-956-0.c:15:19: warning: initialization of 'char *' from 'int' makes pointer from integer without a cast [-Wint-conversion]\ncollected_code/problem-956-0.c:18:15: warning: assignment to 'char *' from 'int' makes pointer from integer without a cast [-Wint-conversion]\n   18 |         token = strtok(NULL, pattern);\n      |               ^\n
957§True§Checking collected_code/problem-957-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-957-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3059 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
958§True§"collected_code/problem-958-0.c:20:18: error: Cannot determine that 'number' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &number);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-958-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 30 in approximately 0.31 seconds (97 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   6 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   6 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 240 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
959§True§collected_code/problem-959-0.c:7:16: error: Cannot determine that 'list[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    sum += list[i];\n               ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-959-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 18 in approximately 0.63 seconds (29 lines/second)\nPhysical Source Lines of Code (SLOC) = 16\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 62.5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
960§True§"collected_code/problem-960-0.c:21:18: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &n);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-960-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 23 in approximately 0.01 seconds (3563 lines/second)\nPhysical Source Lines of Code (SLOC) = 22\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 136.364 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
961§False§collected_code/problem-961-0.c:4:25: error: Cannot determine that 's[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int length = strlen(s);\n                        ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-961-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-961-0.c:4:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 43 in approximately 0.54 seconds (80 lines/second)\nPhysical Source Lines of Code (SLOC) = 43\nHits@level = [0]   0 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 23.2558 [1+] 23.2558 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"collected_code/problem-961-0.c: In function 'romanToInt':\ncollected_code/problem-961-0.c:4:18: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n    4 |     int length = strlen(s);\n      |                  ^~~~~~\ncollected_code/problem-961-0.c:1:1: note: include '<string.h>' or provide a declaration of 'strlen'\n  +++ |+#include <string.h>\n    1 | int romanToInt(char *s) {\ncollected_code/problem-961-0.c:4:18: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n    4 |     int length = strlen(s);\n      |                  ^~~~~~\ncollected_code/problem-961-0.c:4:18: note: include '<string.h>' or provide a declaration of 'strlen'\nUndefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
962§False§Checking collected_code/problem-962-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-962-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 7 in approximately 0.01 seconds (954 lines/second)\nPhysical Source Lines of Code (SLOC) = 8\nHits@level = [0]   0 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]   0 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§"Undefined symbols for architecture x86_64:\n  ""_main"", referenced from:\n     implicit entry/start for main executable\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n"
963§True§"collected_code/problem-963-0.c:10:24: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                       ^\ncollected_code/problem-963-0.c:10:28: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                           ^\ncollected_code/problem-963-0.c:10:32: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf(""%f %f %f"", &a, &b, &c);\n                               ^\ncollected_code/problem-963-0.c:12:42: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    discriminant = calculateDiscriminant(a, b, c);\n                                         ^\ncollected_code/problem-963-0.c:12:45: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    discriminant = calculateDiscriminant(a, b, c);\n                                            ^\ncollected_code/problem-963-0.c:12:48: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    discriminant = calculateDiscriminant(a, b, c);\n                                               ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-963-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.25 seconds (98 lines/second)\nPhysical Source Lines of Code (SLOC) = 17\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 176.471 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
964§True§Checking collected_code/problem-964-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-964-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-964-0.c:5:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 20 in approximately 0.01 seconds (2996 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   2 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 157.895 [1+] 52.6316 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
965§True§collected_code/problem-965-0.c:8:26: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    for(i = 0, j = 0; str[i] != '\0'; i++, j++) {\n                         ^\ncollected_code/problem-965-0.c:9:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        c = str[i];\n               ^\ncollected_code/problem-965-0.c:25:11: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    fgets(str, sizeof(str),stdin);\n          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-965-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-965-0.c:22:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 31 in approximately 0.01 seconds (4495 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   2 [1]   0 [2]   1 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   1 [2+]   1 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+] 41.6667 [2+] 41.6667 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
966§True§collected_code/problem-966-0.c:5:25: error: Cannot determine that '*sizePtr' is initialized [premium-bughuntingUninit]\n    for (int i = 0; i < *sizePtr; i++) {\n                        ^\ncollected_code/problem-966-0.c:6:22: error: Cannot determine that 'tuples[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuples[i][0] != 0 && tuples[i][1] != 0) {\n                     ^\ncollected_code/problem-966-0.c:6:43: error: Cannot determine that 'tuples[i][1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (tuples[i][0] != 0 && tuples[i][1] != 0) {\n                                          ^\ncollected_code/problem-966-0.c:7:43: error: Cannot determine that 'tuples[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            tuples[newSize][0] = tuples[i][0];\n                                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-966-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.01 seconds (3168 lines/second)\nPhysical Source Lines of Code (SLOC) = 21\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 47.619 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
967§True§"collected_code/problem-967-0.c:7:15: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    while (str[i] != '\0') {\n              ^\ncollected_code/problem-967-0.c:8:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        if (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u' ||\n               ^\ncollected_code/problem-967-0.c:9:16: error: Cannot determine that 'str[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U') {\n               ^\ncollected_code/problem-967-0.c:26:17: error: Cannot determine that 'str[0]' is initialized [premium-bughuntingUninit]\n    scanf(""%s"", str);\n                ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-967-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-967-0.c:26:  [4] (buffer) scanf:\n  The scanf() family's %s operation, without a limit specification, permits\n  buffer overflows (CWE-120, CWE-20). Specify a limit to %s, or use a\n  different input function.\ncollected_code/problem-967-0.c:23:  [2] (buffer) char:\n  Statically-sized arrays can be improperly restricted, leading to potential\n  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use\n  functions that limit length, or ensure that the size is larger than the\n  maximum possible length.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 34 in approximately 0.01 seconds (3216 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   3 [1]   0 [2]   1 [3]   0 [4]   1 [5]   0\nHits@level+ = [0+]   5 [1+]   2 [2+]   2 [3+]   1 [4+]   1 [5+]   0\nHits/KSLOC@level+ = [0+] 178.571 [1+] 71.4286 [2+] 71.4286 [3+] 35.7143 [4+] 35.7143 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
968§True§Checking collected_code/problem-968-0.c ...\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-968-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.36 seconds (95 lines/second)\nPhysical Source Lines of Code (SLOC) = 25\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+]  40 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
969§True§collected_code/problem-969-0.c:12:26: error: Cannot determine that 'tuples[j][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (tuples[j][0] > tuples[j+1][0]) {\n                         ^\ncollected_code/problem-969-0.c:12:43: error: Cannot determine that 'tuples[j+1][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n            if (tuples[j][0] > tuples[j+1][0]) {\n                                          ^\ncollected_code/problem-969-0.c:14:24: error: Cannot determine that 'temp[0]' is initialized [premium-bughuntingUninit]\n                memcpy(temp, tuples[j], sizeof(temp));\n                       ^\ncollected_code/problem-969-0.c:14:36: error: Cannot determine that 'tuples[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                memcpy(temp, tuples[j], sizeof(temp));\n                                   ^\ncollected_code/problem-969-0.c:15:30: error: Cannot determine that 'tuples[j]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                memcpy(tuples[j], tuples[j+1], sizeof(temp));\n                             ^\ncollected_code/problem-969-0.c:15:41: error: Cannot determine that 'tuples[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                memcpy(tuples[j], tuples[j+1], sizeof(temp));\n                                        ^\ncollected_code/problem-969-0.c:16:30: error: Cannot determine that 'tuples[j+1]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n                memcpy(tuples[j+1], temp, sizeof(temp));\n                             ^\ncollected_code/problem-969-0.c:23:33: error: Cannot determine that 'tuples[i][0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        tuples[k][0] = tuples[i][0];\n                                ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-969-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-969-0.c:15:  [2] (buffer) memcpy:\n  Does not check for buffer overflows when copying to destination (CWE-120).\n  Make sure destination can always hold the source data.\ncollected_code/problem-969-0.c:16:  [2] (buffer) memcpy:\n  Does not check for buffer overflows when copying to destination (CWE-120).\n  Make sure destination can always hold the source data.\n\nANALYSIS SUMMARY:\n\nHits = 2\nLines analyzed = 51 in approximately 0.36 seconds (140 lines/second)\nPhysical Source Lines of Code (SLOC) = 41\nHits@level = [0]   1 [1]   0 [2]   2 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   2 [2+]   2 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 73.1707 [1+] 48.7805 [2+] 48.7805 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
970§True§"collected_code/problem-970-0.c:10:18: error: Cannot determine that 'num1' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num1);\n                 ^\ncollected_code/problem-970-0.c:12:18: error: Cannot determine that 'num2' is initialized [premium-bughuntingUninit]\n    scanf(""%d"", &num2);\n                 ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-970-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 15 in approximately 0.17 seconds (90 lines/second)\nPhysical Source Lines of Code (SLOC) = 14\nHits@level = [0]   5 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   5 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 357.143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
971§True§"collected_code/problem-971-0.c:22:27: error: Cannot determine that 'a' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d %d"", &a, &b, &c, &n);\n                          ^\ncollected_code/problem-971-0.c:22:31: error: Cannot determine that 'b' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d %d"", &a, &b, &c, &n);\n                              ^\ncollected_code/problem-971-0.c:22:35: error: Cannot determine that 'c' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d %d"", &a, &b, &c, &n);\n                                  ^\ncollected_code/problem-971-0.c:22:39: error: Cannot determine that 'n' is initialized [premium-bughuntingUninit]\n    scanf(""%d %d %d %d"", &a, &b, &c, &n);\n                                      ^\n"§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-971-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 25 in approximately 0.36 seconds (69 lines/second)\nPhysical Source Lines of Code (SLOC) = 24\nHits@level = [0]   3 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   3 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 125 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
972§True§collected_code/problem-972-0.c:10:9: error: Cannot determine that 'nestedTuple' is initialized [premium-bughuntingUninit]\n        nestedTuple[i] = (int*) malloc(sizeof(int));\n        ^\ncollected_code/problem-972-0.c:11:35: error: Cannot determine that 'tuple1[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        nestedTuple[i][0] = tuple1[i];\n                                  ^\ncollected_code/problem-972-0.c:17:43: error: Cannot determine that 'tuple2[i]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        nestedTuple[size1 + i][0] = tuple2[i];\n                                          ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-972-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 39 in approximately 0.01 seconds (4720 lines/second)\nPhysical Source Lines of Code (SLOC) = 27\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 37.037 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-972-0.c: In function 'concatenateTuples':\ncollected_code/problem-972-0.c:10:24: warning: dereference of possibly-NULL 'nestedTuple' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   10 |         nestedTuple[i] = (int*) malloc(sizeof(int));\n      |         ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'concatenateTuples': events 1-4\n    |\n    |    6 |     int** nestedTuple = (int**) malloc((size1 + size2) * sizeof(int*));\n    |      |                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                 |\n    |      |                                 (1) this call could return NULL\n    |......\n    |    9 |     for (int i = 0; i < size1; i++) {\n    |      |                     ~~~~~~~~~    \n    |      |                       |\n    |      |                       (2) following 'true' branch (when 'i < size1')...\n    |   10 |         nestedTuple[i] = (int*) malloc(sizeof(int));\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                    |   |\n    |      |                    |   (4) 'nestedTuple + (long unsigned int)i * 8' could be NULL: unchecked value from (1)\n    |      |                    (3) ...to here\n    |\ncollected_code/problem-972-0.c:11:27: warning: dereference of possibly-NULL '*nestedTuple_38 + _12' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   11 |         nestedTuple[i][0] = tuple1[i];\n      |         ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n  'concatenateTuples': events 1-4\n    |\n    |    9 |     for (int i = 0; i < size1; i++) {\n    |      |                     ~~^~~~~~~\n    |      |                       |\n    |      |                       (1) following 'true' branch (when 'i < size1')...\n    |   10 |         nestedTuple[i] = (int*) malloc(sizeof(int));\n    |      |                    ~            ~~~~~~~~~~~~~~~~~~~\n    |      |                    |            |\n    |      |                    |            (3) this call could return NULL\n    |      |                    (2) ...to here\n    |   11 |         nestedTuple[i][0] = tuple1[i];\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                           |\n    |      |                           (4) '*nestedTuple_38 + _12' could be NULL: unchecked value from (3)\n    |\ncollected_code/problem-972-0.c:17:35: warning: dereference of possibly-NULL '*nestedTuple_38 + _26' [CWE-690] [-Wanalyzer-possible-null-dereference]\n   17 |         nestedTuple[size1 + i][0] = tuple2[i];\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n  'concatenateTuples': events 1-6\n    |\n    |    9 |     for (int i = 0; i < size1; i++) {\n    |      |                     ~~^~~~~~~\n    |      |                       |\n    |      |                       (1) following 'false' branch (when 'i >= size1')...\n    |......\n    |   15 |     for (int i = 0; i < size2; i++) {\n    |      |              ~      ~~~~~~~~~\n    |      |              |        |\n    |      |              |        (3) following 'true' branch (when 'i < size2')...\n    |      |              (2) ...to here\n    |   16 |         nestedTuple[size1 + i] = (int*) malloc(sizeof(int));\n    |      |                     ~~~~~~~~~           ~~~~~~~~~~~~~~~~~~~\n    |      |                           |             |\n    |      |                           |             (5) this call could return NULL\n    |      |                           (4) ...to here\n    |   17 |         nestedTuple[size1 + i][0] = tuple2[i];\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                   |\n    |      |                                   (6) '*nestedTuple_38 + _26' could be NULL: unchecked value from (5)\n    |\n
973§True§collected_code/problem-973-0.c:4:22: error: Cannot determine that 'str[0]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n    int len = strlen(str);\n                     ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-973-0.c\n\nFINAL RESULTS:\n\ncollected_code/problem-973-0.c:4:  [1] (buffer) strlen:\n  Does not handle strings that are not \0-terminated; if given one it may\n  perform an over-read (it could cause a crash if unprotected) (CWE-126).\n\nANALYSIS SUMMARY:\n\nHits = 1\nLines analyzed = 26 in approximately 0.25 seconds (102 lines/second)\nPhysical Source Lines of Code (SLOC) = 19\nHits@level = [0]   1 [1]   1 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   2 [1+]   1 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 105.263 [1+] 52.6316 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nNot every hit is necessarily a security vulnerability.\nYou can inhibit a report by adding a comment in this form:\n// flawfinder: ignore\nMake *sure* it's a false positive!\nYou can use the option --neverignore to show these.\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§collected_code/problem-973-0.c: In function 'leftRotateString':\ncollected_code/problem-973-0.c:4:15: warning: implicit declaration of function 'strlen' [-Wimplicit-function-declaration]\n    4 |     int len = strlen(str);\n      |               ^~~~~~\ncollected_code/problem-973-0.c:2:1: note: include '<string.h>' or provide a declaration of 'strlen'\n    1 | #include <stdio.h>\n  +++ |+#include <string.h>\n    2 | \ncollected_code/problem-973-0.c:4:15: warning: incompatible implicit declaration of built-in function 'strlen' [-Wbuiltin-declaration-mismatch]\n    4 |     int len = strlen(str);\n      |               ^~~~~~\ncollected_code/problem-973-0.c:4:15: note: include '<string.h>' or provide a declaration of 'strlen'\n
974§True§collected_code/problem-974-0.c:7:29: error: Cannot determine that 'triangle[row][col]' is initialized (since function parameter is not 'const' it is assumed it points at uninitialized data) [premium-bughuntingUninitNonConstArg]\n        return triangle[row][col];\n                            ^\n§Flawfinder version 2.0.19, (C) 2001-2019 David A. Wheeler.\nNumber of rules (primarily dangerous function names) in C/C++ ruleset: 222\nExamining collected_code/problem-974-0.c\n\nFINAL RESULTS:\n\n\nANALYSIS SUMMARY:\n\nNo hits found.\nLines analyzed = 34 in approximately 0.01 seconds (4209 lines/second)\nPhysical Source Lines of Code (SLOC) = 28\nHits@level = [0]   1 [1]   0 [2]   0 [3]   0 [4]   0 [5]   0\nHits@level+ = [0+]   1 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nHits/KSLOC@level+ = [0+] 35.7143 [1+]   0 [2+]   0 [3+]   0 [4+]   0 [5+]   0\nMinimum risk level = 1\n\nThere may be other security vulnerabilities; review your code!\nSee 'Secure Programming HOWTO'\n(https://dwheeler.com/secure-programs) for more information.\n§
